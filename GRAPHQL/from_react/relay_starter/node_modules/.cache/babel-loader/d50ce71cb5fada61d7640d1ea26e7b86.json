{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar invariant = require('invariant');\n/**\n * JS maps (both plain objects and Map) maintain key insertion\n * order, which means there is an easy way to simulate LRU behavior\n * that should also perform quite well:\n *\n * To insert a new value, first delete the key from the inner _map,\n * then _map.set(k, v). By deleting and reinserting, you ensure that the\n * map sees the key as the last inserted key.\n *\n * Get does the same: if the key is present, delete and reinsert it.\n */\n\n\nvar LRUCache = /*#__PURE__*/function () {\n  function LRUCache(capacity) {\n    this._capacity = capacity;\n    !(this._capacity > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'LRUCache: Unable to create instance of cache with zero or negative capacity.') : invariant(false) : void 0;\n    this._map = new Map();\n  }\n\n  var _proto = LRUCache.prototype;\n\n  _proto.set = function set(key, value) {\n    this._map[\"delete\"](key);\n\n    this._map.set(key, value);\n\n    if (this._map.size > this._capacity) {\n      var firstKey = this._map.keys().next();\n\n      if (!firstKey.done) {\n        this._map[\"delete\"](firstKey.value);\n      }\n    }\n  };\n\n  _proto.get = function get(key) {\n    var value = this._map.get(key);\n\n    if (value != null) {\n      this._map[\"delete\"](key);\n\n      this._map.set(key, value);\n    }\n\n    return value;\n  };\n\n  _proto.has = function has(key) {\n    return this._map.has(key);\n  };\n\n  _proto[\"delete\"] = function _delete(key) {\n    this._map[\"delete\"](key);\n  };\n\n  _proto.size = function size() {\n    return this._map.size;\n  };\n\n  _proto.capacity = function capacity() {\n    return this._capacity - this._map.size;\n  };\n\n  _proto.clear = function clear() {\n    this._map.clear();\n  };\n\n  return LRUCache;\n}();\n\nfunction create(capacity) {\n  return new LRUCache(capacity);\n}\n\nmodule.exports = {\n  create: create\n};","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/react-relay/lib/relay-hooks/LRUCache.js"],"names":["invariant","require","LRUCache","capacity","_capacity","process","env","NODE_ENV","_map","Map","_proto","prototype","set","key","value","size","firstKey","keys","next","done","get","has","_delete","clear","create","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIC,QAAQ,GAAG,aAAa,YAAY;AACtC,WAASA,QAAT,CAAkBC,QAAlB,EAA4B;AAC1B,SAAKC,SAAL,GAAiBD,QAAjB;AACA,MAAE,KAAKC,SAAL,GAAiB,CAAnB,IAAwBC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCP,SAAS,CAAC,KAAD,EAAQ,8EAAR,CAAjD,GAA2IA,SAAS,CAAC,KAAD,CAA5K,GAAsL,KAAK,CAA3L;AACA,SAAKQ,IAAL,GAAY,IAAIC,GAAJ,EAAZ;AACD;;AAED,MAAIC,MAAM,GAAGR,QAAQ,CAACS,SAAtB;;AAEAD,EAAAA,MAAM,CAACE,GAAP,GAAa,SAASA,GAAT,CAAaC,GAAb,EAAkBC,KAAlB,EAAyB;AACpC,SAAKN,IAAL,CAAU,QAAV,EAAoBK,GAApB;;AAEA,SAAKL,IAAL,CAAUI,GAAV,CAAcC,GAAd,EAAmBC,KAAnB;;AAEA,QAAI,KAAKN,IAAL,CAAUO,IAAV,GAAiB,KAAKX,SAA1B,EAAqC;AACnC,UAAIY,QAAQ,GAAG,KAAKR,IAAL,CAAUS,IAAV,GAAiBC,IAAjB,EAAf;;AAEA,UAAI,CAACF,QAAQ,CAACG,IAAd,EAAoB;AAClB,aAAKX,IAAL,CAAU,QAAV,EAAoBQ,QAAQ,CAACF,KAA7B;AACD;AACF;AACF,GAZD;;AAcAJ,EAAAA,MAAM,CAACU,GAAP,GAAa,SAASA,GAAT,CAAaP,GAAb,EAAkB;AAC7B,QAAIC,KAAK,GAAG,KAAKN,IAAL,CAAUY,GAAV,CAAcP,GAAd,CAAZ;;AAEA,QAAIC,KAAK,IAAI,IAAb,EAAmB;AACjB,WAAKN,IAAL,CAAU,QAAV,EAAoBK,GAApB;;AAEA,WAAKL,IAAL,CAAUI,GAAV,CAAcC,GAAd,EAAmBC,KAAnB;AACD;;AAED,WAAOA,KAAP;AACD,GAVD;;AAYAJ,EAAAA,MAAM,CAACW,GAAP,GAAa,SAASA,GAAT,CAAaR,GAAb,EAAkB;AAC7B,WAAO,KAAKL,IAAL,CAAUa,GAAV,CAAcR,GAAd,CAAP;AACD,GAFD;;AAIAH,EAAAA,MAAM,CAAC,QAAD,CAAN,GAAmB,SAASY,OAAT,CAAiBT,GAAjB,EAAsB;AACvC,SAAKL,IAAL,CAAU,QAAV,EAAoBK,GAApB;AACD,GAFD;;AAIAH,EAAAA,MAAM,CAACK,IAAP,GAAc,SAASA,IAAT,GAAgB;AAC5B,WAAO,KAAKP,IAAL,CAAUO,IAAjB;AACD,GAFD;;AAIAL,EAAAA,MAAM,CAACP,QAAP,GAAkB,SAASA,QAAT,GAAoB;AACpC,WAAO,KAAKC,SAAL,GAAiB,KAAKI,IAAL,CAAUO,IAAlC;AACD,GAFD;;AAIAL,EAAAA,MAAM,CAACa,KAAP,GAAe,SAASA,KAAT,GAAiB;AAC9B,SAAKf,IAAL,CAAUe,KAAV;AACD,GAFD;;AAIA,SAAOrB,QAAP;AACD,CAxD2B,EAA5B;;AA0DA,SAASsB,MAAT,CAAgBrB,QAAhB,EAA0B;AACxB,SAAO,IAAID,QAAJ,CAAaC,QAAb,CAAP;AACD;;AAEDsB,MAAM,CAACC,OAAP,GAAiB;AACfF,EAAAA,MAAM,EAAEA;AADO,CAAjB","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar invariant = require('invariant');\n\n/**\n * JS maps (both plain objects and Map) maintain key insertion\n * order, which means there is an easy way to simulate LRU behavior\n * that should also perform quite well:\n *\n * To insert a new value, first delete the key from the inner _map,\n * then _map.set(k, v). By deleting and reinserting, you ensure that the\n * map sees the key as the last inserted key.\n *\n * Get does the same: if the key is present, delete and reinsert it.\n */\nvar LRUCache = /*#__PURE__*/function () {\n  function LRUCache(capacity) {\n    this._capacity = capacity;\n    !(this._capacity > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'LRUCache: Unable to create instance of cache with zero or negative capacity.') : invariant(false) : void 0;\n    this._map = new Map();\n  }\n\n  var _proto = LRUCache.prototype;\n\n  _proto.set = function set(key, value) {\n    this._map[\"delete\"](key);\n\n    this._map.set(key, value);\n\n    if (this._map.size > this._capacity) {\n      var firstKey = this._map.keys().next();\n\n      if (!firstKey.done) {\n        this._map[\"delete\"](firstKey.value);\n      }\n    }\n  };\n\n  _proto.get = function get(key) {\n    var value = this._map.get(key);\n\n    if (value != null) {\n      this._map[\"delete\"](key);\n\n      this._map.set(key, value);\n    }\n\n    return value;\n  };\n\n  _proto.has = function has(key) {\n    return this._map.has(key);\n  };\n\n  _proto[\"delete\"] = function _delete(key) {\n    this._map[\"delete\"](key);\n  };\n\n  _proto.size = function size() {\n    return this._map.size;\n  };\n\n  _proto.capacity = function capacity() {\n    return this._capacity - this._map.size;\n  };\n\n  _proto.clear = function clear() {\n    this._map.clear();\n  };\n\n  return LRUCache;\n}();\n\nfunction create(capacity) {\n  return new LRUCache(capacity);\n}\n\nmodule.exports = {\n  create: create\n};"]},"metadata":{},"sourceType":"script"}