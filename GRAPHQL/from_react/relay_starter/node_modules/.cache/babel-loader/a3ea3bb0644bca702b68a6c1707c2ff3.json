{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar getRelayHandleKey = require('../util/getRelayHandleKey');\n\nvar RelayConcreteNode = require('../util/RelayConcreteNode');\n\nvar stableCopy = require('../util/stableCopy');\n\nvar invariant = require('invariant');\n\nvar VARIABLE = RelayConcreteNode.VARIABLE,\n    LITERAL = RelayConcreteNode.LITERAL,\n    OBJECT_VALUE = RelayConcreteNode.OBJECT_VALUE,\n    LIST_VALUE = RelayConcreteNode.LIST_VALUE;\nvar MODULE_COMPONENT_KEY_PREFIX = '__module_component_';\nvar MODULE_OPERATION_KEY_PREFIX = '__module_operation_';\n\nfunction getArgumentValue(arg, variables) {\n  if (arg.kind === VARIABLE) {\n    // Variables are provided at runtime and are not guaranteed to be stable.\n    return getStableVariableValue(arg.variableName, variables);\n  } else if (arg.kind === LITERAL) {\n    // The Relay compiler generates stable ConcreteArgument values.\n    return arg.value;\n  } else if (arg.kind === OBJECT_VALUE) {\n    var value = {};\n    arg.fields.forEach(function (field) {\n      value[field.name] = getArgumentValue(field, variables);\n    });\n    return value;\n  } else if (arg.kind === LIST_VALUE) {\n    var _value = [];\n    arg.items.forEach(function (item) {\n      item != null ? _value.push(getArgumentValue(item, variables)) : null;\n    });\n    return _value;\n  }\n}\n/**\n * Returns the values of field/fragment arguments as an object keyed by argument\n * names. Guaranteed to return a result with stable ordered nested values.\n */\n\n\nfunction getArgumentValues(args, variables) {\n  var values = {};\n  args.forEach(function (arg) {\n    values[arg.name] = getArgumentValue(arg, variables);\n  });\n  return values;\n}\n/**\n * Given a handle field and variable values, returns a key that can be used to\n * uniquely identify the combination of the handle name and argument values.\n *\n * Note: the word \"storage\" here refers to the fact this key is primarily used\n * when writing the results of a key in a normalized graph or \"store\". This\n * name was used in previous implementations of Relay internals and is also\n * used here for consistency.\n */\n\n\nfunction getHandleStorageKey(handleField, variables) {\n  var dynamicKey = handleField.dynamicKey,\n      handle = handleField.handle,\n      key = handleField.key,\n      name = handleField.name,\n      args = handleField.args,\n      filters = handleField.filters;\n  var handleName = getRelayHandleKey(handle, key, name);\n  var filterArgs = null;\n\n  if (args && filters && args.length !== 0 && filters.length !== 0) {\n    filterArgs = args.filter(function (arg) {\n      return filters.indexOf(arg.name) > -1;\n    });\n  }\n\n  if (dynamicKey) {\n    // \"Sort\" the arguments by argument name: this is done by the compiler for\n    // user-supplied arguments but the dynamic argument must also be in sorted\n    // order.  Note that dynamic key argument name is double-underscore-\n    // -prefixed, and a double-underscore prefix is disallowed for user-supplied\n    // argument names, so there's no need to actually sort.\n    filterArgs = filterArgs != null ? [dynamicKey].concat((0, _toConsumableArray2[\"default\"])(filterArgs)) : [dynamicKey];\n  }\n\n  if (filterArgs === null) {\n    return handleName;\n  } else {\n    return formatStorageKey(handleName, getArgumentValues(filterArgs, variables));\n  }\n}\n/**\n * Given a field and variable values, returns a key that can be used to\n * uniquely identify the combination of the field name and argument values.\n *\n * Note: the word \"storage\" here refers to the fact this key is primarily used\n * when writing the results of a key in a normalized graph or \"store\". This\n * name was used in previous implementations of Relay internals and is also\n * used here for consistency.\n */\n\n\nfunction getStorageKey(field, variables) {\n  if (field.storageKey) {\n    // TODO T23663664: Handle nodes do not yet define a static storageKey.\n    return field.storageKey;\n  }\n\n  var args = typeof field.args === 'undefined' ? undefined : field.args;\n  var name = field.name;\n  return args && args.length !== 0 ? formatStorageKey(name, getArgumentValues(args, variables)) : name;\n}\n/**\n * Given a `name` (eg. \"foo\") and an object representing argument values\n * (eg. `{orberBy: \"name\", first: 10}`) returns a unique storage key\n * (ie. `foo{\"first\":10,\"orderBy\":\"name\"}`).\n *\n * This differs from getStorageKey which requires a ConcreteNode where arguments\n * are assumed to already be sorted into a stable order.\n */\n\n\nfunction getStableStorageKey(name, args) {\n  return formatStorageKey(name, stableCopy(args));\n}\n/**\n * Given a name and argument values, format a storage key.\n *\n * Arguments and the values within them are expected to be ordered in a stable\n * alphabetical ordering.\n */\n\n\nfunction formatStorageKey(name, argValues) {\n  if (!argValues) {\n    return name;\n  }\n\n  var values = [];\n\n  for (var argName in argValues) {\n    if (argValues.hasOwnProperty(argName)) {\n      var value = argValues[argName];\n\n      if (value != null) {\n        var _JSON$stringify;\n\n        values.push(argName + ':' + ((_JSON$stringify = JSON.stringify(value)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 'undefined'));\n      }\n    }\n  }\n\n  return values.length === 0 ? name : name + \"(\".concat(values.join(','), \")\");\n}\n/**\n * Given Variables and a variable name, return a variable value with\n * all values in a stable order.\n */\n\n\nfunction getStableVariableValue(name, variables) {\n  !variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'getVariableValue(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n  return stableCopy(variables[name]);\n}\n\nfunction getModuleComponentKey(documentName) {\n  return \"\".concat(MODULE_COMPONENT_KEY_PREFIX).concat(documentName);\n}\n\nfunction getModuleOperationKey(documentName) {\n  return \"\".concat(MODULE_OPERATION_KEY_PREFIX).concat(documentName);\n}\n/**\n * Constants shared by all implementations of RecordSource/MutableRecordSource/etc.\n */\n\n\nvar RelayStoreUtils = {\n  ACTOR_IDENTIFIER_KEY: '__actorIdentifier',\n  CLIENT_EDGE_TRAVERSAL_PATH: '__clientEdgeTraversalPath',\n  FRAGMENTS_KEY: '__fragments',\n  FRAGMENT_OWNER_KEY: '__fragmentOwner',\n  FRAGMENT_PROP_NAME_KEY: '__fragmentPropName',\n  MODULE_COMPONENT_KEY: '__module_component',\n  // alias returned by Reader\n  ID_KEY: '__id',\n  REF_KEY: '__ref',\n  REFS_KEY: '__refs',\n  ROOT_ID: 'client:root',\n  ROOT_TYPE: '__Root',\n  TYPENAME_KEY: '__typename',\n  INVALIDATED_AT_KEY: '__invalidated_at',\n  IS_WITHIN_UNMATCHED_TYPE_REFINEMENT: '__isWithinUnmatchedTypeRefinement',\n  RELAY_RESOLVER_VALUE_KEY: '__resolverValue',\n  RELAY_RESOLVER_INVALIDATION_KEY: '__resolverValueMayBeInvalid',\n  RELAY_RESOLVER_INPUTS_KEY: '__resolverInputValues',\n  RELAY_RESOLVER_READER_SELECTOR_KEY: '__resolverReaderSelector',\n  RELAY_RESOLVER_MISSING_REQUIRED_FIELDS_KEY: '__resolverMissingRequiredFields',\n  formatStorageKey: formatStorageKey,\n  getArgumentValue: getArgumentValue,\n  getArgumentValues: getArgumentValues,\n  getHandleStorageKey: getHandleStorageKey,\n  getStorageKey: getStorageKey,\n  getStableStorageKey: getStableStorageKey,\n  getModuleComponentKey: getModuleComponentKey,\n  getModuleOperationKey: getModuleOperationKey\n};\nmodule.exports = RelayStoreUtils;","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/store/RelayStoreUtils.js"],"names":["_interopRequireDefault","require","_toConsumableArray2","getRelayHandleKey","RelayConcreteNode","stableCopy","invariant","VARIABLE","LITERAL","OBJECT_VALUE","LIST_VALUE","MODULE_COMPONENT_KEY_PREFIX","MODULE_OPERATION_KEY_PREFIX","getArgumentValue","arg","variables","kind","getStableVariableValue","variableName","value","fields","forEach","field","name","_value","items","item","push","getArgumentValues","args","values","getHandleStorageKey","handleField","dynamicKey","handle","key","filters","handleName","filterArgs","length","filter","indexOf","concat","formatStorageKey","getStorageKey","storageKey","undefined","getStableStorageKey","argValues","argName","hasOwnProperty","_JSON$stringify","JSON","stringify","join","process","env","NODE_ENV","getModuleComponentKey","documentName","getModuleOperationKey","RelayStoreUtils","ACTOR_IDENTIFIER_KEY","CLIENT_EDGE_TRAVERSAL_PATH","FRAGMENTS_KEY","FRAGMENT_OWNER_KEY","FRAGMENT_PROP_NAME_KEY","MODULE_COMPONENT_KEY","ID_KEY","REF_KEY","REFS_KEY","ROOT_ID","ROOT_TYPE","TYPENAME_KEY","INVALIDATED_AT_KEY","IS_WITHIN_UNMATCHED_TYPE_REFINEMENT","RELAY_RESOLVER_VALUE_KEY","RELAY_RESOLVER_INVALIDATION_KEY","RELAY_RESOLVER_INPUTS_KEY","RELAY_RESOLVER_READER_SELECTOR_KEY","RELAY_RESOLVER_MISSING_REQUIRED_FIELDS_KEY","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar getRelayHandleKey = require('../util/getRelayHandleKey');\n\nvar RelayConcreteNode = require('../util/RelayConcreteNode');\n\nvar stableCopy = require('../util/stableCopy');\n\nvar invariant = require('invariant');\n\nvar VARIABLE = RelayConcreteNode.VARIABLE,\n    LITERAL = RelayConcreteNode.LITERAL,\n    OBJECT_VALUE = RelayConcreteNode.OBJECT_VALUE,\n    LIST_VALUE = RelayConcreteNode.LIST_VALUE;\nvar MODULE_COMPONENT_KEY_PREFIX = '__module_component_';\nvar MODULE_OPERATION_KEY_PREFIX = '__module_operation_';\n\nfunction getArgumentValue(arg, variables) {\n  if (arg.kind === VARIABLE) {\n    // Variables are provided at runtime and are not guaranteed to be stable.\n    return getStableVariableValue(arg.variableName, variables);\n  } else if (arg.kind === LITERAL) {\n    // The Relay compiler generates stable ConcreteArgument values.\n    return arg.value;\n  } else if (arg.kind === OBJECT_VALUE) {\n    var value = {};\n    arg.fields.forEach(function (field) {\n      value[field.name] = getArgumentValue(field, variables);\n    });\n    return value;\n  } else if (arg.kind === LIST_VALUE) {\n    var _value = [];\n    arg.items.forEach(function (item) {\n      item != null ? _value.push(getArgumentValue(item, variables)) : null;\n    });\n    return _value;\n  }\n}\n/**\n * Returns the values of field/fragment arguments as an object keyed by argument\n * names. Guaranteed to return a result with stable ordered nested values.\n */\n\n\nfunction getArgumentValues(args, variables) {\n  var values = {};\n  args.forEach(function (arg) {\n    values[arg.name] = getArgumentValue(arg, variables);\n  });\n  return values;\n}\n/**\n * Given a handle field and variable values, returns a key that can be used to\n * uniquely identify the combination of the handle name and argument values.\n *\n * Note: the word \"storage\" here refers to the fact this key is primarily used\n * when writing the results of a key in a normalized graph or \"store\". This\n * name was used in previous implementations of Relay internals and is also\n * used here for consistency.\n */\n\n\nfunction getHandleStorageKey(handleField, variables) {\n  var dynamicKey = handleField.dynamicKey,\n      handle = handleField.handle,\n      key = handleField.key,\n      name = handleField.name,\n      args = handleField.args,\n      filters = handleField.filters;\n  var handleName = getRelayHandleKey(handle, key, name);\n  var filterArgs = null;\n\n  if (args && filters && args.length !== 0 && filters.length !== 0) {\n    filterArgs = args.filter(function (arg) {\n      return filters.indexOf(arg.name) > -1;\n    });\n  }\n\n  if (dynamicKey) {\n    // \"Sort\" the arguments by argument name: this is done by the compiler for\n    // user-supplied arguments but the dynamic argument must also be in sorted\n    // order.  Note that dynamic key argument name is double-underscore-\n    // -prefixed, and a double-underscore prefix is disallowed for user-supplied\n    // argument names, so there's no need to actually sort.\n    filterArgs = filterArgs != null ? [dynamicKey].concat((0, _toConsumableArray2[\"default\"])(filterArgs)) : [dynamicKey];\n  }\n\n  if (filterArgs === null) {\n    return handleName;\n  } else {\n    return formatStorageKey(handleName, getArgumentValues(filterArgs, variables));\n  }\n}\n/**\n * Given a field and variable values, returns a key that can be used to\n * uniquely identify the combination of the field name and argument values.\n *\n * Note: the word \"storage\" here refers to the fact this key is primarily used\n * when writing the results of a key in a normalized graph or \"store\". This\n * name was used in previous implementations of Relay internals and is also\n * used here for consistency.\n */\n\n\nfunction getStorageKey(field, variables) {\n  if (field.storageKey) {\n    // TODO T23663664: Handle nodes do not yet define a static storageKey.\n    return field.storageKey;\n  }\n\n  var args = typeof field.args === 'undefined' ? undefined : field.args;\n  var name = field.name;\n  return args && args.length !== 0 ? formatStorageKey(name, getArgumentValues(args, variables)) : name;\n}\n/**\n * Given a `name` (eg. \"foo\") and an object representing argument values\n * (eg. `{orberBy: \"name\", first: 10}`) returns a unique storage key\n * (ie. `foo{\"first\":10,\"orderBy\":\"name\"}`).\n *\n * This differs from getStorageKey which requires a ConcreteNode where arguments\n * are assumed to already be sorted into a stable order.\n */\n\n\nfunction getStableStorageKey(name, args) {\n  return formatStorageKey(name, stableCopy(args));\n}\n/**\n * Given a name and argument values, format a storage key.\n *\n * Arguments and the values within them are expected to be ordered in a stable\n * alphabetical ordering.\n */\n\n\nfunction formatStorageKey(name, argValues) {\n  if (!argValues) {\n    return name;\n  }\n\n  var values = [];\n\n  for (var argName in argValues) {\n    if (argValues.hasOwnProperty(argName)) {\n      var value = argValues[argName];\n\n      if (value != null) {\n        var _JSON$stringify;\n\n        values.push(argName + ':' + ((_JSON$stringify = JSON.stringify(value)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 'undefined'));\n      }\n    }\n  }\n\n  return values.length === 0 ? name : name + \"(\".concat(values.join(','), \")\");\n}\n/**\n * Given Variables and a variable name, return a variable value with\n * all values in a stable order.\n */\n\n\nfunction getStableVariableValue(name, variables) {\n  !variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'getVariableValue(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n  return stableCopy(variables[name]);\n}\n\nfunction getModuleComponentKey(documentName) {\n  return \"\".concat(MODULE_COMPONENT_KEY_PREFIX).concat(documentName);\n}\n\nfunction getModuleOperationKey(documentName) {\n  return \"\".concat(MODULE_OPERATION_KEY_PREFIX).concat(documentName);\n}\n/**\n * Constants shared by all implementations of RecordSource/MutableRecordSource/etc.\n */\n\n\nvar RelayStoreUtils = {\n  ACTOR_IDENTIFIER_KEY: '__actorIdentifier',\n  CLIENT_EDGE_TRAVERSAL_PATH: '__clientEdgeTraversalPath',\n  FRAGMENTS_KEY: '__fragments',\n  FRAGMENT_OWNER_KEY: '__fragmentOwner',\n  FRAGMENT_PROP_NAME_KEY: '__fragmentPropName',\n  MODULE_COMPONENT_KEY: '__module_component',\n  // alias returned by Reader\n  ID_KEY: '__id',\n  REF_KEY: '__ref',\n  REFS_KEY: '__refs',\n  ROOT_ID: 'client:root',\n  ROOT_TYPE: '__Root',\n  TYPENAME_KEY: '__typename',\n  INVALIDATED_AT_KEY: '__invalidated_at',\n  IS_WITHIN_UNMATCHED_TYPE_REFINEMENT: '__isWithinUnmatchedTypeRefinement',\n  RELAY_RESOLVER_VALUE_KEY: '__resolverValue',\n  RELAY_RESOLVER_INVALIDATION_KEY: '__resolverValueMayBeInvalid',\n  RELAY_RESOLVER_INPUTS_KEY: '__resolverInputValues',\n  RELAY_RESOLVER_READER_SELECTOR_KEY: '__resolverReaderSelector',\n  RELAY_RESOLVER_MISSING_REQUIRED_FIELDS_KEY: '__resolverMissingRequiredFields',\n  formatStorageKey: formatStorageKey,\n  getArgumentValue: getArgumentValue,\n  getArgumentValues: getArgumentValues,\n  getHandleStorageKey: getHandleStorageKey,\n  getStorageKey: getStorageKey,\n  getStableStorageKey: getStableStorageKey,\n  getModuleComponentKey: getModuleComponentKey,\n  getModuleOperationKey: getModuleOperationKey\n};\nmodule.exports = RelayStoreUtils;"]},"metadata":{},"sourceType":"script"}