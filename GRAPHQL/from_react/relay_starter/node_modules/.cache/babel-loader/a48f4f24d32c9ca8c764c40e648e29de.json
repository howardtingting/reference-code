{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar ConnectionHandler = require('./ConnectionHandler');\n\nvar ConnectionInterface = require('./ConnectionInterface');\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar DeleteRecordHandler = {\n  update: function update(store, payload) {\n    var record = store.get(payload.dataID);\n\n    if (record != null) {\n      var idOrIds = record.getValue(payload.fieldKey);\n\n      if (typeof idOrIds === 'string') {\n        store[\"delete\"](idOrIds);\n      } else if (Array.isArray(idOrIds)) {\n        idOrIds.forEach(function (id) {\n          if (typeof id === 'string') {\n            store[\"delete\"](id);\n          }\n        });\n      }\n    }\n  }\n};\nvar DeleteEdgeHandler = {\n  update: function update(store, payload) {\n    var record = store.get(payload.dataID);\n\n    if (record == null) {\n      return;\n    }\n\n    var connections = payload.handleArgs.connections;\n    !(connections != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MutationHandlers: Expected connection IDs to be specified.') : invariant(false) : void 0;\n    var idOrIds = record.getValue(payload.fieldKey);\n    var idList = Array.isArray(idOrIds) ? idOrIds : [idOrIds];\n    idList.forEach(function (id) {\n      if (typeof id === 'string') {\n        var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(connections),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var connectionID = _step.value;\n            var connection = store.get(connectionID);\n\n            if (connection == null) {\n              process.env.NODE_ENV !== \"production\" ? warning(false, \"[Relay][Mutation] The connection with id '\".concat(connectionID, \"' doesn't exist.\")) : void 0;\n              continue;\n            }\n\n            ConnectionHandler.deleteNode(connection, id);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    });\n  }\n};\nvar AppendEdgeHandler = {\n  update: edgeUpdater(ConnectionHandler.insertEdgeAfter)\n};\nvar PrependEdgeHandler = {\n  update: edgeUpdater(ConnectionHandler.insertEdgeBefore)\n};\nvar AppendNodeHandler = {\n  update: nodeUpdater(ConnectionHandler.insertEdgeAfter)\n};\nvar PrependNodeHandler = {\n  update: nodeUpdater(ConnectionHandler.insertEdgeBefore)\n};\n\nfunction edgeUpdater(insertFn) {\n  return function (store, payload) {\n    var _serverEdges;\n\n    var record = store.get(payload.dataID);\n\n    if (record == null) {\n      return;\n    }\n\n    var connections = payload.handleArgs.connections;\n    !(connections != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MutationHandlers: Expected connection IDs to be specified.') : invariant(false) : void 0;\n    var singleServerEdge, serverEdges;\n\n    try {\n      singleServerEdge = record.getLinkedRecord(payload.fieldKey, payload.args);\n    } catch (_unused) {}\n\n    if (!singleServerEdge) {\n      try {\n        serverEdges = record.getLinkedRecords(payload.fieldKey, payload.args);\n      } catch (_unused2) {}\n    }\n\n    if (singleServerEdge == null && serverEdges == null) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'MutationHandlers: Expected the server edge to be non-null.') : void 0;\n      return;\n    }\n\n    var _ConnectionInterface$ = ConnectionInterface.get(),\n        NODE = _ConnectionInterface$.NODE,\n        EDGES = _ConnectionInterface$.EDGES;\n\n    var serverEdgeList = (_serverEdges = serverEdges) !== null && _serverEdges !== void 0 ? _serverEdges : [singleServerEdge];\n\n    var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(serverEdgeList),\n        _step2;\n\n    try {\n      var _loop = function _loop() {\n        var serverEdge = _step2.value;\n\n        if (serverEdge == null) {\n          return \"continue\";\n        }\n\n        var serverNode = serverEdge.getLinkedRecord('node');\n\n        if (!serverNode) {\n          return \"continue\";\n        }\n\n        var serverNodeId = serverNode.getDataID();\n\n        var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(connections),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var connectionID = _step3.value;\n            var connection = store.get(connectionID);\n\n            if (connection == null) {\n              process.env.NODE_ENV !== \"production\" ? warning(false, \"[Relay][Mutation] The connection with id '\".concat(connectionID, \"' doesn't exist.\")) : void 0;\n              continue;\n            }\n\n            var nodeAlreadyExistsInConnection = (_connection$getLinked = connection.getLinkedRecords(EDGES)) === null || _connection$getLinked === void 0 ? void 0 : _connection$getLinked.some(function (edge) {\n              var _edge$getLinkedRecord;\n\n              return (edge === null || edge === void 0 ? void 0 : (_edge$getLinkedRecord = edge.getLinkedRecord(NODE)) === null || _edge$getLinkedRecord === void 0 ? void 0 : _edge$getLinkedRecord.getDataID()) === serverNodeId;\n            });\n\n            if (nodeAlreadyExistsInConnection) {\n              continue;\n            }\n\n            var clientEdge = ConnectionHandler.buildConnectionEdge(store, connection, serverEdge);\n            !(clientEdge != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MutationHandlers: Failed to build the edge.') : invariant(false) : void 0;\n            insertFn(connection, clientEdge);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      };\n\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _connection$getLinked;\n\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  };\n}\n\nfunction nodeUpdater(insertFn) {\n  return function (store, payload) {\n    var _serverNodes;\n\n    var record = store.get(payload.dataID);\n\n    if (record == null) {\n      return;\n    }\n\n    var _payload$handleArgs = payload.handleArgs,\n        connections = _payload$handleArgs.connections,\n        edgeTypeName = _payload$handleArgs.edgeTypeName;\n    !(connections != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MutationHandlers: Expected connection IDs to be specified.') : invariant(false) : void 0;\n    !(edgeTypeName != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MutationHandlers: Expected edge typename to be specified.') : invariant(false) : void 0;\n    var singleServerNode;\n    var serverNodes;\n\n    try {\n      singleServerNode = record.getLinkedRecord(payload.fieldKey, payload.args);\n    } catch (_unused3) {}\n\n    if (!singleServerNode) {\n      try {\n        serverNodes = record.getLinkedRecords(payload.fieldKey, payload.args);\n      } catch (_unused4) {}\n    }\n\n    if (singleServerNode == null && serverNodes == null) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'MutationHandlers: Expected target node to exist.') : void 0;\n      return;\n    }\n\n    var _ConnectionInterface$2 = ConnectionInterface.get(),\n        NODE = _ConnectionInterface$2.NODE,\n        EDGES = _ConnectionInterface$2.EDGES;\n\n    var serverNodeList = (_serverNodes = serverNodes) !== null && _serverNodes !== void 0 ? _serverNodes : [singleServerNode];\n\n    var _iterator4 = (0, _createForOfIteratorHelper2[\"default\"])(serverNodeList),\n        _step4;\n\n    try {\n      var _loop2 = function _loop2() {\n        var serverNode = _step4.value;\n\n        if (serverNode == null) {\n          return \"continue\";\n        }\n\n        var serverNodeId = serverNode.getDataID();\n\n        var _iterator5 = (0, _createForOfIteratorHelper2[\"default\"])(connections),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var connectionID = _step5.value;\n            var connection = store.get(connectionID);\n\n            if (connection == null) {\n              process.env.NODE_ENV !== \"production\" ? warning(false, \"[Relay][Mutation] The connection with id '\".concat(connectionID, \"' doesn't exist.\")) : void 0;\n              continue;\n            }\n\n            var nodeAlreadyExistsInConnection = (_connection$getLinked2 = connection.getLinkedRecords(EDGES)) === null || _connection$getLinked2 === void 0 ? void 0 : _connection$getLinked2.some(function (edge) {\n              var _edge$getLinkedRecord2;\n\n              return (edge === null || edge === void 0 ? void 0 : (_edge$getLinkedRecord2 = edge.getLinkedRecord(NODE)) === null || _edge$getLinkedRecord2 === void 0 ? void 0 : _edge$getLinkedRecord2.getDataID()) === serverNodeId;\n            });\n\n            if (nodeAlreadyExistsInConnection) {\n              continue;\n            }\n\n            var clientEdge = ConnectionHandler.createEdge(store, connection, serverNode, edgeTypeName);\n            !(clientEdge != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MutationHandlers: Failed to build the edge.') : invariant(false) : void 0;\n            insertFn(connection, clientEdge);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      };\n\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _connection$getLinked2;\n\n        var _ret2 = _loop2();\n\n        if (_ret2 === \"continue\") continue;\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  };\n}\n\nmodule.exports = {\n  AppendEdgeHandler: AppendEdgeHandler,\n  DeleteRecordHandler: DeleteRecordHandler,\n  PrependEdgeHandler: PrependEdgeHandler,\n  AppendNodeHandler: AppendNodeHandler,\n  PrependNodeHandler: PrependNodeHandler,\n  DeleteEdgeHandler: DeleteEdgeHandler\n};","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/handlers/connection/MutationHandlers.js"],"names":["_interopRequireDefault","require","_createForOfIteratorHelper2","ConnectionHandler","ConnectionInterface","invariant","warning","DeleteRecordHandler","update","store","payload","record","get","dataID","idOrIds","getValue","fieldKey","Array","isArray","forEach","id","DeleteEdgeHandler","connections","handleArgs","process","env","NODE_ENV","idList","_iterator","_step","s","n","done","connectionID","value","connection","concat","deleteNode","err","e","f","AppendEdgeHandler","edgeUpdater","insertEdgeAfter","PrependEdgeHandler","insertEdgeBefore","AppendNodeHandler","nodeUpdater","PrependNodeHandler","insertFn","_serverEdges","singleServerEdge","serverEdges","getLinkedRecord","args","_unused","getLinkedRecords","_unused2","_ConnectionInterface$","NODE","EDGES","serverEdgeList","_iterator2","_step2","_loop","serverEdge","serverNode","serverNodeId","getDataID","_iterator3","_step3","nodeAlreadyExistsInConnection","_connection$getLinked","some","edge","_edge$getLinkedRecord","clientEdge","buildConnectionEdge","_ret","_serverNodes","_payload$handleArgs","edgeTypeName","singleServerNode","serverNodes","_unused3","_unused4","_ConnectionInterface$2","serverNodeList","_iterator4","_step4","_loop2","_iterator5","_step5","_connection$getLinked2","_edge$getLinkedRecord2","createEdge","_ret2","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar ConnectionHandler = require('./ConnectionHandler');\n\nvar ConnectionInterface = require('./ConnectionInterface');\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar DeleteRecordHandler = {\n  update: function update(store, payload) {\n    var record = store.get(payload.dataID);\n\n    if (record != null) {\n      var idOrIds = record.getValue(payload.fieldKey);\n\n      if (typeof idOrIds === 'string') {\n        store[\"delete\"](idOrIds);\n      } else if (Array.isArray(idOrIds)) {\n        idOrIds.forEach(function (id) {\n          if (typeof id === 'string') {\n            store[\"delete\"](id);\n          }\n        });\n      }\n    }\n  }\n};\nvar DeleteEdgeHandler = {\n  update: function update(store, payload) {\n    var record = store.get(payload.dataID);\n\n    if (record == null) {\n      return;\n    }\n\n    var connections = payload.handleArgs.connections;\n    !(connections != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MutationHandlers: Expected connection IDs to be specified.') : invariant(false) : void 0;\n    var idOrIds = record.getValue(payload.fieldKey);\n    var idList = Array.isArray(idOrIds) ? idOrIds : [idOrIds];\n    idList.forEach(function (id) {\n      if (typeof id === 'string') {\n        var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(connections),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var connectionID = _step.value;\n            var connection = store.get(connectionID);\n\n            if (connection == null) {\n              process.env.NODE_ENV !== \"production\" ? warning(false, \"[Relay][Mutation] The connection with id '\".concat(connectionID, \"' doesn't exist.\")) : void 0;\n              continue;\n            }\n\n            ConnectionHandler.deleteNode(connection, id);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    });\n  }\n};\nvar AppendEdgeHandler = {\n  update: edgeUpdater(ConnectionHandler.insertEdgeAfter)\n};\nvar PrependEdgeHandler = {\n  update: edgeUpdater(ConnectionHandler.insertEdgeBefore)\n};\nvar AppendNodeHandler = {\n  update: nodeUpdater(ConnectionHandler.insertEdgeAfter)\n};\nvar PrependNodeHandler = {\n  update: nodeUpdater(ConnectionHandler.insertEdgeBefore)\n};\n\nfunction edgeUpdater(insertFn) {\n  return function (store, payload) {\n    var _serverEdges;\n\n    var record = store.get(payload.dataID);\n\n    if (record == null) {\n      return;\n    }\n\n    var connections = payload.handleArgs.connections;\n    !(connections != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MutationHandlers: Expected connection IDs to be specified.') : invariant(false) : void 0;\n    var singleServerEdge, serverEdges;\n\n    try {\n      singleServerEdge = record.getLinkedRecord(payload.fieldKey, payload.args);\n    } catch (_unused) {}\n\n    if (!singleServerEdge) {\n      try {\n        serverEdges = record.getLinkedRecords(payload.fieldKey, payload.args);\n      } catch (_unused2) {}\n    }\n\n    if (singleServerEdge == null && serverEdges == null) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'MutationHandlers: Expected the server edge to be non-null.') : void 0;\n      return;\n    }\n\n    var _ConnectionInterface$ = ConnectionInterface.get(),\n        NODE = _ConnectionInterface$.NODE,\n        EDGES = _ConnectionInterface$.EDGES;\n\n    var serverEdgeList = (_serverEdges = serverEdges) !== null && _serverEdges !== void 0 ? _serverEdges : [singleServerEdge];\n\n    var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(serverEdgeList),\n        _step2;\n\n    try {\n      var _loop = function _loop() {\n        var serverEdge = _step2.value;\n\n        if (serverEdge == null) {\n          return \"continue\";\n        }\n\n        var serverNode = serverEdge.getLinkedRecord('node');\n\n        if (!serverNode) {\n          return \"continue\";\n        }\n\n        var serverNodeId = serverNode.getDataID();\n\n        var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(connections),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var connectionID = _step3.value;\n            var connection = store.get(connectionID);\n\n            if (connection == null) {\n              process.env.NODE_ENV !== \"production\" ? warning(false, \"[Relay][Mutation] The connection with id '\".concat(connectionID, \"' doesn't exist.\")) : void 0;\n              continue;\n            }\n\n            var nodeAlreadyExistsInConnection = (_connection$getLinked = connection.getLinkedRecords(EDGES)) === null || _connection$getLinked === void 0 ? void 0 : _connection$getLinked.some(function (edge) {\n              var _edge$getLinkedRecord;\n\n              return (edge === null || edge === void 0 ? void 0 : (_edge$getLinkedRecord = edge.getLinkedRecord(NODE)) === null || _edge$getLinkedRecord === void 0 ? void 0 : _edge$getLinkedRecord.getDataID()) === serverNodeId;\n            });\n\n            if (nodeAlreadyExistsInConnection) {\n              continue;\n            }\n\n            var clientEdge = ConnectionHandler.buildConnectionEdge(store, connection, serverEdge);\n            !(clientEdge != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MutationHandlers: Failed to build the edge.') : invariant(false) : void 0;\n            insertFn(connection, clientEdge);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      };\n\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _connection$getLinked;\n\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  };\n}\n\nfunction nodeUpdater(insertFn) {\n  return function (store, payload) {\n    var _serverNodes;\n\n    var record = store.get(payload.dataID);\n\n    if (record == null) {\n      return;\n    }\n\n    var _payload$handleArgs = payload.handleArgs,\n        connections = _payload$handleArgs.connections,\n        edgeTypeName = _payload$handleArgs.edgeTypeName;\n    !(connections != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MutationHandlers: Expected connection IDs to be specified.') : invariant(false) : void 0;\n    !(edgeTypeName != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MutationHandlers: Expected edge typename to be specified.') : invariant(false) : void 0;\n    var singleServerNode;\n    var serverNodes;\n\n    try {\n      singleServerNode = record.getLinkedRecord(payload.fieldKey, payload.args);\n    } catch (_unused3) {}\n\n    if (!singleServerNode) {\n      try {\n        serverNodes = record.getLinkedRecords(payload.fieldKey, payload.args);\n      } catch (_unused4) {}\n    }\n\n    if (singleServerNode == null && serverNodes == null) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'MutationHandlers: Expected target node to exist.') : void 0;\n      return;\n    }\n\n    var _ConnectionInterface$2 = ConnectionInterface.get(),\n        NODE = _ConnectionInterface$2.NODE,\n        EDGES = _ConnectionInterface$2.EDGES;\n\n    var serverNodeList = (_serverNodes = serverNodes) !== null && _serverNodes !== void 0 ? _serverNodes : [singleServerNode];\n\n    var _iterator4 = (0, _createForOfIteratorHelper2[\"default\"])(serverNodeList),\n        _step4;\n\n    try {\n      var _loop2 = function _loop2() {\n        var serverNode = _step4.value;\n\n        if (serverNode == null) {\n          return \"continue\";\n        }\n\n        var serverNodeId = serverNode.getDataID();\n\n        var _iterator5 = (0, _createForOfIteratorHelper2[\"default\"])(connections),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var connectionID = _step5.value;\n            var connection = store.get(connectionID);\n\n            if (connection == null) {\n              process.env.NODE_ENV !== \"production\" ? warning(false, \"[Relay][Mutation] The connection with id '\".concat(connectionID, \"' doesn't exist.\")) : void 0;\n              continue;\n            }\n\n            var nodeAlreadyExistsInConnection = (_connection$getLinked2 = connection.getLinkedRecords(EDGES)) === null || _connection$getLinked2 === void 0 ? void 0 : _connection$getLinked2.some(function (edge) {\n              var _edge$getLinkedRecord2;\n\n              return (edge === null || edge === void 0 ? void 0 : (_edge$getLinkedRecord2 = edge.getLinkedRecord(NODE)) === null || _edge$getLinkedRecord2 === void 0 ? void 0 : _edge$getLinkedRecord2.getDataID()) === serverNodeId;\n            });\n\n            if (nodeAlreadyExistsInConnection) {\n              continue;\n            }\n\n            var clientEdge = ConnectionHandler.createEdge(store, connection, serverNode, edgeTypeName);\n            !(clientEdge != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MutationHandlers: Failed to build the edge.') : invariant(false) : void 0;\n            insertFn(connection, clientEdge);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      };\n\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _connection$getLinked2;\n\n        var _ret2 = _loop2();\n\n        if (_ret2 === \"continue\") continue;\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  };\n}\n\nmodule.exports = {\n  AppendEdgeHandler: AppendEdgeHandler,\n  DeleteRecordHandler: DeleteRecordHandler,\n  PrependEdgeHandler: PrependEdgeHandler,\n  AppendNodeHandler: AppendNodeHandler,\n  PrependNodeHandler: PrependNodeHandler,\n  DeleteEdgeHandler: DeleteEdgeHandler\n};"]},"metadata":{},"sourceType":"script"}