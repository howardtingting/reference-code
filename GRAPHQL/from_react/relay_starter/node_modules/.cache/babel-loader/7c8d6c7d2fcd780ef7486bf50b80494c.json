{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _require = require('./FragmentResource'),\n    getFragmentResourceForEnvironment = _require.getFragmentResourceForEnvironment;\n\nvar ProfilerContext = require('./ProfilerContext');\n\nvar _require2 = require('./QueryResource'),\n    getQueryResourceForEnvironment = _require2.getQueryResourceForEnvironment;\n\nvar useFragmentNode = require('./useFragmentNode');\n\nvar useIsMountedRef = require('./useIsMountedRef');\n\nvar useQueryLoader = require('./useQueryLoader');\n\nvar useRelayEnvironment = require('./useRelayEnvironment');\n\nvar invariant = require('invariant');\n\nvar _require3 = require('react'),\n    useCallback = _require3.useCallback,\n    useContext = _require3.useContext,\n    useReducer = _require3.useReducer;\n\nvar _require4 = require('relay-runtime'),\n    fetchQuery = _require4.__internal.fetchQuery,\n    createOperationDescriptor = _require4.createOperationDescriptor,\n    getFragmentIdentifier = _require4.getFragmentIdentifier,\n    getRefetchMetadata = _require4.getRefetchMetadata,\n    getSelector = _require4.getSelector,\n    getValueAtPath = _require4.getValueAtPath;\n\nvar warning = require(\"fbjs/lib/warning\");\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'refetch':\n      {\n        var _action$refetchEnviro;\n\n        return (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, state), {}, {\n          fetchPolicy: action.fetchPolicy,\n          mirroredEnvironment: (_action$refetchEnviro = action.refetchEnvironment) !== null && _action$refetchEnviro !== void 0 ? _action$refetchEnviro : state.mirroredEnvironment,\n          onComplete: action.onComplete,\n          refetchEnvironment: action.refetchEnvironment,\n          refetchQuery: action.refetchQuery,\n          renderPolicy: action.renderPolicy\n        });\n      }\n\n    case 'reset':\n      {\n        return {\n          fetchPolicy: undefined,\n          mirroredEnvironment: action.environment,\n          mirroredFragmentIdentifier: action.fragmentIdentifier,\n          onComplete: undefined,\n          refetchQuery: null,\n          renderPolicy: undefined\n        };\n      }\n\n    default:\n      {\n        action.type;\n        throw new Error('useRefetchableFragmentNode: Unexpected action type');\n      }\n  }\n}\n\nfunction useRefetchableFragmentNode(fragmentNode, parentFragmentRef, componentDisplayName) {\n  var parentEnvironment = useRelayEnvironment();\n\n  var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName),\n      refetchableRequest = _getRefetchMetadata.refetchableRequest,\n      fragmentRefPathInResponse = _getRefetchMetadata.fragmentRefPathInResponse,\n      identifierField = _getRefetchMetadata.identifierField;\n\n  var fragmentIdentifier = getFragmentIdentifier(fragmentNode, parentFragmentRef);\n\n  var _useReducer = useReducer(reducer, {\n    fetchPolicy: undefined,\n    mirroredEnvironment: parentEnvironment,\n    mirroredFragmentIdentifier: fragmentIdentifier,\n    onComplete: undefined,\n    refetchEnvironment: null,\n    refetchQuery: null,\n    renderPolicy: undefined\n  }),\n      refetchState = _useReducer[0],\n      dispatch = _useReducer[1];\n\n  var fetchPolicy = refetchState.fetchPolicy,\n      mirroredEnvironment = refetchState.mirroredEnvironment,\n      mirroredFragmentIdentifier = refetchState.mirroredFragmentIdentifier,\n      onComplete = refetchState.onComplete,\n      refetchEnvironment = refetchState.refetchEnvironment,\n      refetchQuery = refetchState.refetchQuery,\n      renderPolicy = refetchState.renderPolicy;\n  var environment = refetchEnvironment !== null && refetchEnvironment !== void 0 ? refetchEnvironment : parentEnvironment;\n  var QueryResource = getQueryResourceForEnvironment(environment);\n  var FragmentResource = getFragmentResourceForEnvironment(environment);\n  var profilerContext = useContext(ProfilerContext);\n  var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;\n\n  var _useQueryLoader = useQueryLoader(refetchableRequest),\n      queryRef = _useQueryLoader[0],\n      loadQuery = _useQueryLoader[1],\n      disposeQuery = _useQueryLoader[2];\n\n  var fragmentRef = parentFragmentRef;\n\n  if (shouldReset) {\n    dispatch({\n      type: 'reset',\n      environment: environment,\n      fragmentIdentifier: fragmentIdentifier\n    });\n    disposeQuery();\n  } else if (refetchQuery != null && queryRef != null) {\n    // If refetch was called, we expect to have a refetchQuery and queryRef\n    // in state, since both state updates to set the refetchQuery and the\n    // queryRef occur simultaneously.\n    // In this case, we need to read the refetched query data (potentially\n    // suspending if it's in flight), and extract the new fragment ref\n    // from the query in order read the current @refetchable fragment\n    // with the updated fragment owner as the new refetchQuery.\n    // Before observing the refetch, record the current ID and typename\n    // so that, if we are refetching existing data on\n    // a field that implements Node, after refetching we\n    // can validate that the received data is consistent\n    var debugPreviousIDAndTypename;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      debugPreviousIDAndTypename = debugFunctions.getInitialIDAndType(refetchQuery.request.variables, fragmentRefPathInResponse, environment);\n    }\n\n    var handleQueryCompleted = function handleQueryCompleted(maybeError) {\n      onComplete && onComplete(maybeError !== null && maybeError !== void 0 ? maybeError : null);\n    }; // The queryRef.source obtained from useQueryLoader will be\n    // an observable we can consume /if/ a network request was\n    // started. Otherwise, given that QueryResource.prepare\n    // always expects an observable we fall back to a new network\n    // observable. Note however that if loadQuery did not make a network\n    // request, we don't expect to make one here, unless the state of\n    // the cache has changed between the call to refetch and this\n    // render.\n\n\n    var fetchObservable = queryRef.source != null ? queryRef.source : fetchQuery(environment, refetchQuery); // Now wwe can we read the refetch query here using the\n    // queryRef provided from useQueryLoader. Note that the\n    // network request is started during the call to refetch,\n    // but if the refetch query is still in flight, we will suspend\n    // at this point:\n\n    var queryResult = profilerContext.wrapPrepareQueryResource(function () {\n      return QueryResource.prepare(refetchQuery, fetchObservable, fetchPolicy, renderPolicy, {\n        error: handleQueryCompleted,\n        complete: function complete() {\n          // Validate that the type of the object we got back matches the type\n          // of the object already in the store\n          if (process.env.NODE_ENV !== \"production\") {\n            debugFunctions.checkSameTypeAfterRefetch(debugPreviousIDAndTypename, environment, fragmentNode, componentDisplayName);\n          }\n\n          handleQueryCompleted();\n        }\n      }, queryRef.fetchKey, profilerContext);\n    });\n    var queryData = FragmentResource.read(queryResult.fragmentNode, queryResult.fragmentRef, componentDisplayName).data;\n    !(queryData != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to be able to read refetch query response. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0; // After reading/fetching the refetch query, we extract from the\n    // refetch query response the new fragment ref we need to use to read\n    // the fragment. The new fragment ref will point to the refetch query\n    // as its fragment owner.\n\n    var refetchedFragmentRef = getValueAtPath(queryData, fragmentRefPathInResponse);\n    fragmentRef = refetchedFragmentRef;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      // Validate that the id of the object we got back matches the id\n      // we queried for in the variables.\n      // We do this during render instead of onComplete to make sure we are\n      // only validating the most recent refetch.\n      debugFunctions.checkSameIDAfterRefetch(debugPreviousIDAndTypename, fragmentRef, fragmentNode, componentDisplayName);\n    }\n  } // We read and subscribe to the fragment using useFragmentNode.\n  // If refetch was called, we read the fragment using the new computed\n  // fragment ref from the refetch query response; otherwise, we use the\n  // fragment ref passed by the caller as normal.\n\n\n  var _useFragmentNode = useFragmentNode(fragmentNode, fragmentRef, componentDisplayName),\n      fragmentData = _useFragmentNode.data,\n      disableStoreUpdates = _useFragmentNode.disableStoreUpdates,\n      enableStoreUpdates = _useFragmentNode.enableStoreUpdates;\n\n  var refetch = useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierField, loadQuery, parentFragmentRef, refetchableRequest);\n  return {\n    fragmentData: fragmentData,\n    fragmentRef: fragmentRef,\n    refetch: refetch,\n    disableStoreUpdates: disableStoreUpdates,\n    enableStoreUpdates: enableStoreUpdates\n  };\n}\n\nfunction useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierField, loadQuery, parentFragmentRef, refetchableRequest) {\n  var isMountedRef = useIsMountedRef();\n  var identifierValue = identifierField != null && fragmentData != null && typeof fragmentData === 'object' ? fragmentData[identifierField] : null;\n  return useCallback(function (providedRefetchVariables, options) {\n    // Bail out and warn if we're trying to refetch after the component\n    // has unmounted\n    if (isMountedRef.current !== true) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected call to `refetch` on unmounted component for fragment ' + '`%s` in `%s`. It looks like some instances of your component are ' + 'still trying to fetch data but they already unmounted. ' + 'Please make sure you clear all timers, intervals, ' + 'async calls, etc that may trigger a fetch.', fragmentNode.name, componentDisplayName) : void 0;\n      return {\n        dispose: function dispose() {}\n      };\n    }\n\n    if (parentFragmentRef == null) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected call to `refetch` while using a null fragment ref ' + 'for fragment `%s` in `%s`. When calling `refetch`, we expect ' + \"initial fragment data to be non-null. Please make sure you're \" + 'passing a valid fragment ref to `%s` before calling ' + '`refetch`, or make sure you pass all required variables to `refetch`.', fragmentNode.name, componentDisplayName, componentDisplayName) : void 0;\n    }\n\n    var refetchEnvironment = options === null || options === void 0 ? void 0 : options.__environment;\n    var fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy;\n    var renderPolicy = options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy;\n    var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;\n    var fragmentSelector = getSelector(fragmentNode, parentFragmentRef);\n    var parentVariables;\n    var fragmentVariables;\n\n    if (fragmentSelector == null) {\n      parentVariables = {};\n      fragmentVariables = {};\n    } else if (fragmentSelector.kind === 'PluralReaderSelector') {\n      var _fragmentSelector$sel, _fragmentSelector$sel2, _fragmentSelector$sel3, _fragmentSelector$sel4;\n\n      parentVariables = (_fragmentSelector$sel = (_fragmentSelector$sel2 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel2 === void 0 ? void 0 : _fragmentSelector$sel2.owner.variables) !== null && _fragmentSelector$sel !== void 0 ? _fragmentSelector$sel : {};\n      fragmentVariables = (_fragmentSelector$sel3 = (_fragmentSelector$sel4 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel4 === void 0 ? void 0 : _fragmentSelector$sel4.variables) !== null && _fragmentSelector$sel3 !== void 0 ? _fragmentSelector$sel3 : {};\n    } else {\n      parentVariables = fragmentSelector.owner.variables;\n      fragmentVariables = fragmentSelector.variables;\n    } // A user of `useRefetchableFragment()` may pass a subset of\n    // all variables required by the fragment when calling `refetch()`.\n    // We fill in any variables not passed by the call to `refetch()` with the\n    // variables from the original parent fragment owner.\n\n\n    var refetchVariables = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, parentVariables), fragmentVariables), providedRefetchVariables); // If the query needs an identifier value ('id' or similar) and one\n    // was not explicitly provided, read it from the fragment data.\n\n    if (identifierField != null && !providedRefetchVariables.hasOwnProperty('id')) {\n      // @refetchable fragments are guaranteed to have an `id` selection\n      // if the type is Node, implements Node, or is @fetchable. Double-check\n      // that there actually is a value at runtime.\n      if (typeof identifierValue !== 'string') {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Expected result to have a string  ' + '`%s` in order to refetch, got `%s`.', identifierField, identifierValue) : void 0;\n      }\n\n      refetchVariables.id = identifierValue;\n    }\n\n    var refetchQuery = createOperationDescriptor(refetchableRequest, refetchVariables, {\n      force: true\n    }); // We call loadQuery which will start a network request if necessary\n    // and update the querRef from useQueryLoader.\n    // Note the following:\n    // - loadQuery will dispose of any previously refetched queries.\n    // - We use the variables extracted off the OperationDescriptor\n    // so that they have been filtered out to include only the\n    // variables actually declared in the query.\n\n    loadQuery(refetchQuery.request.variables, {\n      fetchPolicy: fetchPolicy,\n      __environment: refetchEnvironment,\n      __nameForWarning: 'refetch'\n    });\n    dispatch({\n      type: 'refetch',\n      fetchPolicy: fetchPolicy,\n      onComplete: onComplete,\n      refetchEnvironment: refetchEnvironment,\n      refetchQuery: refetchQuery,\n      renderPolicy: renderPolicy\n    });\n    return {\n      dispose: disposeQuery\n    };\n  }, // NOTE: We disable react-hooks-deps warning because:\n  //   - We know fragmentRefPathInResponse is static, so it can be omitted from\n  //     deps\n  //   - We know fragmentNode is static, so it can be omitted from deps.\n  //   - fragmentNode and parentFragmentRef are also captured by including\n  //     fragmentIdentifier\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [fragmentIdentifier, dispatch, disposeQuery, identifierValue, loadQuery]);\n}\n\nvar debugFunctions;\n\nif (process.env.NODE_ENV !== \"production\") {\n  debugFunctions = {\n    getInitialIDAndType: function getInitialIDAndType(memoRefetchVariables, fragmentRefPathInResponse, environment) {\n      var _require5 = require('relay-runtime'),\n          Record = _require5.Record;\n\n      var id = memoRefetchVariables === null || memoRefetchVariables === void 0 ? void 0 : memoRefetchVariables.id;\n\n      if (fragmentRefPathInResponse.length !== 1 || fragmentRefPathInResponse[0] !== 'node' || id == null) {\n        return null;\n      }\n\n      var recordSource = environment.getStore().getSource();\n      var record = recordSource.get(id);\n      var typename = record && Record.getType(record);\n\n      if (typename == null) {\n        return null;\n      }\n\n      return {\n        id: id,\n        typename: typename\n      };\n    },\n    checkSameTypeAfterRefetch: function checkSameTypeAfterRefetch(previousIDAndType, environment, fragmentNode, componentDisplayName) {\n      var _require6 = require('relay-runtime'),\n          Record = _require6.Record;\n\n      if (!previousIDAndType) {\n        return;\n      }\n\n      var recordSource = environment.getStore().getSource();\n      var record = recordSource.get(previousIDAndType.id);\n      var typename = record && Record.getType(record);\n\n      if (typename !== previousIDAndType.typename) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Call to `refetch` returned data with a different ' + '__typename: was `%s`, now `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements' + 'unique id requirement.', previousIDAndType.typename, typename, fragmentNode.name, componentDisplayName) : void 0;\n      }\n    },\n    checkSameIDAfterRefetch: function checkSameIDAfterRefetch(previousIDAndTypename, refetchedFragmentRef, fragmentNode, componentDisplayName) {\n      if (previousIDAndTypename == null) {\n        return;\n      }\n\n      var _require7 = require('relay-runtime'),\n          ID_KEY = _require7.ID_KEY; // $FlowExpectedError[incompatible-use]\n\n\n      var resultID = refetchedFragmentRef[ID_KEY];\n\n      if (resultID != null && resultID !== previousIDAndTypename.id) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Call to `refetch` returned a different id, expected ' + '`%s`, got `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements ' + 'unique id requirement.', resultID, previousIDAndTypename.id, fragmentNode.name, componentDisplayName) : void 0;\n      }\n    }\n  };\n}\n\nmodule.exports = useRefetchableFragmentNode;","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/react-relay/lib/relay-hooks/useRefetchableFragmentNode.js"],"names":["_interopRequireDefault","require","_objectSpread2","_require","getFragmentResourceForEnvironment","ProfilerContext","_require2","getQueryResourceForEnvironment","useFragmentNode","useIsMountedRef","useQueryLoader","useRelayEnvironment","invariant","_require3","useCallback","useContext","useReducer","_require4","fetchQuery","__internal","createOperationDescriptor","getFragmentIdentifier","getRefetchMetadata","getSelector","getValueAtPath","warning","reducer","state","action","type","_action$refetchEnviro","fetchPolicy","mirroredEnvironment","refetchEnvironment","onComplete","refetchQuery","renderPolicy","undefined","environment","mirroredFragmentIdentifier","fragmentIdentifier","Error","useRefetchableFragmentNode","fragmentNode","parentFragmentRef","componentDisplayName","parentEnvironment","_getRefetchMetadata","refetchableRequest","fragmentRefPathInResponse","identifierField","_useReducer","refetchState","dispatch","QueryResource","FragmentResource","profilerContext","shouldReset","_useQueryLoader","queryRef","loadQuery","disposeQuery","fragmentRef","debugPreviousIDAndTypename","process","env","NODE_ENV","debugFunctions","getInitialIDAndType","request","variables","handleQueryCompleted","maybeError","fetchObservable","source","queryResult","wrapPrepareQueryResource","prepare","error","complete","checkSameTypeAfterRefetch","fetchKey","queryData","read","data","refetchedFragmentRef","checkSameIDAfterRefetch","_useFragmentNode","fragmentData","disableStoreUpdates","enableStoreUpdates","refetch","useRefetchFunction","isMountedRef","identifierValue","providedRefetchVariables","options","current","name","dispose","__environment","UNSTABLE_renderPolicy","fragmentSelector","parentVariables","fragmentVariables","kind","_fragmentSelector$sel","_fragmentSelector$sel2","_fragmentSelector$sel3","_fragmentSelector$sel4","selectors","owner","refetchVariables","hasOwnProperty","id","force","__nameForWarning","memoRefetchVariables","_require5","Record","length","recordSource","getStore","getSource","record","get","typename","getType","previousIDAndType","_require6","previousIDAndTypename","_require7","ID_KEY","resultID","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _require = require('./FragmentResource'),\n    getFragmentResourceForEnvironment = _require.getFragmentResourceForEnvironment;\n\nvar ProfilerContext = require('./ProfilerContext');\n\nvar _require2 = require('./QueryResource'),\n    getQueryResourceForEnvironment = _require2.getQueryResourceForEnvironment;\n\nvar useFragmentNode = require('./useFragmentNode');\n\nvar useIsMountedRef = require('./useIsMountedRef');\n\nvar useQueryLoader = require('./useQueryLoader');\n\nvar useRelayEnvironment = require('./useRelayEnvironment');\n\nvar invariant = require('invariant');\n\nvar _require3 = require('react'),\n    useCallback = _require3.useCallback,\n    useContext = _require3.useContext,\n    useReducer = _require3.useReducer;\n\nvar _require4 = require('relay-runtime'),\n    fetchQuery = _require4.__internal.fetchQuery,\n    createOperationDescriptor = _require4.createOperationDescriptor,\n    getFragmentIdentifier = _require4.getFragmentIdentifier,\n    getRefetchMetadata = _require4.getRefetchMetadata,\n    getSelector = _require4.getSelector,\n    getValueAtPath = _require4.getValueAtPath;\n\nvar warning = require(\"fbjs/lib/warning\");\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'refetch':\n      {\n        var _action$refetchEnviro;\n\n        return (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, state), {}, {\n          fetchPolicy: action.fetchPolicy,\n          mirroredEnvironment: (_action$refetchEnviro = action.refetchEnvironment) !== null && _action$refetchEnviro !== void 0 ? _action$refetchEnviro : state.mirroredEnvironment,\n          onComplete: action.onComplete,\n          refetchEnvironment: action.refetchEnvironment,\n          refetchQuery: action.refetchQuery,\n          renderPolicy: action.renderPolicy\n        });\n      }\n\n    case 'reset':\n      {\n        return {\n          fetchPolicy: undefined,\n          mirroredEnvironment: action.environment,\n          mirroredFragmentIdentifier: action.fragmentIdentifier,\n          onComplete: undefined,\n          refetchQuery: null,\n          renderPolicy: undefined\n        };\n      }\n\n    default:\n      {\n        action.type;\n        throw new Error('useRefetchableFragmentNode: Unexpected action type');\n      }\n  }\n}\n\nfunction useRefetchableFragmentNode(fragmentNode, parentFragmentRef, componentDisplayName) {\n  var parentEnvironment = useRelayEnvironment();\n\n  var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName),\n      refetchableRequest = _getRefetchMetadata.refetchableRequest,\n      fragmentRefPathInResponse = _getRefetchMetadata.fragmentRefPathInResponse,\n      identifierField = _getRefetchMetadata.identifierField;\n\n  var fragmentIdentifier = getFragmentIdentifier(fragmentNode, parentFragmentRef);\n\n  var _useReducer = useReducer(reducer, {\n    fetchPolicy: undefined,\n    mirroredEnvironment: parentEnvironment,\n    mirroredFragmentIdentifier: fragmentIdentifier,\n    onComplete: undefined,\n    refetchEnvironment: null,\n    refetchQuery: null,\n    renderPolicy: undefined\n  }),\n      refetchState = _useReducer[0],\n      dispatch = _useReducer[1];\n\n  var fetchPolicy = refetchState.fetchPolicy,\n      mirroredEnvironment = refetchState.mirroredEnvironment,\n      mirroredFragmentIdentifier = refetchState.mirroredFragmentIdentifier,\n      onComplete = refetchState.onComplete,\n      refetchEnvironment = refetchState.refetchEnvironment,\n      refetchQuery = refetchState.refetchQuery,\n      renderPolicy = refetchState.renderPolicy;\n  var environment = refetchEnvironment !== null && refetchEnvironment !== void 0 ? refetchEnvironment : parentEnvironment;\n  var QueryResource = getQueryResourceForEnvironment(environment);\n  var FragmentResource = getFragmentResourceForEnvironment(environment);\n  var profilerContext = useContext(ProfilerContext);\n  var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;\n\n  var _useQueryLoader = useQueryLoader(refetchableRequest),\n      queryRef = _useQueryLoader[0],\n      loadQuery = _useQueryLoader[1],\n      disposeQuery = _useQueryLoader[2];\n\n  var fragmentRef = parentFragmentRef;\n\n  if (shouldReset) {\n    dispatch({\n      type: 'reset',\n      environment: environment,\n      fragmentIdentifier: fragmentIdentifier\n    });\n    disposeQuery();\n  } else if (refetchQuery != null && queryRef != null) {\n    // If refetch was called, we expect to have a refetchQuery and queryRef\n    // in state, since both state updates to set the refetchQuery and the\n    // queryRef occur simultaneously.\n    // In this case, we need to read the refetched query data (potentially\n    // suspending if it's in flight), and extract the new fragment ref\n    // from the query in order read the current @refetchable fragment\n    // with the updated fragment owner as the new refetchQuery.\n    // Before observing the refetch, record the current ID and typename\n    // so that, if we are refetching existing data on\n    // a field that implements Node, after refetching we\n    // can validate that the received data is consistent\n    var debugPreviousIDAndTypename;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      debugPreviousIDAndTypename = debugFunctions.getInitialIDAndType(refetchQuery.request.variables, fragmentRefPathInResponse, environment);\n    }\n\n    var handleQueryCompleted = function handleQueryCompleted(maybeError) {\n      onComplete && onComplete(maybeError !== null && maybeError !== void 0 ? maybeError : null);\n    }; // The queryRef.source obtained from useQueryLoader will be\n    // an observable we can consume /if/ a network request was\n    // started. Otherwise, given that QueryResource.prepare\n    // always expects an observable we fall back to a new network\n    // observable. Note however that if loadQuery did not make a network\n    // request, we don't expect to make one here, unless the state of\n    // the cache has changed between the call to refetch and this\n    // render.\n\n\n    var fetchObservable = queryRef.source != null ? queryRef.source : fetchQuery(environment, refetchQuery); // Now wwe can we read the refetch query here using the\n    // queryRef provided from useQueryLoader. Note that the\n    // network request is started during the call to refetch,\n    // but if the refetch query is still in flight, we will suspend\n    // at this point:\n\n    var queryResult = profilerContext.wrapPrepareQueryResource(function () {\n      return QueryResource.prepare(refetchQuery, fetchObservable, fetchPolicy, renderPolicy, {\n        error: handleQueryCompleted,\n        complete: function complete() {\n          // Validate that the type of the object we got back matches the type\n          // of the object already in the store\n          if (process.env.NODE_ENV !== \"production\") {\n            debugFunctions.checkSameTypeAfterRefetch(debugPreviousIDAndTypename, environment, fragmentNode, componentDisplayName);\n          }\n\n          handleQueryCompleted();\n        }\n      }, queryRef.fetchKey, profilerContext);\n    });\n    var queryData = FragmentResource.read(queryResult.fragmentNode, queryResult.fragmentRef, componentDisplayName).data;\n    !(queryData != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to be able to read refetch query response. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0; // After reading/fetching the refetch query, we extract from the\n    // refetch query response the new fragment ref we need to use to read\n    // the fragment. The new fragment ref will point to the refetch query\n    // as its fragment owner.\n\n    var refetchedFragmentRef = getValueAtPath(queryData, fragmentRefPathInResponse);\n    fragmentRef = refetchedFragmentRef;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      // Validate that the id of the object we got back matches the id\n      // we queried for in the variables.\n      // We do this during render instead of onComplete to make sure we are\n      // only validating the most recent refetch.\n      debugFunctions.checkSameIDAfterRefetch(debugPreviousIDAndTypename, fragmentRef, fragmentNode, componentDisplayName);\n    }\n  } // We read and subscribe to the fragment using useFragmentNode.\n  // If refetch was called, we read the fragment using the new computed\n  // fragment ref from the refetch query response; otherwise, we use the\n  // fragment ref passed by the caller as normal.\n\n\n  var _useFragmentNode = useFragmentNode(fragmentNode, fragmentRef, componentDisplayName),\n      fragmentData = _useFragmentNode.data,\n      disableStoreUpdates = _useFragmentNode.disableStoreUpdates,\n      enableStoreUpdates = _useFragmentNode.enableStoreUpdates;\n\n  var refetch = useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierField, loadQuery, parentFragmentRef, refetchableRequest);\n  return {\n    fragmentData: fragmentData,\n    fragmentRef: fragmentRef,\n    refetch: refetch,\n    disableStoreUpdates: disableStoreUpdates,\n    enableStoreUpdates: enableStoreUpdates\n  };\n}\n\nfunction useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierField, loadQuery, parentFragmentRef, refetchableRequest) {\n  var isMountedRef = useIsMountedRef();\n  var identifierValue = identifierField != null && fragmentData != null && typeof fragmentData === 'object' ? fragmentData[identifierField] : null;\n  return useCallback(function (providedRefetchVariables, options) {\n    // Bail out and warn if we're trying to refetch after the component\n    // has unmounted\n    if (isMountedRef.current !== true) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected call to `refetch` on unmounted component for fragment ' + '`%s` in `%s`. It looks like some instances of your component are ' + 'still trying to fetch data but they already unmounted. ' + 'Please make sure you clear all timers, intervals, ' + 'async calls, etc that may trigger a fetch.', fragmentNode.name, componentDisplayName) : void 0;\n      return {\n        dispose: function dispose() {}\n      };\n    }\n\n    if (parentFragmentRef == null) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected call to `refetch` while using a null fragment ref ' + 'for fragment `%s` in `%s`. When calling `refetch`, we expect ' + \"initial fragment data to be non-null. Please make sure you're \" + 'passing a valid fragment ref to `%s` before calling ' + '`refetch`, or make sure you pass all required variables to `refetch`.', fragmentNode.name, componentDisplayName, componentDisplayName) : void 0;\n    }\n\n    var refetchEnvironment = options === null || options === void 0 ? void 0 : options.__environment;\n    var fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy;\n    var renderPolicy = options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy;\n    var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;\n    var fragmentSelector = getSelector(fragmentNode, parentFragmentRef);\n    var parentVariables;\n    var fragmentVariables;\n\n    if (fragmentSelector == null) {\n      parentVariables = {};\n      fragmentVariables = {};\n    } else if (fragmentSelector.kind === 'PluralReaderSelector') {\n      var _fragmentSelector$sel, _fragmentSelector$sel2, _fragmentSelector$sel3, _fragmentSelector$sel4;\n\n      parentVariables = (_fragmentSelector$sel = (_fragmentSelector$sel2 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel2 === void 0 ? void 0 : _fragmentSelector$sel2.owner.variables) !== null && _fragmentSelector$sel !== void 0 ? _fragmentSelector$sel : {};\n      fragmentVariables = (_fragmentSelector$sel3 = (_fragmentSelector$sel4 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel4 === void 0 ? void 0 : _fragmentSelector$sel4.variables) !== null && _fragmentSelector$sel3 !== void 0 ? _fragmentSelector$sel3 : {};\n    } else {\n      parentVariables = fragmentSelector.owner.variables;\n      fragmentVariables = fragmentSelector.variables;\n    } // A user of `useRefetchableFragment()` may pass a subset of\n    // all variables required by the fragment when calling `refetch()`.\n    // We fill in any variables not passed by the call to `refetch()` with the\n    // variables from the original parent fragment owner.\n\n\n    var refetchVariables = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, parentVariables), fragmentVariables), providedRefetchVariables); // If the query needs an identifier value ('id' or similar) and one\n    // was not explicitly provided, read it from the fragment data.\n\n    if (identifierField != null && !providedRefetchVariables.hasOwnProperty('id')) {\n      // @refetchable fragments are guaranteed to have an `id` selection\n      // if the type is Node, implements Node, or is @fetchable. Double-check\n      // that there actually is a value at runtime.\n      if (typeof identifierValue !== 'string') {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Expected result to have a string  ' + '`%s` in order to refetch, got `%s`.', identifierField, identifierValue) : void 0;\n      }\n\n      refetchVariables.id = identifierValue;\n    }\n\n    var refetchQuery = createOperationDescriptor(refetchableRequest, refetchVariables, {\n      force: true\n    }); // We call loadQuery which will start a network request if necessary\n    // and update the querRef from useQueryLoader.\n    // Note the following:\n    // - loadQuery will dispose of any previously refetched queries.\n    // - We use the variables extracted off the OperationDescriptor\n    // so that they have been filtered out to include only the\n    // variables actually declared in the query.\n\n    loadQuery(refetchQuery.request.variables, {\n      fetchPolicy: fetchPolicy,\n      __environment: refetchEnvironment,\n      __nameForWarning: 'refetch'\n    });\n    dispatch({\n      type: 'refetch',\n      fetchPolicy: fetchPolicy,\n      onComplete: onComplete,\n      refetchEnvironment: refetchEnvironment,\n      refetchQuery: refetchQuery,\n      renderPolicy: renderPolicy\n    });\n    return {\n      dispose: disposeQuery\n    };\n  }, // NOTE: We disable react-hooks-deps warning because:\n  //   - We know fragmentRefPathInResponse is static, so it can be omitted from\n  //     deps\n  //   - We know fragmentNode is static, so it can be omitted from deps.\n  //   - fragmentNode and parentFragmentRef are also captured by including\n  //     fragmentIdentifier\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [fragmentIdentifier, dispatch, disposeQuery, identifierValue, loadQuery]);\n}\n\nvar debugFunctions;\n\nif (process.env.NODE_ENV !== \"production\") {\n  debugFunctions = {\n    getInitialIDAndType: function getInitialIDAndType(memoRefetchVariables, fragmentRefPathInResponse, environment) {\n      var _require5 = require('relay-runtime'),\n          Record = _require5.Record;\n\n      var id = memoRefetchVariables === null || memoRefetchVariables === void 0 ? void 0 : memoRefetchVariables.id;\n\n      if (fragmentRefPathInResponse.length !== 1 || fragmentRefPathInResponse[0] !== 'node' || id == null) {\n        return null;\n      }\n\n      var recordSource = environment.getStore().getSource();\n      var record = recordSource.get(id);\n      var typename = record && Record.getType(record);\n\n      if (typename == null) {\n        return null;\n      }\n\n      return {\n        id: id,\n        typename: typename\n      };\n    },\n    checkSameTypeAfterRefetch: function checkSameTypeAfterRefetch(previousIDAndType, environment, fragmentNode, componentDisplayName) {\n      var _require6 = require('relay-runtime'),\n          Record = _require6.Record;\n\n      if (!previousIDAndType) {\n        return;\n      }\n\n      var recordSource = environment.getStore().getSource();\n      var record = recordSource.get(previousIDAndType.id);\n      var typename = record && Record.getType(record);\n\n      if (typename !== previousIDAndType.typename) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Call to `refetch` returned data with a different ' + '__typename: was `%s`, now `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements' + 'unique id requirement.', previousIDAndType.typename, typename, fragmentNode.name, componentDisplayName) : void 0;\n      }\n    },\n    checkSameIDAfterRefetch: function checkSameIDAfterRefetch(previousIDAndTypename, refetchedFragmentRef, fragmentNode, componentDisplayName) {\n      if (previousIDAndTypename == null) {\n        return;\n      }\n\n      var _require7 = require('relay-runtime'),\n          ID_KEY = _require7.ID_KEY; // $FlowExpectedError[incompatible-use]\n\n\n      var resultID = refetchedFragmentRef[ID_KEY];\n\n      if (resultID != null && resultID !== previousIDAndTypename.id) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Call to `refetch` returned a different id, expected ' + '`%s`, got `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements ' + 'unique id requirement.', resultID, previousIDAndTypename.id, fragmentNode.name, componentDisplayName) : void 0;\n      }\n    }\n  };\n}\n\nmodule.exports = useRefetchableFragmentNode;"]},"metadata":{},"sourceType":"script"}