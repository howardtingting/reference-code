{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar _require = require('./ClientID'),\n    generateClientID = _require.generateClientID;\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require2 = require('./RelayStoreUtils'),\n    RELAY_RESOLVER_INPUTS_KEY = _require2.RELAY_RESOLVER_INPUTS_KEY,\n    RELAY_RESOLVER_INVALIDATION_KEY = _require2.RELAY_RESOLVER_INVALIDATION_KEY,\n    RELAY_RESOLVER_MISSING_REQUIRED_FIELDS_KEY = _require2.RELAY_RESOLVER_MISSING_REQUIRED_FIELDS_KEY,\n    RELAY_RESOLVER_READER_SELECTOR_KEY = _require2.RELAY_RESOLVER_READER_SELECTOR_KEY,\n    RELAY_RESOLVER_VALUE_KEY = _require2.RELAY_RESOLVER_VALUE_KEY,\n    getStorageKey = _require2.getStorageKey;\n\nvar warning = require(\"fbjs/lib/warning\"); // $FlowFixMe[unclear-type] - will always be empty\n\n\nvar emptySet = new Set();\n\nvar NoopResolverCache = /*#__PURE__*/function () {\n  function NoopResolverCache() {}\n\n  var _proto = NoopResolverCache.prototype;\n\n  _proto.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(record, field, variables, evaluate, getDataForResolverFragment) {\n    var _evaluate = evaluate(),\n        resolverResult = _evaluate.resolverResult,\n        missingRequiredFields = _evaluate.missingRequiredFields;\n\n    return [resolverResult, undefined, missingRequiredFields];\n  };\n\n  _proto.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {};\n\n  return NoopResolverCache;\n}();\n\nfunction addDependencyEdge(edges, from, to) {\n  var set = edges.get(from);\n\n  if (!set) {\n    set = new Set();\n    edges.set(from, set);\n  }\n\n  set.add(to);\n}\n\nvar RecordResolverCache = /*#__PURE__*/function () {\n  function RecordResolverCache(getRecordSource) {\n    this._resolverIDToRecordIDs = new Map();\n    this._recordIDToResolverIDs = new Map();\n    this._getRecordSource = getRecordSource;\n  }\n\n  var _proto2 = RecordResolverCache.prototype;\n\n  _proto2.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(record, field, variables, evaluate, getDataForResolverFragment) {\n    var recordSource = this._getRecordSource();\n\n    var recordID = RelayModernRecord.getDataID(record);\n    var storageKey = getStorageKey(field, variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n    var linkedRecord = linkedID == null ? null : recordSource.get(linkedID);\n\n    if (linkedRecord == null || this._isInvalid(linkedRecord, getDataForResolverFragment)) {\n      var _linkedID; // Cache miss; evaluate the selector and store the result in a new record:\n\n\n      linkedID = (_linkedID = linkedID) !== null && _linkedID !== void 0 ? _linkedID : generateClientID(recordID, storageKey);\n      linkedRecord = RelayModernRecord.create(linkedID, '__RELAY_RESOLVER__');\n      var evaluationResult = evaluate();\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_VALUE_KEY, evaluationResult.resolverResult);\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_INPUTS_KEY, evaluationResult.fragmentValue);\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_READER_SELECTOR_KEY, evaluationResult.readerSelector);\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_MISSING_REQUIRED_FIELDS_KEY, evaluationResult.missingRequiredFields);\n      recordSource.set(linkedID, linkedRecord); // Link the resolver value record to the resolver field of the record being read:\n\n      var nextRecord = RelayModernRecord.clone(record);\n      RelayModernRecord.setLinkedRecordID(nextRecord, storageKey, linkedID);\n      recordSource.set(RelayModernRecord.getDataID(nextRecord), nextRecord); // Put records observed by the resolver into the dependency graph:\n\n      var resolverID = evaluationResult.resolverID;\n      addDependencyEdge(this._resolverIDToRecordIDs, resolverID, linkedID);\n      addDependencyEdge(this._recordIDToResolverIDs, recordID, resolverID);\n\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(evaluationResult.seenRecordIDs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var seenRecordID = _step.value;\n          addDependencyEdge(this._recordIDToResolverIDs, seenRecordID, resolverID);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } // $FlowFixMe[incompatible-type] - will always be empty\n\n\n    var answer = linkedRecord[RELAY_RESOLVER_VALUE_KEY];\n    var missingRequiredFields = // $FlowFixMe[incompatible-type] - casting mixed\n    linkedRecord[RELAY_RESOLVER_MISSING_REQUIRED_FIELDS_KEY];\n    return [answer, linkedID, missingRequiredFields];\n  };\n\n  _proto2.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {\n    var recordSource = this._getRecordSource();\n\n    var visited = new Set();\n    var recordsToVisit = Array.from(updatedDataIDs);\n\n    while (recordsToVisit.length) {\n      var recordID = recordsToVisit.pop();\n      updatedDataIDs.add(recordID);\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])((_this$_recordIDToReso = this._recordIDToResolverIDs.get(recordID)) !== null && _this$_recordIDToReso !== void 0 ? _this$_recordIDToReso : emptySet),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _this$_recordIDToReso;\n\n          var fragment = _step2.value;\n\n          if (!visited.has(fragment)) {\n            var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])((_this$_resolverIDToRe = this._resolverIDToRecordIDs.get(fragment)) !== null && _this$_resolverIDToRe !== void 0 ? _this$_resolverIDToRe : emptySet),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _this$_resolverIDToRe;\n\n                var anotherRecordID = _step3.value;\n\n                this._markInvalidatedResolverRecord(anotherRecordID, recordSource, updatedDataIDs);\n\n                if (!visited.has(anotherRecordID)) {\n                  recordsToVisit.push(anotherRecordID);\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  };\n\n  _proto2._markInvalidatedResolverRecord = function _markInvalidatedResolverRecord(dataID, recordSource, // Written to\n  updatedDataIDs) // Mutated in place\n  {\n    var record = recordSource.get(dataID);\n\n    if (!record) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Expected a resolver record with ID %s, but it was missing.', dataID) : void 0;\n      return;\n    }\n\n    var nextRecord = RelayModernRecord.clone(record);\n    RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_INVALIDATION_KEY, true);\n    recordSource.set(dataID, nextRecord);\n  };\n\n  _proto2._isInvalid = function _isInvalid(record, getDataForResolverFragment) {\n    if (!RelayModernRecord.getValue(record, RELAY_RESOLVER_INVALIDATION_KEY)) {\n      return false;\n    }\n\n    var originalInputs = RelayModernRecord.getValue(record, RELAY_RESOLVER_INPUTS_KEY); // $FlowFixMe[incompatible-type] - storing values in records is not typed\n\n    var readerSelector = RelayModernRecord.getValue(record, RELAY_RESOLVER_READER_SELECTOR_KEY);\n\n    if (originalInputs == null || readerSelector == null) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Expected previous inputs and reader selector on resolver record with ID %s, but they were missing.', RelayModernRecord.getDataID(record)) : void 0;\n      return true;\n    }\n\n    var latestValues = getDataForResolverFragment(readerSelector);\n    var recycled = recycleNodesInto(originalInputs, latestValues);\n\n    if (recycled !== originalInputs) {\n      return true;\n    }\n\n    return false;\n  };\n\n  return RecordResolverCache;\n}();\n\nmodule.exports = {\n  NoopResolverCache: NoopResolverCache,\n  RecordResolverCache: RecordResolverCache\n};","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/store/ResolverCache.js"],"names":["_interopRequireDefault","require","_createForOfIteratorHelper2","recycleNodesInto","_require","generateClientID","RelayModernRecord","_require2","RELAY_RESOLVER_INPUTS_KEY","RELAY_RESOLVER_INVALIDATION_KEY","RELAY_RESOLVER_MISSING_REQUIRED_FIELDS_KEY","RELAY_RESOLVER_READER_SELECTOR_KEY","RELAY_RESOLVER_VALUE_KEY","getStorageKey","warning","emptySet","Set","NoopResolverCache","_proto","prototype","readFromCacheOrEvaluate","record","field","variables","evaluate","getDataForResolverFragment","_evaluate","resolverResult","missingRequiredFields","undefined","invalidateDataIDs","updatedDataIDs","addDependencyEdge","edges","from","to","set","get","add","RecordResolverCache","getRecordSource","_resolverIDToRecordIDs","Map","_recordIDToResolverIDs","_getRecordSource","_proto2","recordSource","recordID","getDataID","storageKey","linkedID","getLinkedRecordID","linkedRecord","_isInvalid","_linkedID","create","evaluationResult","setValue","fragmentValue","readerSelector","nextRecord","clone","setLinkedRecordID","resolverID","_iterator","seenRecordIDs","_step","s","n","done","seenRecordID","value","err","e","f","answer","visited","recordsToVisit","Array","length","pop","_iterator2","_this$_recordIDToReso","_step2","fragment","has","_iterator3","_this$_resolverIDToRe","_step3","anotherRecordID","_markInvalidatedResolverRecord","push","dataID","process","env","NODE_ENV","getValue","originalInputs","latestValues","recycled","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEA,IAAIC,2BAA2B,GAAGF,sBAAsB,CAACC,OAAO,CAAC,kDAAD,CAAR,CAAxD;;AAEA,IAAIE,gBAAgB,GAAGF,OAAO,CAAC,0BAAD,CAA9B;;AAEA,IAAIG,QAAQ,GAAGH,OAAO,CAAC,YAAD,CAAtB;AAAA,IACII,gBAAgB,GAAGD,QAAQ,CAACC,gBADhC;;AAGA,IAAIC,iBAAiB,GAAGL,OAAO,CAAC,qBAAD,CAA/B;;AAEA,IAAIM,SAAS,GAAGN,OAAO,CAAC,mBAAD,CAAvB;AAAA,IACIO,yBAAyB,GAAGD,SAAS,CAACC,yBAD1C;AAAA,IAEIC,+BAA+B,GAAGF,SAAS,CAACE,+BAFhD;AAAA,IAGIC,0CAA0C,GAAGH,SAAS,CAACG,0CAH3D;AAAA,IAIIC,kCAAkC,GAAGJ,SAAS,CAACI,kCAJnD;AAAA,IAKIC,wBAAwB,GAAGL,SAAS,CAACK,wBALzC;AAAA,IAMIC,aAAa,GAAGN,SAAS,CAACM,aAN9B;;AAQA,IAAIC,OAAO,GAAGb,OAAO,CAAC,kBAAD,CAArB,C,CAEA;;;AACA,IAAIc,QAAQ,GAAG,IAAIC,GAAJ,EAAf;;AAEA,IAAIC,iBAAiB,GAAG,aAAa,YAAY;AAC/C,WAASA,iBAAT,GAA6B,CAAE;;AAE/B,MAAIC,MAAM,GAAGD,iBAAiB,CAACE,SAA/B;;AAEAD,EAAAA,MAAM,CAACE,uBAAP,GAAiC,SAASA,uBAAT,CAAiCC,MAAjC,EAAyCC,KAAzC,EAAgDC,SAAhD,EAA2DC,QAA3D,EAAqEC,0BAArE,EAAiG;AAChI,QAAIC,SAAS,GAAGF,QAAQ,EAAxB;AAAA,QACIG,cAAc,GAAGD,SAAS,CAACC,cAD/B;AAAA,QAEIC,qBAAqB,GAAGF,SAAS,CAACE,qBAFtC;;AAIA,WAAO,CAACD,cAAD,EAAiBE,SAAjB,EAA4BD,qBAA5B,CAAP;AACD,GAND;;AAQAV,EAAAA,MAAM,CAACY,iBAAP,GAA2B,SAASA,iBAAT,CAA2BC,cAA3B,EAA2C,CAAE,CAAxE;;AAEA,SAAOd,iBAAP;AACD,CAhBoC,EAArC;;AAkBA,SAASe,iBAAT,CAA2BC,KAA3B,EAAkCC,IAAlC,EAAwCC,EAAxC,EAA4C;AAC1C,MAAIC,GAAG,GAAGH,KAAK,CAACI,GAAN,CAAUH,IAAV,CAAV;;AAEA,MAAI,CAACE,GAAL,EAAU;AACRA,IAAAA,GAAG,GAAG,IAAIpB,GAAJ,EAAN;AACAiB,IAAAA,KAAK,CAACG,GAAN,CAAUF,IAAV,EAAgBE,GAAhB;AACD;;AAEDA,EAAAA,GAAG,CAACE,GAAJ,CAAQH,EAAR;AACD;;AAED,IAAII,mBAAmB,GAAG,aAAa,YAAY;AACjD,WAASA,mBAAT,CAA6BC,eAA7B,EAA8C;AAC5C,SAAKC,sBAAL,GAA8B,IAAIC,GAAJ,EAA9B;AACA,SAAKC,sBAAL,GAA8B,IAAID,GAAJ,EAA9B;AACA,SAAKE,gBAAL,GAAwBJ,eAAxB;AACD;;AAED,MAAIK,OAAO,GAAGN,mBAAmB,CAACpB,SAAlC;;AAEA0B,EAAAA,OAAO,CAACzB,uBAAR,GAAkC,SAASA,uBAAT,CAAiCC,MAAjC,EAAyCC,KAAzC,EAAgDC,SAAhD,EAA2DC,QAA3D,EAAqEC,0BAArE,EAAiG;AACjI,QAAIqB,YAAY,GAAG,KAAKF,gBAAL,EAAnB;;AAEA,QAAIG,QAAQ,GAAGzC,iBAAiB,CAAC0C,SAAlB,CAA4B3B,MAA5B,CAAf;AACA,QAAI4B,UAAU,GAAGpC,aAAa,CAACS,KAAD,EAAQC,SAAR,CAA9B;AACA,QAAI2B,QAAQ,GAAG5C,iBAAiB,CAAC6C,iBAAlB,CAAoC9B,MAApC,EAA4C4B,UAA5C,CAAf;AACA,QAAIG,YAAY,GAAGF,QAAQ,IAAI,IAAZ,GAAmB,IAAnB,GAA0BJ,YAAY,CAACT,GAAb,CAAiBa,QAAjB,CAA7C;;AAEA,QAAIE,YAAY,IAAI,IAAhB,IAAwB,KAAKC,UAAL,CAAgBD,YAAhB,EAA8B3B,0BAA9B,CAA5B,EAAuF;AACrF,UAAI6B,SAAJ,CADqF,CAGrF;;;AACAJ,MAAAA,QAAQ,GAAG,CAACI,SAAS,GAAGJ,QAAb,MAA2B,IAA3B,IAAmCI,SAAS,KAAK,KAAK,CAAtD,GAA0DA,SAA1D,GAAsEjD,gBAAgB,CAAC0C,QAAD,EAAWE,UAAX,CAAjG;AACAG,MAAAA,YAAY,GAAG9C,iBAAiB,CAACiD,MAAlB,CAAyBL,QAAzB,EAAmC,oBAAnC,CAAf;AACA,UAAIM,gBAAgB,GAAGhC,QAAQ,EAA/B;AACAlB,MAAAA,iBAAiB,CAACmD,QAAlB,CAA2BL,YAA3B,EAAyCxC,wBAAzC,EAAmE4C,gBAAgB,CAAC7B,cAApF;AACArB,MAAAA,iBAAiB,CAACmD,QAAlB,CAA2BL,YAA3B,EAAyC5C,yBAAzC,EAAoEgD,gBAAgB,CAACE,aAArF;AACApD,MAAAA,iBAAiB,CAACmD,QAAlB,CAA2BL,YAA3B,EAAyCzC,kCAAzC,EAA6E6C,gBAAgB,CAACG,cAA9F;AACArD,MAAAA,iBAAiB,CAACmD,QAAlB,CAA2BL,YAA3B,EAAyC1C,0CAAzC,EAAqF8C,gBAAgB,CAAC5B,qBAAtG;AACAkB,MAAAA,YAAY,CAACV,GAAb,CAAiBc,QAAjB,EAA2BE,YAA3B,EAXqF,CAW3C;;AAE1C,UAAIQ,UAAU,GAAGtD,iBAAiB,CAACuD,KAAlB,CAAwBxC,MAAxB,CAAjB;AACAf,MAAAA,iBAAiB,CAACwD,iBAAlB,CAAoCF,UAApC,EAAgDX,UAAhD,EAA4DC,QAA5D;AACAJ,MAAAA,YAAY,CAACV,GAAb,CAAiB9B,iBAAiB,CAAC0C,SAAlB,CAA4BY,UAA5B,CAAjB,EAA0DA,UAA1D,EAfqF,CAed;;AAEvE,UAAIG,UAAU,GAAGP,gBAAgB,CAACO,UAAlC;AACA/B,MAAAA,iBAAiB,CAAC,KAAKS,sBAAN,EAA8BsB,UAA9B,EAA0Cb,QAA1C,CAAjB;AACAlB,MAAAA,iBAAiB,CAAC,KAAKW,sBAAN,EAA8BI,QAA9B,EAAwCgB,UAAxC,CAAjB;;AAEA,UAAIC,SAAS,GAAG,CAAC,GAAG9D,2BAA2B,CAAC,SAAD,CAA/B,EAA4CsD,gBAAgB,CAACS,aAA7D,CAAhB;AAAA,UACIC,KADJ;;AAGA,UAAI;AACF,aAAKF,SAAS,CAACG,CAAV,EAAL,EAAoB,CAAC,CAACD,KAAK,GAAGF,SAAS,CAACI,CAAV,EAAT,EAAwBC,IAA7C,GAAoD;AAClD,cAAIC,YAAY,GAAGJ,KAAK,CAACK,KAAzB;AACAvC,UAAAA,iBAAiB,CAAC,KAAKW,sBAAN,EAA8B2B,YAA9B,EAA4CP,UAA5C,CAAjB;AACD;AACF,OALD,CAKE,OAAOS,GAAP,EAAY;AACZR,QAAAA,SAAS,CAACS,CAAV,CAAYD,GAAZ;AACD,OAPD,SAOU;AACRR,QAAAA,SAAS,CAACU,CAAV;AACD;AACF,KA1CgI,CA0C/H;;;AAGF,QAAIC,MAAM,GAAGvB,YAAY,CAACxC,wBAAD,CAAzB;AACA,QAAIgB,qBAAqB,GAAG;AAC5BwB,IAAAA,YAAY,CAAC1C,0CAAD,CADZ;AAEA,WAAO,CAACiE,MAAD,EAASzB,QAAT,EAAmBtB,qBAAnB,CAAP;AACD,GAjDD;;AAmDAiB,EAAAA,OAAO,CAACf,iBAAR,GAA4B,SAASA,iBAAT,CAA2BC,cAA3B,EAA2C;AACrE,QAAIe,YAAY,GAAG,KAAKF,gBAAL,EAAnB;;AAEA,QAAIgC,OAAO,GAAG,IAAI5D,GAAJ,EAAd;AACA,QAAI6D,cAAc,GAAGC,KAAK,CAAC5C,IAAN,CAAWH,cAAX,CAArB;;AAEA,WAAO8C,cAAc,CAACE,MAAtB,EAA8B;AAC5B,UAAIhC,QAAQ,GAAG8B,cAAc,CAACG,GAAf,EAAf;AACAjD,MAAAA,cAAc,CAACO,GAAf,CAAmBS,QAAnB;;AAEA,UAAIkC,UAAU,GAAG,CAAC,GAAG/E,2BAA2B,CAAC,SAAD,CAA/B,EAA4C,CAACgF,qBAAqB,GAAG,KAAKvC,sBAAL,CAA4BN,GAA5B,CAAgCU,QAAhC,CAAzB,MAAwE,IAAxE,IAAgFmC,qBAAqB,KAAK,KAAK,CAA/G,GAAmHA,qBAAnH,GAA2InE,QAAvL,CAAjB;AAAA,UACIoE,MADJ;;AAGA,UAAI;AACF,aAAKF,UAAU,CAACd,CAAX,EAAL,EAAqB,CAAC,CAACgB,MAAM,GAAGF,UAAU,CAACb,CAAX,EAAV,EAA0BC,IAAhD,GAAuD;AACrD,cAAIa,qBAAJ;;AAEA,cAAIE,QAAQ,GAAGD,MAAM,CAACZ,KAAtB;;AAEA,cAAI,CAACK,OAAO,CAACS,GAAR,CAAYD,QAAZ,CAAL,EAA4B;AAC1B,gBAAIE,UAAU,GAAG,CAAC,GAAGpF,2BAA2B,CAAC,SAAD,CAA/B,EAA4C,CAACqF,qBAAqB,GAAG,KAAK9C,sBAAL,CAA4BJ,GAA5B,CAAgC+C,QAAhC,CAAzB,MAAwE,IAAxE,IAAgFG,qBAAqB,KAAK,KAAK,CAA/G,GAAmHA,qBAAnH,GAA2IxE,QAAvL,CAAjB;AAAA,gBACIyE,MADJ;;AAGA,gBAAI;AACF,mBAAKF,UAAU,CAACnB,CAAX,EAAL,EAAqB,CAAC,CAACqB,MAAM,GAAGF,UAAU,CAAClB,CAAX,EAAV,EAA0BC,IAAhD,GAAuD;AACrD,oBAAIkB,qBAAJ;;AAEA,oBAAIE,eAAe,GAAGD,MAAM,CAACjB,KAA7B;;AAEA,qBAAKmB,8BAAL,CAAoCD,eAApC,EAAqD3C,YAArD,EAAmEf,cAAnE;;AAEA,oBAAI,CAAC6C,OAAO,CAACS,GAAR,CAAYI,eAAZ,CAAL,EAAmC;AACjCZ,kBAAAA,cAAc,CAACc,IAAf,CAAoBF,eAApB;AACD;AACF;AACF,aAZD,CAYE,OAAOjB,GAAP,EAAY;AACZc,cAAAA,UAAU,CAACb,CAAX,CAAaD,GAAb;AACD,aAdD,SAcU;AACRc,cAAAA,UAAU,CAACZ,CAAX;AACD;AACF;AACF;AACF,OA7BD,CA6BE,OAAOF,GAAP,EAAY;AACZS,QAAAA,UAAU,CAACR,CAAX,CAAaD,GAAb;AACD,OA/BD,SA+BU;AACRS,QAAAA,UAAU,CAACP,CAAX;AACD;AACF;AACF,GAhDD;;AAkDA7B,EAAAA,OAAO,CAAC6C,8BAAR,GAAyC,SAASA,8BAAT,CAAwCE,MAAxC,EAAgD9C,YAAhD,EAA8D;AACvGf,EAAAA,cADyC,EACzB;AAChB;AACE,QAAIV,MAAM,GAAGyB,YAAY,CAACT,GAAb,CAAiBuD,MAAjB,CAAb;;AAEA,QAAI,CAACvE,MAAL,EAAa;AACXwE,MAAAA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCjF,OAAO,CAAC,KAAD,EAAQ,4DAAR,EAAsE8E,MAAtE,CAA/C,GAA+H,KAAK,CAApI;AACA;AACD;;AAED,QAAIhC,UAAU,GAAGtD,iBAAiB,CAACuD,KAAlB,CAAwBxC,MAAxB,CAAjB;AACAf,IAAAA,iBAAiB,CAACmD,QAAlB,CAA2BG,UAA3B,EAAuCnD,+BAAvC,EAAwE,IAAxE;AACAqC,IAAAA,YAAY,CAACV,GAAb,CAAiBwD,MAAjB,EAAyBhC,UAAzB;AACD,GAbD;;AAeAf,EAAAA,OAAO,CAACQ,UAAR,GAAqB,SAASA,UAAT,CAAoBhC,MAApB,EAA4BI,0BAA5B,EAAwD;AAC3E,QAAI,CAACnB,iBAAiB,CAAC0F,QAAlB,CAA2B3E,MAA3B,EAAmCZ,+BAAnC,CAAL,EAA0E;AACxE,aAAO,KAAP;AACD;;AAED,QAAIwF,cAAc,GAAG3F,iBAAiB,CAAC0F,QAAlB,CAA2B3E,MAA3B,EAAmCb,yBAAnC,CAArB,CAL2E,CAKS;;AAEpF,QAAImD,cAAc,GAAGrD,iBAAiB,CAAC0F,QAAlB,CAA2B3E,MAA3B,EAAmCV,kCAAnC,CAArB;;AAEA,QAAIsF,cAAc,IAAI,IAAlB,IAA0BtC,cAAc,IAAI,IAAhD,EAAsD;AACpDkC,MAAAA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCjF,OAAO,CAAC,KAAD,EAAQ,oGAAR,EAA8GR,iBAAiB,CAAC0C,SAAlB,CAA4B3B,MAA5B,CAA9G,CAA/C,GAAoM,KAAK,CAAzM;AACA,aAAO,IAAP;AACD;;AAED,QAAI6E,YAAY,GAAGzE,0BAA0B,CAACkC,cAAD,CAA7C;AACA,QAAIwC,QAAQ,GAAGhG,gBAAgB,CAAC8F,cAAD,EAAiBC,YAAjB,CAA/B;;AAEA,QAAIC,QAAQ,KAAKF,cAAjB,EAAiC;AAC/B,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD,GAtBD;;AAwBA,SAAO1D,mBAAP;AACD,CAtJsC,EAAvC;;AAwJA6D,MAAM,CAACC,OAAP,GAAiB;AACfpF,EAAAA,iBAAiB,EAAEA,iBADJ;AAEfsB,EAAAA,mBAAmB,EAAEA;AAFN,CAAjB","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar _require = require('./ClientID'),\n    generateClientID = _require.generateClientID;\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require2 = require('./RelayStoreUtils'),\n    RELAY_RESOLVER_INPUTS_KEY = _require2.RELAY_RESOLVER_INPUTS_KEY,\n    RELAY_RESOLVER_INVALIDATION_KEY = _require2.RELAY_RESOLVER_INVALIDATION_KEY,\n    RELAY_RESOLVER_MISSING_REQUIRED_FIELDS_KEY = _require2.RELAY_RESOLVER_MISSING_REQUIRED_FIELDS_KEY,\n    RELAY_RESOLVER_READER_SELECTOR_KEY = _require2.RELAY_RESOLVER_READER_SELECTOR_KEY,\n    RELAY_RESOLVER_VALUE_KEY = _require2.RELAY_RESOLVER_VALUE_KEY,\n    getStorageKey = _require2.getStorageKey;\n\nvar warning = require(\"fbjs/lib/warning\");\n\n// $FlowFixMe[unclear-type] - will always be empty\nvar emptySet = new Set();\n\nvar NoopResolverCache = /*#__PURE__*/function () {\n  function NoopResolverCache() {}\n\n  var _proto = NoopResolverCache.prototype;\n\n  _proto.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(record, field, variables, evaluate, getDataForResolverFragment) {\n    var _evaluate = evaluate(),\n        resolverResult = _evaluate.resolverResult,\n        missingRequiredFields = _evaluate.missingRequiredFields;\n\n    return [resolverResult, undefined, missingRequiredFields];\n  };\n\n  _proto.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {};\n\n  return NoopResolverCache;\n}();\n\nfunction addDependencyEdge(edges, from, to) {\n  var set = edges.get(from);\n\n  if (!set) {\n    set = new Set();\n    edges.set(from, set);\n  }\n\n  set.add(to);\n}\n\nvar RecordResolverCache = /*#__PURE__*/function () {\n  function RecordResolverCache(getRecordSource) {\n    this._resolverIDToRecordIDs = new Map();\n    this._recordIDToResolverIDs = new Map();\n    this._getRecordSource = getRecordSource;\n  }\n\n  var _proto2 = RecordResolverCache.prototype;\n\n  _proto2.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(record, field, variables, evaluate, getDataForResolverFragment) {\n    var recordSource = this._getRecordSource();\n\n    var recordID = RelayModernRecord.getDataID(record);\n    var storageKey = getStorageKey(field, variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n    var linkedRecord = linkedID == null ? null : recordSource.get(linkedID);\n\n    if (linkedRecord == null || this._isInvalid(linkedRecord, getDataForResolverFragment)) {\n      var _linkedID;\n\n      // Cache miss; evaluate the selector and store the result in a new record:\n      linkedID = (_linkedID = linkedID) !== null && _linkedID !== void 0 ? _linkedID : generateClientID(recordID, storageKey);\n      linkedRecord = RelayModernRecord.create(linkedID, '__RELAY_RESOLVER__');\n      var evaluationResult = evaluate();\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_VALUE_KEY, evaluationResult.resolverResult);\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_INPUTS_KEY, evaluationResult.fragmentValue);\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_READER_SELECTOR_KEY, evaluationResult.readerSelector);\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_MISSING_REQUIRED_FIELDS_KEY, evaluationResult.missingRequiredFields);\n      recordSource.set(linkedID, linkedRecord); // Link the resolver value record to the resolver field of the record being read:\n\n      var nextRecord = RelayModernRecord.clone(record);\n      RelayModernRecord.setLinkedRecordID(nextRecord, storageKey, linkedID);\n      recordSource.set(RelayModernRecord.getDataID(nextRecord), nextRecord); // Put records observed by the resolver into the dependency graph:\n\n      var resolverID = evaluationResult.resolverID;\n      addDependencyEdge(this._resolverIDToRecordIDs, resolverID, linkedID);\n      addDependencyEdge(this._recordIDToResolverIDs, recordID, resolverID);\n\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(evaluationResult.seenRecordIDs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var seenRecordID = _step.value;\n          addDependencyEdge(this._recordIDToResolverIDs, seenRecordID, resolverID);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } // $FlowFixMe[incompatible-type] - will always be empty\n\n\n    var answer = linkedRecord[RELAY_RESOLVER_VALUE_KEY];\n    var missingRequiredFields = // $FlowFixMe[incompatible-type] - casting mixed\n    linkedRecord[RELAY_RESOLVER_MISSING_REQUIRED_FIELDS_KEY];\n    return [answer, linkedID, missingRequiredFields];\n  };\n\n  _proto2.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {\n    var recordSource = this._getRecordSource();\n\n    var visited = new Set();\n    var recordsToVisit = Array.from(updatedDataIDs);\n\n    while (recordsToVisit.length) {\n      var recordID = recordsToVisit.pop();\n      updatedDataIDs.add(recordID);\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])((_this$_recordIDToReso = this._recordIDToResolverIDs.get(recordID)) !== null && _this$_recordIDToReso !== void 0 ? _this$_recordIDToReso : emptySet),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _this$_recordIDToReso;\n\n          var fragment = _step2.value;\n\n          if (!visited.has(fragment)) {\n            var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])((_this$_resolverIDToRe = this._resolverIDToRecordIDs.get(fragment)) !== null && _this$_resolverIDToRe !== void 0 ? _this$_resolverIDToRe : emptySet),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _this$_resolverIDToRe;\n\n                var anotherRecordID = _step3.value;\n\n                this._markInvalidatedResolverRecord(anotherRecordID, recordSource, updatedDataIDs);\n\n                if (!visited.has(anotherRecordID)) {\n                  recordsToVisit.push(anotherRecordID);\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  };\n\n  _proto2._markInvalidatedResolverRecord = function _markInvalidatedResolverRecord(dataID, recordSource, // Written to\n  updatedDataIDs) // Mutated in place\n  {\n    var record = recordSource.get(dataID);\n\n    if (!record) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Expected a resolver record with ID %s, but it was missing.', dataID) : void 0;\n      return;\n    }\n\n    var nextRecord = RelayModernRecord.clone(record);\n    RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_INVALIDATION_KEY, true);\n    recordSource.set(dataID, nextRecord);\n  };\n\n  _proto2._isInvalid = function _isInvalid(record, getDataForResolverFragment) {\n    if (!RelayModernRecord.getValue(record, RELAY_RESOLVER_INVALIDATION_KEY)) {\n      return false;\n    }\n\n    var originalInputs = RelayModernRecord.getValue(record, RELAY_RESOLVER_INPUTS_KEY); // $FlowFixMe[incompatible-type] - storing values in records is not typed\n\n    var readerSelector = RelayModernRecord.getValue(record, RELAY_RESOLVER_READER_SELECTOR_KEY);\n\n    if (originalInputs == null || readerSelector == null) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Expected previous inputs and reader selector on resolver record with ID %s, but they were missing.', RelayModernRecord.getDataID(record)) : void 0;\n      return true;\n    }\n\n    var latestValues = getDataForResolverFragment(readerSelector);\n    var recycled = recycleNodesInto(originalInputs, latestValues);\n\n    if (recycled !== originalInputs) {\n      return true;\n    }\n\n    return false;\n  };\n\n  return RecordResolverCache;\n}();\n\nmodule.exports = {\n  NoopResolverCache: NoopResolverCache,\n  RecordResolverCache: RecordResolverCache\n};"]},"metadata":{},"sourceType":"script"}