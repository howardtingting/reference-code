{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _require = require('./loadQuery'),\n    loadQuery = _require.loadQuery,\n    useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;\n\nvar useIsMountedRef = require('./useIsMountedRef');\n\nvar useRelayEnvironment = require('./useRelayEnvironment');\n\nvar _require2 = require('react'),\n    useCallback = _require2.useCallback,\n    useEffect = _require2.useEffect,\n    useRef = _require2.useRef,\n    useState = _require2.useState;\n\nvar _require3 = require('relay-runtime'),\n    getRequest = _require3.getRequest;\n\nvar initialNullQueryReferenceState = {\n  kind: 'NullQueryReference'\n};\n\nfunction requestIsLiveQuery(preloadableRequest) {\n  if (preloadableRequest.kind === 'PreloadableConcreteRequest') {\n    return preloadableRequest.params.metadata.live !== undefined;\n  }\n\n  var request = getRequest(preloadableRequest);\n  return request.params.metadata.live !== undefined;\n}\n\nfunction useQueryLoader(preloadableRequest, initialQueryReference) {\n  /**\n   * We want to always call `queryReference.dispose()` for every call to\n   * `setQueryReference(loadQuery(...))` so that no leaks of data in Relay stores\n   * will occur.\n   *\n   * However, a call to `setState(newState)` is not always followed by a commit where\n   * this value is reflected in the state. Thus, we cannot reliably clean up each\n   * ref with `useEffect(() => () => queryReference.dispose(), [queryReference])`.\n   *\n   * Instead, we keep track of each call to `loadQuery` in a ref.\n   * Relying on the fact that if a state change commits, no state changes that were\n   * initiated prior to the currently committing state change will ever subsequently\n   * commit, we can safely dispose of all preloaded query references\n   * associated with state changes initiated prior to the currently committing state\n   * change.\n   *\n   * Finally, when the hook unmounts, we also dispose of all remaining uncommitted\n   * query references.\n   */\n  var initialQueryReferenceInternal = initialQueryReference !== null && initialQueryReference !== void 0 ? initialQueryReference : initialNullQueryReferenceState;\n  var environment = useRelayEnvironment();\n  useTrackLoadQueryInRender();\n  var isMountedRef = useIsMountedRef();\n  var undisposedQueryReferencesRef = useRef(new Set([initialQueryReferenceInternal]));\n\n  var _useState = useState(function () {\n    return initialQueryReferenceInternal;\n  }),\n      queryReference = _useState[0],\n      setQueryReference = _useState[1];\n\n  var _useState2 = useState(function () {\n    return initialQueryReferenceInternal;\n  }),\n      previousInitialQueryReference = _useState2[0],\n      setPreviousInitialQueryReference = _useState2[1];\n\n  if (initialQueryReferenceInternal !== previousInitialQueryReference) {\n    // Rendering the query reference makes it \"managed\" by this hook, so\n    // we start keeping track of it so we can dispose it when it is no longer\n    // necessary here\n    // TODO(T78446637): Handle disposal of managed query references in\n    // components that were never mounted after rendering\n    undisposedQueryReferencesRef.current.add(initialQueryReferenceInternal);\n    setPreviousInitialQueryReference(initialQueryReferenceInternal);\n    setQueryReference(initialQueryReferenceInternal);\n  }\n\n  var disposeQuery = useCallback(function () {\n    if (isMountedRef.current) {\n      undisposedQueryReferencesRef.current.add(initialNullQueryReferenceState);\n      setQueryReference(initialNullQueryReferenceState);\n    }\n  }, [isMountedRef]);\n  var queryLoaderCallback = useCallback(function (variables, options) {\n    var mergedOptions = options != null && options.hasOwnProperty('__environment') ? {\n      fetchPolicy: options.fetchPolicy,\n      networkCacheConfig: options.networkCacheConfig,\n      __nameForWarning: options.__nameForWarning\n    } : options;\n\n    if (isMountedRef.current) {\n      var _options$__environmen;\n\n      var updatedQueryReference = loadQuery((_options$__environmen = options === null || options === void 0 ? void 0 : options.__environment) !== null && _options$__environmen !== void 0 ? _options$__environmen : environment, preloadableRequest, variables, mergedOptions);\n      undisposedQueryReferencesRef.current.add(updatedQueryReference);\n      setQueryReference(updatedQueryReference);\n    }\n  }, [environment, preloadableRequest, setQueryReference, isMountedRef]);\n  var maybeHiddenOrFastRefresh = useRef(false);\n  useEffect(function () {\n    return function () {\n      // Attempt to detect if the component was\n      // hidden (by Offscreen API), or fast refresh occured;\n      // Only in these situations would the effect cleanup\n      // for \"unmounting\" run multiple times, so if\n      // we are ever able to read this ref with a value\n      // of true, it means that one of these cases\n      // has happened.\n      maybeHiddenOrFastRefresh.current = true;\n    };\n  }, []);\n  useEffect(function () {\n    if (maybeHiddenOrFastRefresh.current === true) {\n      // This block only runs if the component has previously \"unmounted\"\n      // due to it being hidden by the Offscreen API, or during fast refresh.\n      // At this point, the current queryReference will have been disposed\n      // by the previous cleanup, so instead of attempting to\n      // do our regular commit setup, which would incorrectly leave our\n      // current queryReference disposed, we need to load the query again\n      // and force a re-render by calling queryLoaderCallback again,\n      // so that the queryReference is correctly re-retained, and\n      // potentially refetched if necessary.\n      maybeHiddenOrFastRefresh.current = false;\n\n      if (queryReference.kind !== 'NullQueryReference') {\n        queryLoaderCallback(queryReference.variables, {\n          fetchPolicy: queryReference.fetchPolicy,\n          networkCacheConfig: queryReference.networkCacheConfig\n        });\n      }\n\n      return;\n    } // When a new queryReference is committed, we iterate over all\n    // query references in undisposedQueryReferences and dispose all of\n    // the refs that aren't the currently committed one. This ensures\n    // that we don't leave any dangling query references for the\n    // case that loadQuery is called multiple times before commit; when\n    // this happens, multiple state updates will be scheduled, but only one\n    // will commit, meaning that we need to keep track of and dispose any\n    // query references that don't end up committing.\n    // - We are relying on the fact that sets iterate in insertion order, and we\n    // can remove items from a set as we iterate over it (i.e. no iterator\n    // invalidation issues.) Thus, it is safe to loop through\n    // undisposedQueryReferences until we find queryReference, and\n    // remove and dispose all previous references.\n    // - We are guaranteed to find queryReference in the set, because if a\n    // state update results in a commit, no state updates initiated prior to that\n    // one will be committed, and we are disposing and removing references\n    // associated with updates that were scheduled prior to the currently\n    // committing state change. (A useEffect callback is called during the commit\n    // phase.)\n\n\n    var undisposedQueryReferences = undisposedQueryReferencesRef.current;\n\n    if (isMountedRef.current) {\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(undisposedQueryReferences),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var undisposedQueryReference = _step.value;\n\n          if (undisposedQueryReference === queryReference) {\n            break;\n          }\n\n          undisposedQueryReferences[\"delete\"](undisposedQueryReference);\n\n          if (undisposedQueryReference.kind !== 'NullQueryReference') {\n            if (requestIsLiveQuery(preloadableRequest)) {\n              undisposedQueryReference.dispose && undisposedQueryReference.dispose();\n            } else {\n              undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, [queryReference, isMountedRef, queryLoaderCallback, preloadableRequest]);\n  useEffect(function () {\n    return function disposeAllRemainingQueryReferences() {\n      // undisposedQueryReferences.current is never reassigned\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(undisposedQueryReferencesRef.current),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var undisposedQueryReference = _step2.value;\n\n          if (undisposedQueryReference.kind !== 'NullQueryReference') {\n            if (requestIsLiveQuery(preloadableRequest)) {\n              undisposedQueryReference.dispose && undisposedQueryReference.dispose();\n            } else {\n              undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    };\n  }, [preloadableRequest]);\n  return [queryReference.kind === 'NullQueryReference' ? null : queryReference, queryLoaderCallback, disposeQuery];\n}\n\nmodule.exports = useQueryLoader;","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/react-relay/lib/relay-hooks/useQueryLoader.js"],"names":["_interopRequireDefault","require","_createForOfIteratorHelper2","_require","loadQuery","useTrackLoadQueryInRender","useIsMountedRef","useRelayEnvironment","_require2","useCallback","useEffect","useRef","useState","_require3","getRequest","initialNullQueryReferenceState","kind","requestIsLiveQuery","preloadableRequest","params","metadata","live","undefined","request","useQueryLoader","initialQueryReference","initialQueryReferenceInternal","environment","isMountedRef","undisposedQueryReferencesRef","Set","_useState","queryReference","setQueryReference","_useState2","previousInitialQueryReference","setPreviousInitialQueryReference","current","add","disposeQuery","queryLoaderCallback","variables","options","mergedOptions","hasOwnProperty","fetchPolicy","networkCacheConfig","__nameForWarning","_options$__environmen","updatedQueryReference","__environment","maybeHiddenOrFastRefresh","undisposedQueryReferences","_iterator","_step","s","n","done","undisposedQueryReference","value","dispose","releaseQuery","err","e","f","disposeAllRemainingQueryReferences","_iterator2","_step2","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEA,IAAIC,2BAA2B,GAAGF,sBAAsB,CAACC,OAAO,CAAC,kDAAD,CAAR,CAAxD;;AAEA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,aAAD,CAAtB;AAAA,IACIG,SAAS,GAAGD,QAAQ,CAACC,SADzB;AAAA,IAEIC,yBAAyB,GAAGF,QAAQ,CAACE,yBAFzC;;AAIA,IAAIC,eAAe,GAAGL,OAAO,CAAC,mBAAD,CAA7B;;AAEA,IAAIM,mBAAmB,GAAGN,OAAO,CAAC,uBAAD,CAAjC;;AAEA,IAAIO,SAAS,GAAGP,OAAO,CAAC,OAAD,CAAvB;AAAA,IACIQ,WAAW,GAAGD,SAAS,CAACC,WAD5B;AAAA,IAEIC,SAAS,GAAGF,SAAS,CAACE,SAF1B;AAAA,IAGIC,MAAM,GAAGH,SAAS,CAACG,MAHvB;AAAA,IAIIC,QAAQ,GAAGJ,SAAS,CAACI,QAJzB;;AAMA,IAAIC,SAAS,GAAGZ,OAAO,CAAC,eAAD,CAAvB;AAAA,IACIa,UAAU,GAAGD,SAAS,CAACC,UAD3B;;AAGA,IAAIC,8BAA8B,GAAG;AACnCC,EAAAA,IAAI,EAAE;AAD6B,CAArC;;AAIA,SAASC,kBAAT,CAA4BC,kBAA5B,EAAgD;AAC9C,MAAIA,kBAAkB,CAACF,IAAnB,KAA4B,4BAAhC,EAA8D;AAC5D,WAAOE,kBAAkB,CAACC,MAAnB,CAA0BC,QAA1B,CAAmCC,IAAnC,KAA4CC,SAAnD;AACD;;AAED,MAAIC,OAAO,GAAGT,UAAU,CAACI,kBAAD,CAAxB;AACA,SAAOK,OAAO,CAACJ,MAAR,CAAeC,QAAf,CAAwBC,IAAxB,KAAiCC,SAAxC;AACD;;AAED,SAASE,cAAT,CAAwBN,kBAAxB,EAA4CO,qBAA5C,EAAmE;AACjE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,MAAIC,6BAA6B,GAAGD,qBAAqB,KAAK,IAA1B,IAAkCA,qBAAqB,KAAK,KAAK,CAAjE,GAAqEA,qBAArE,GAA6FV,8BAAjI;AACA,MAAIY,WAAW,GAAGpB,mBAAmB,EAArC;AACAF,EAAAA,yBAAyB;AACzB,MAAIuB,YAAY,GAAGtB,eAAe,EAAlC;AACA,MAAIuB,4BAA4B,GAAGlB,MAAM,CAAC,IAAImB,GAAJ,CAAQ,CAACJ,6BAAD,CAAR,CAAD,CAAzC;;AAEA,MAAIK,SAAS,GAAGnB,QAAQ,CAAC,YAAY;AACnC,WAAOc,6BAAP;AACD,GAFuB,CAAxB;AAAA,MAGIM,cAAc,GAAGD,SAAS,CAAC,CAAD,CAH9B;AAAA,MAIIE,iBAAiB,GAAGF,SAAS,CAAC,CAAD,CAJjC;;AAMA,MAAIG,UAAU,GAAGtB,QAAQ,CAAC,YAAY;AACpC,WAAOc,6BAAP;AACD,GAFwB,CAAzB;AAAA,MAGIS,6BAA6B,GAAGD,UAAU,CAAC,CAAD,CAH9C;AAAA,MAIIE,gCAAgC,GAAGF,UAAU,CAAC,CAAD,CAJjD;;AAMA,MAAIR,6BAA6B,KAAKS,6BAAtC,EAAqE;AACnE;AACA;AACA;AACA;AACA;AACAN,IAAAA,4BAA4B,CAACQ,OAA7B,CAAqCC,GAArC,CAAyCZ,6BAAzC;AACAU,IAAAA,gCAAgC,CAACV,6BAAD,CAAhC;AACAO,IAAAA,iBAAiB,CAACP,6BAAD,CAAjB;AACD;;AAED,MAAIa,YAAY,GAAG9B,WAAW,CAAC,YAAY;AACzC,QAAImB,YAAY,CAACS,OAAjB,EAA0B;AACxBR,MAAAA,4BAA4B,CAACQ,OAA7B,CAAqCC,GAArC,CAAyCvB,8BAAzC;AACAkB,MAAAA,iBAAiB,CAAClB,8BAAD,CAAjB;AACD;AACF,GAL6B,EAK3B,CAACa,YAAD,CAL2B,CAA9B;AAMA,MAAIY,mBAAmB,GAAG/B,WAAW,CAAC,UAAUgC,SAAV,EAAqBC,OAArB,EAA8B;AAClE,QAAIC,aAAa,GAAGD,OAAO,IAAI,IAAX,IAAmBA,OAAO,CAACE,cAAR,CAAuB,eAAvB,CAAnB,GAA6D;AAC/EC,MAAAA,WAAW,EAAEH,OAAO,CAACG,WAD0D;AAE/EC,MAAAA,kBAAkB,EAAEJ,OAAO,CAACI,kBAFmD;AAG/EC,MAAAA,gBAAgB,EAAEL,OAAO,CAACK;AAHqD,KAA7D,GAIhBL,OAJJ;;AAMA,QAAId,YAAY,CAACS,OAAjB,EAA0B;AACxB,UAAIW,qBAAJ;;AAEA,UAAIC,qBAAqB,GAAG7C,SAAS,CAAC,CAAC4C,qBAAqB,GAAGN,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACQ,aAAnF,MAAsG,IAAtG,IAA8GF,qBAAqB,KAAK,KAAK,CAA7I,GAAiJA,qBAAjJ,GAAyKrB,WAA1K,EAAuLT,kBAAvL,EAA2MuB,SAA3M,EAAsNE,aAAtN,CAArC;AACAd,MAAAA,4BAA4B,CAACQ,OAA7B,CAAqCC,GAArC,CAAyCW,qBAAzC;AACAhB,MAAAA,iBAAiB,CAACgB,qBAAD,CAAjB;AACD;AACF,GAdoC,EAclC,CAACtB,WAAD,EAAcT,kBAAd,EAAkCe,iBAAlC,EAAqDL,YAArD,CAdkC,CAArC;AAeA,MAAIuB,wBAAwB,GAAGxC,MAAM,CAAC,KAAD,CAArC;AACAD,EAAAA,SAAS,CAAC,YAAY;AACpB,WAAO,YAAY;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACAyC,MAAAA,wBAAwB,CAACd,OAAzB,GAAmC,IAAnC;AACD,KATD;AAUD,GAXQ,EAWN,EAXM,CAAT;AAYA3B,EAAAA,SAAS,CAAC,YAAY;AACpB,QAAIyC,wBAAwB,CAACd,OAAzB,KAAqC,IAAzC,EAA+C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAc,MAAAA,wBAAwB,CAACd,OAAzB,GAAmC,KAAnC;;AAEA,UAAIL,cAAc,CAAChB,IAAf,KAAwB,oBAA5B,EAAkD;AAChDwB,QAAAA,mBAAmB,CAACR,cAAc,CAACS,SAAhB,EAA2B;AAC5CI,UAAAA,WAAW,EAAEb,cAAc,CAACa,WADgB;AAE5CC,UAAAA,kBAAkB,EAAEd,cAAc,CAACc;AAFS,SAA3B,CAAnB;AAID;;AAED;AACD,KArBmB,CAqBlB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,QAAIM,yBAAyB,GAAGvB,4BAA4B,CAACQ,OAA7D;;AAEA,QAAIT,YAAY,CAACS,OAAjB,EAA0B;AACxB,UAAIgB,SAAS,GAAG,CAAC,GAAGnD,2BAA2B,CAAC,SAAD,CAA/B,EAA4CkD,yBAA5C,CAAhB;AAAA,UACIE,KADJ;;AAGA,UAAI;AACF,aAAKD,SAAS,CAACE,CAAV,EAAL,EAAoB,CAAC,CAACD,KAAK,GAAGD,SAAS,CAACG,CAAV,EAAT,EAAwBC,IAA7C,GAAoD;AAClD,cAAIC,wBAAwB,GAAGJ,KAAK,CAACK,KAArC;;AAEA,cAAID,wBAAwB,KAAK1B,cAAjC,EAAiD;AAC/C;AACD;;AAEDoB,UAAAA,yBAAyB,CAAC,QAAD,CAAzB,CAAoCM,wBAApC;;AAEA,cAAIA,wBAAwB,CAAC1C,IAAzB,KAAkC,oBAAtC,EAA4D;AAC1D,gBAAIC,kBAAkB,CAACC,kBAAD,CAAtB,EAA4C;AAC1CwC,cAAAA,wBAAwB,CAACE,OAAzB,IAAoCF,wBAAwB,CAACE,OAAzB,EAApC;AACD,aAFD,MAEO;AACLF,cAAAA,wBAAwB,CAACG,YAAzB,IAAyCH,wBAAwB,CAACG,YAAzB,EAAzC;AACD;AACF;AACF;AACF,OAlBD,CAkBE,OAAOC,GAAP,EAAY;AACZT,QAAAA,SAAS,CAACU,CAAV,CAAYD,GAAZ;AACD,OApBD,SAoBU;AACRT,QAAAA,SAAS,CAACW,CAAV;AACD;AACF;AACF,GAxEQ,EAwEN,CAAChC,cAAD,EAAiBJ,YAAjB,EAA+BY,mBAA/B,EAAoDtB,kBAApD,CAxEM,CAAT;AAyEAR,EAAAA,SAAS,CAAC,YAAY;AACpB,WAAO,SAASuD,kCAAT,GAA8C;AACnD;AACA;AACA,UAAIC,UAAU,GAAG,CAAC,GAAGhE,2BAA2B,CAAC,SAAD,CAA/B,EAA4C2B,4BAA4B,CAACQ,OAAzE,CAAjB;AAAA,UACI8B,MADJ;;AAGA,UAAI;AACF,aAAKD,UAAU,CAACX,CAAX,EAAL,EAAqB,CAAC,CAACY,MAAM,GAAGD,UAAU,CAACV,CAAX,EAAV,EAA0BC,IAAhD,GAAuD;AACrD,cAAIC,wBAAwB,GAAGS,MAAM,CAACR,KAAtC;;AAEA,cAAID,wBAAwB,CAAC1C,IAAzB,KAAkC,oBAAtC,EAA4D;AAC1D,gBAAIC,kBAAkB,CAACC,kBAAD,CAAtB,EAA4C;AAC1CwC,cAAAA,wBAAwB,CAACE,OAAzB,IAAoCF,wBAAwB,CAACE,OAAzB,EAApC;AACD,aAFD,MAEO;AACLF,cAAAA,wBAAwB,CAACG,YAAzB,IAAyCH,wBAAwB,CAACG,YAAzB,EAAzC;AACD;AACF;AACF;AACF,OAZD,CAYE,OAAOC,GAAP,EAAY;AACZI,QAAAA,UAAU,CAACH,CAAX,CAAaD,GAAb;AACD,OAdD,SAcU;AACRI,QAAAA,UAAU,CAACF,CAAX;AACD;AACF,KAvBD;AAwBD,GAzBQ,EAyBN,CAAC9C,kBAAD,CAzBM,CAAT;AA0BA,SAAO,CAACc,cAAc,CAAChB,IAAf,KAAwB,oBAAxB,GAA+C,IAA/C,GAAsDgB,cAAvD,EAAuEQ,mBAAvE,EAA4FD,YAA5F,CAAP;AACD;;AAED6B,MAAM,CAACC,OAAP,GAAiB7C,cAAjB","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _require = require('./loadQuery'),\n    loadQuery = _require.loadQuery,\n    useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;\n\nvar useIsMountedRef = require('./useIsMountedRef');\n\nvar useRelayEnvironment = require('./useRelayEnvironment');\n\nvar _require2 = require('react'),\n    useCallback = _require2.useCallback,\n    useEffect = _require2.useEffect,\n    useRef = _require2.useRef,\n    useState = _require2.useState;\n\nvar _require3 = require('relay-runtime'),\n    getRequest = _require3.getRequest;\n\nvar initialNullQueryReferenceState = {\n  kind: 'NullQueryReference'\n};\n\nfunction requestIsLiveQuery(preloadableRequest) {\n  if (preloadableRequest.kind === 'PreloadableConcreteRequest') {\n    return preloadableRequest.params.metadata.live !== undefined;\n  }\n\n  var request = getRequest(preloadableRequest);\n  return request.params.metadata.live !== undefined;\n}\n\nfunction useQueryLoader(preloadableRequest, initialQueryReference) {\n  /**\n   * We want to always call `queryReference.dispose()` for every call to\n   * `setQueryReference(loadQuery(...))` so that no leaks of data in Relay stores\n   * will occur.\n   *\n   * However, a call to `setState(newState)` is not always followed by a commit where\n   * this value is reflected in the state. Thus, we cannot reliably clean up each\n   * ref with `useEffect(() => () => queryReference.dispose(), [queryReference])`.\n   *\n   * Instead, we keep track of each call to `loadQuery` in a ref.\n   * Relying on the fact that if a state change commits, no state changes that were\n   * initiated prior to the currently committing state change will ever subsequently\n   * commit, we can safely dispose of all preloaded query references\n   * associated with state changes initiated prior to the currently committing state\n   * change.\n   *\n   * Finally, when the hook unmounts, we also dispose of all remaining uncommitted\n   * query references.\n   */\n  var initialQueryReferenceInternal = initialQueryReference !== null && initialQueryReference !== void 0 ? initialQueryReference : initialNullQueryReferenceState;\n  var environment = useRelayEnvironment();\n  useTrackLoadQueryInRender();\n  var isMountedRef = useIsMountedRef();\n  var undisposedQueryReferencesRef = useRef(new Set([initialQueryReferenceInternal]));\n\n  var _useState = useState(function () {\n    return initialQueryReferenceInternal;\n  }),\n      queryReference = _useState[0],\n      setQueryReference = _useState[1];\n\n  var _useState2 = useState(function () {\n    return initialQueryReferenceInternal;\n  }),\n      previousInitialQueryReference = _useState2[0],\n      setPreviousInitialQueryReference = _useState2[1];\n\n  if (initialQueryReferenceInternal !== previousInitialQueryReference) {\n    // Rendering the query reference makes it \"managed\" by this hook, so\n    // we start keeping track of it so we can dispose it when it is no longer\n    // necessary here\n    // TODO(T78446637): Handle disposal of managed query references in\n    // components that were never mounted after rendering\n    undisposedQueryReferencesRef.current.add(initialQueryReferenceInternal);\n    setPreviousInitialQueryReference(initialQueryReferenceInternal);\n    setQueryReference(initialQueryReferenceInternal);\n  }\n\n  var disposeQuery = useCallback(function () {\n    if (isMountedRef.current) {\n      undisposedQueryReferencesRef.current.add(initialNullQueryReferenceState);\n      setQueryReference(initialNullQueryReferenceState);\n    }\n  }, [isMountedRef]);\n  var queryLoaderCallback = useCallback(function (variables, options) {\n    var mergedOptions = options != null && options.hasOwnProperty('__environment') ? {\n      fetchPolicy: options.fetchPolicy,\n      networkCacheConfig: options.networkCacheConfig,\n      __nameForWarning: options.__nameForWarning\n    } : options;\n\n    if (isMountedRef.current) {\n      var _options$__environmen;\n\n      var updatedQueryReference = loadQuery((_options$__environmen = options === null || options === void 0 ? void 0 : options.__environment) !== null && _options$__environmen !== void 0 ? _options$__environmen : environment, preloadableRequest, variables, mergedOptions);\n      undisposedQueryReferencesRef.current.add(updatedQueryReference);\n      setQueryReference(updatedQueryReference);\n    }\n  }, [environment, preloadableRequest, setQueryReference, isMountedRef]);\n  var maybeHiddenOrFastRefresh = useRef(false);\n  useEffect(function () {\n    return function () {\n      // Attempt to detect if the component was\n      // hidden (by Offscreen API), or fast refresh occured;\n      // Only in these situations would the effect cleanup\n      // for \"unmounting\" run multiple times, so if\n      // we are ever able to read this ref with a value\n      // of true, it means that one of these cases\n      // has happened.\n      maybeHiddenOrFastRefresh.current = true;\n    };\n  }, []);\n  useEffect(function () {\n    if (maybeHiddenOrFastRefresh.current === true) {\n      // This block only runs if the component has previously \"unmounted\"\n      // due to it being hidden by the Offscreen API, or during fast refresh.\n      // At this point, the current queryReference will have been disposed\n      // by the previous cleanup, so instead of attempting to\n      // do our regular commit setup, which would incorrectly leave our\n      // current queryReference disposed, we need to load the query again\n      // and force a re-render by calling queryLoaderCallback again,\n      // so that the queryReference is correctly re-retained, and\n      // potentially refetched if necessary.\n      maybeHiddenOrFastRefresh.current = false;\n\n      if (queryReference.kind !== 'NullQueryReference') {\n        queryLoaderCallback(queryReference.variables, {\n          fetchPolicy: queryReference.fetchPolicy,\n          networkCacheConfig: queryReference.networkCacheConfig\n        });\n      }\n\n      return;\n    } // When a new queryReference is committed, we iterate over all\n    // query references in undisposedQueryReferences and dispose all of\n    // the refs that aren't the currently committed one. This ensures\n    // that we don't leave any dangling query references for the\n    // case that loadQuery is called multiple times before commit; when\n    // this happens, multiple state updates will be scheduled, but only one\n    // will commit, meaning that we need to keep track of and dispose any\n    // query references that don't end up committing.\n    // - We are relying on the fact that sets iterate in insertion order, and we\n    // can remove items from a set as we iterate over it (i.e. no iterator\n    // invalidation issues.) Thus, it is safe to loop through\n    // undisposedQueryReferences until we find queryReference, and\n    // remove and dispose all previous references.\n    // - We are guaranteed to find queryReference in the set, because if a\n    // state update results in a commit, no state updates initiated prior to that\n    // one will be committed, and we are disposing and removing references\n    // associated with updates that were scheduled prior to the currently\n    // committing state change. (A useEffect callback is called during the commit\n    // phase.)\n\n\n    var undisposedQueryReferences = undisposedQueryReferencesRef.current;\n\n    if (isMountedRef.current) {\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(undisposedQueryReferences),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var undisposedQueryReference = _step.value;\n\n          if (undisposedQueryReference === queryReference) {\n            break;\n          }\n\n          undisposedQueryReferences[\"delete\"](undisposedQueryReference);\n\n          if (undisposedQueryReference.kind !== 'NullQueryReference') {\n            if (requestIsLiveQuery(preloadableRequest)) {\n              undisposedQueryReference.dispose && undisposedQueryReference.dispose();\n            } else {\n              undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, [queryReference, isMountedRef, queryLoaderCallback, preloadableRequest]);\n  useEffect(function () {\n    return function disposeAllRemainingQueryReferences() {\n      // undisposedQueryReferences.current is never reassigned\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(undisposedQueryReferencesRef.current),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var undisposedQueryReference = _step2.value;\n\n          if (undisposedQueryReference.kind !== 'NullQueryReference') {\n            if (requestIsLiveQuery(preloadableRequest)) {\n              undisposedQueryReference.dispose && undisposedQueryReference.dispose();\n            } else {\n              undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    };\n  }, [preloadableRequest]);\n  return [queryReference.kind === 'NullQueryReference' ? null : queryReference, queryLoaderCallback, disposeQuery];\n}\n\nmodule.exports = useQueryLoader;"]},"metadata":{},"sourceType":"script"}