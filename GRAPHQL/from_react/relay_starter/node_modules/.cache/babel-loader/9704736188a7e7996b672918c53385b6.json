{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _require = require('../util/RelayConcreteNode'),\n    ACTOR_CHANGE = _require.ACTOR_CHANGE,\n    CLIENT_EDGE = _require.CLIENT_EDGE,\n    CLIENT_EXTENSION = _require.CLIENT_EXTENSION,\n    CONDITION = _require.CONDITION,\n    DEFER = _require.DEFER,\n    FLIGHT_FIELD = _require.FLIGHT_FIELD,\n    FRAGMENT_SPREAD = _require.FRAGMENT_SPREAD,\n    INLINE_DATA_FRAGMENT_SPREAD = _require.INLINE_DATA_FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = _require.INLINE_FRAGMENT,\n    LINKED_FIELD = _require.LINKED_FIELD,\n    MODULE_IMPORT = _require.MODULE_IMPORT,\n    RELAY_RESOLVER = _require.RELAY_RESOLVER,\n    REQUIRED_FIELD = _require.REQUIRED_FIELD,\n    SCALAR_FIELD = _require.SCALAR_FIELD,\n    STREAM = _require.STREAM;\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar ClientID = require('./ClientID');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require2 = require('./RelayStoreReactFlightUtils'),\n    getReactFlightClientResponse = _require2.getReactFlightClientResponse;\n\nvar _require3 = require('./RelayStoreUtils'),\n    CLIENT_EDGE_TRAVERSAL_PATH = _require3.CLIENT_EDGE_TRAVERSAL_PATH,\n    FRAGMENT_OWNER_KEY = _require3.FRAGMENT_OWNER_KEY,\n    FRAGMENT_PROP_NAME_KEY = _require3.FRAGMENT_PROP_NAME_KEY,\n    FRAGMENTS_KEY = _require3.FRAGMENTS_KEY,\n    ID_KEY = _require3.ID_KEY,\n    IS_WITHIN_UNMATCHED_TYPE_REFINEMENT = _require3.IS_WITHIN_UNMATCHED_TYPE_REFINEMENT,\n    MODULE_COMPONENT_KEY = _require3.MODULE_COMPONENT_KEY,\n    ROOT_ID = _require3.ROOT_ID,\n    getArgumentValues = _require3.getArgumentValues,\n    getModuleComponentKey = _require3.getModuleComponentKey,\n    getStorageKey = _require3.getStorageKey;\n\nvar _require4 = require('./ResolverCache'),\n    NoopResolverCache = _require4.NoopResolverCache;\n\nvar _require5 = require('./ResolverFragments'),\n    withResolverContext = _require5.withResolverContext;\n\nvar _require6 = require('./TypeID'),\n    generateTypeID = _require6.generateTypeID;\n\nvar invariant = require('invariant');\n\nfunction read(recordSource, selector, resolverCache) {\n  var reader = new RelayReader(recordSource, selector, resolverCache !== null && resolverCache !== void 0 ? resolverCache : new NoopResolverCache());\n  return reader.read();\n}\n/**\n * @private\n */\n\n\nvar RelayReader = /*#__PURE__*/function () {\n  function RelayReader(recordSource, selector, resolverCache) {\n    var _selector$clientEdgeT;\n\n    this._clientEdgeTraversalPath = RelayFeatureFlags.ENABLE_CLIENT_EDGES && ((_selector$clientEdgeT = selector.clientEdgeTraversalPath) === null || _selector$clientEdgeT === void 0 ? void 0 : _selector$clientEdgeT.length) ? (0, _toConsumableArray2[\"default\"])(selector.clientEdgeTraversalPath) : [];\n    this._missingClientEdges = [];\n    this._isMissingData = false;\n    this._isWithinUnmatchedTypeRefinement = false;\n    this._missingRequiredFields = null;\n    this._owner = selector.owner;\n    this._recordSource = recordSource;\n    this._seenRecords = new Set();\n    this._selector = selector;\n    this._variables = selector.variables;\n    this._resolverCache = resolverCache;\n    this._fragmentName = selector.node.name;\n  }\n\n  var _proto = RelayReader.prototype;\n\n  _proto.read = function read() {\n    var _this$_selector = this._selector,\n        node = _this$_selector.node,\n        dataID = _this$_selector.dataID,\n        isWithinUnmatchedTypeRefinement = _this$_selector.isWithinUnmatchedTypeRefinement;\n    var abstractKey = node.abstractKey;\n\n    var record = this._recordSource.get(dataID); // Relay historically allowed child fragments to be read even if the root object\n    // did not match the type of the fragment: either the root object has a different\n    // concrete type than the fragment (for concrete fragments) or the root object does\n    // not conform to the interface/union for abstract fragments.\n    // For suspense purposes, however, we want to accurately compute whether any data\n    // is missing: but if the fragment type doesn't match (or a parent type didn't\n    // match), then no data is expected to be present.\n    // By default data is expected to be present unless this selector was read out\n    // from within a non-matching type refinement in a parent fragment:\n\n\n    var isDataExpectedToBePresent = !isWithinUnmatchedTypeRefinement; // If this is a concrete fragment and the concrete type of the record does not\n    // match, then no data is expected to be present.\n\n    if (isDataExpectedToBePresent && abstractKey == null && record != null) {\n      var recordType = RelayModernRecord.getType(record);\n\n      if (recordType !== node.type && // The root record type is a special `__Root` type and may not match the\n      // type on the ast, so ignore type mismatches at the root.\n      // We currently detect whether we're at the root by checking against ROOT_ID,\n      // but this does not work for mutations/subscriptions which generate unique\n      // root ids. This is acceptable in practice as we don't read data for mutations/\n      // subscriptions in a situation where we would use isMissingData to decide whether\n      // to suspend or not.\n      // TODO T96653810: Correctly detect reading from root of mutation/subscription\n      dataID !== ROOT_ID) {\n        isDataExpectedToBePresent = false;\n      }\n    } // If this is an abstract fragment (and the precise refinement GK is enabled)\n    // then data is only expected to be present if the record type is known to\n    // implement the interface. If we aren't sure whether the record implements\n    // the interface, that itself constitutes \"expected\" data being missing.\n\n\n    if (isDataExpectedToBePresent && abstractKey != null && record != null) {\n      var _recordType = RelayModernRecord.getType(record);\n\n      var typeID = generateTypeID(_recordType);\n\n      var typeRecord = this._recordSource.get(typeID);\n\n      var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n\n      if (implementsInterface === false) {\n        // Type known to not implement the interface\n        isDataExpectedToBePresent = false;\n      } else if (implementsInterface == null) {\n        // Don't know if the type implements the interface or not\n        this._isMissingData = true;\n      }\n    }\n\n    this._isWithinUnmatchedTypeRefinement = !isDataExpectedToBePresent;\n\n    var data = this._traverse(node, dataID, null);\n\n    return {\n      data: data,\n      isMissingData: this._isMissingData && isDataExpectedToBePresent,\n      missingClientEdges: RelayFeatureFlags.ENABLE_CLIENT_EDGES && this._missingClientEdges.length ? this._missingClientEdges : null,\n      seenRecords: this._seenRecords,\n      selector: this._selector,\n      missingRequiredFields: this._missingRequiredFields\n    };\n  };\n\n  _proto._markDataAsMissing = function _markDataAsMissing() {\n    this._isMissingData = true;\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && this._clientEdgeTraversalPath.length) {\n      var top = this._clientEdgeTraversalPath[this._clientEdgeTraversalPath.length - 1]; // Top can be null if we've traversed past a client edge into an ordinary\n      // client extension field; we never want to fetch in response to missing\n      // data off of a client extension field.\n\n      if (top !== null) {\n        this._missingClientEdges.push({\n          request: top.readerClientEdge.operation,\n          clientEdgeDestinationID: top.clientEdgeDestinationID\n        });\n      }\n    }\n  };\n\n  _proto._traverse = function _traverse(node, dataID, prevData) {\n    var record = this._recordSource.get(dataID);\n\n    this._seenRecords.add(dataID);\n\n    if (record == null) {\n      if (record === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return record;\n    }\n\n    var data = prevData || {};\n\n    var hadRequiredData = this._traverseSelections(node.selections, record, data);\n\n    return hadRequiredData ? data : null;\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n    return this._variables[name];\n  };\n\n  _proto._maybeReportUnexpectedNull = function _maybeReportUnexpectedNull(fieldPath, action, record) {\n    var _this$_missingRequire;\n\n    if (((_this$_missingRequire = this._missingRequiredFields) === null || _this$_missingRequire === void 0 ? void 0 : _this$_missingRequire.action) === 'THROW') {\n      // Chained @required directives may cause a parent `@required(action:\n      // THROW)` field to become null, so the first missing field we\n      // encounter is likely to be the root cause of the error.\n      return;\n    }\n\n    var owner = this._fragmentName;\n\n    switch (action) {\n      case 'THROW':\n        this._missingRequiredFields = {\n          action: action,\n          field: {\n            path: fieldPath,\n            owner: owner\n          }\n        };\n        return;\n\n      case 'LOG':\n        if (this._missingRequiredFields == null) {\n          this._missingRequiredFields = {\n            action: action,\n            fields: [{\n              path: fieldPath,\n              owner: owner\n            }]\n          };\n        } else {\n          this._missingRequiredFields = {\n            action: action,\n            fields: [].concat((0, _toConsumableArray2[\"default\"])(this._missingRequiredFields.fields), [{\n              path: fieldPath,\n              owner: owner\n            }])\n          };\n        }\n\n        return;\n\n      default:\n        action;\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, record, data)\n  /* had all expected data */\n  {\n    for (var i = 0; i < selections.length; i++) {\n      var selection = selections[i];\n\n      switch (selection.kind) {\n        case REQUIRED_FIELD:\n          var fieldValue = this._readRequiredField(selection, record, data);\n\n          if (fieldValue == null) {\n            var action = selection.action;\n\n            if (action !== 'NONE') {\n              this._maybeReportUnexpectedNull(selection.path, action, record);\n            } // We are going to throw, or our parent is going to get nulled out.\n            // Either way, sibling values are going to be ignored, so we can\n            // bail early here as an optimization.\n\n\n            return false;\n          }\n\n          break;\n\n        case SCALAR_FIELD:\n          this._readScalar(selection, record, data);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            this._readPluralLink(selection, record, data);\n          } else {\n            this._readLink(selection, record, data);\n          }\n\n          break;\n\n        case CONDITION:\n          var conditionValue = Boolean(this._getVariableValue(selection.condition));\n\n          if (conditionValue === selection.passingValue) {\n            var hasExpectedData = this._traverseSelections(selection.selections, record, data);\n\n            if (!hasExpectedData) {\n              return false;\n            }\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var abstractKey = selection.abstractKey;\n\n            if (abstractKey == null) {\n              // concrete type refinement: only read data if the type exactly matches\n              var typeName = RelayModernRecord.getType(record);\n\n              if (typeName != null && typeName === selection.type) {\n                var _hasExpectedData = this._traverseSelections(selection.selections, record, data);\n\n                if (!_hasExpectedData) {\n                  return false;\n                }\n              }\n            } else {\n              // Similar to the logic in read(): data is only expected to be present\n              // if the record is known to conform to the interface. If we don't know\n              // whether the type conforms or not, that constitutes missing data.\n              // store flags to reset after reading\n              var parentIsMissingData = this._isMissingData;\n              var parentIsWithinUnmatchedTypeRefinement = this._isWithinUnmatchedTypeRefinement;\n\n              var _typeName = RelayModernRecord.getType(record);\n\n              var typeID = generateTypeID(_typeName);\n\n              var typeRecord = this._recordSource.get(typeID);\n\n              var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement || implementsInterface === false;\n\n              this._traverseSelections(selection.selections, record, data);\n\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement;\n\n              if (implementsInterface === false) {\n                // Type known to not implement the interface, no data expected\n                this._isMissingData = parentIsMissingData;\n              } else if (implementsInterface == null) {\n                // Don't know if the type implements the interface or not\n                this._markDataAsMissing();\n              }\n            }\n\n            break;\n          }\n\n        case RELAY_RESOLVER:\n          {\n            if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n              throw new Error('Relay Resolver fields are not yet supported.');\n            }\n\n            this._readResolverField(selection, record, data);\n\n            break;\n          }\n\n        case FRAGMENT_SPREAD:\n          this._createFragmentPointer(selection, record, data);\n\n          break;\n\n        case MODULE_IMPORT:\n          this._readModuleImport(selection, record, data);\n\n          break;\n\n        case INLINE_DATA_FRAGMENT_SPREAD:\n          this._createInlineDataOrResolverFragmentPointer(selection, record, data);\n\n          break;\n\n        case DEFER:\n        case CLIENT_EXTENSION:\n          {\n            var isMissingData = this._isMissingData;\n            var alreadyMissingClientEdges = this._missingClientEdges.length;\n\n            if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n              this._clientEdgeTraversalPath.push(null);\n            }\n\n            var _hasExpectedData2 = this._traverseSelections(selection.selections, record, data); // The only case where we want to suspend due to missing data off of\n            // a client extension is if we reached a client edge that we might be\n            // able to fetch:\n\n\n            this._isMissingData = isMissingData || this._missingClientEdges.length > alreadyMissingClientEdges;\n\n            if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n              this._clientEdgeTraversalPath.pop();\n            }\n\n            if (!_hasExpectedData2) {\n              return false;\n            }\n\n            break;\n          }\n\n        case STREAM:\n          {\n            var _hasExpectedData3 = this._traverseSelections(selection.selections, record, data);\n\n            if (!_hasExpectedData3) {\n              return false;\n            }\n\n            break;\n          }\n\n        case FLIGHT_FIELD:\n          if (RelayFeatureFlags.ENABLE_REACT_FLIGHT_COMPONENT_FIELD) {\n            this._readFlightField(selection, record, data);\n          } else {\n            throw new Error('Flight fields are not yet supported.');\n          }\n\n          break;\n\n        case ACTOR_CHANGE:\n          this._readActorChange(selection, record, data);\n\n          break;\n\n        case CLIENT_EDGE:\n          if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n            this._readClientEdge(selection, record, data);\n          } else {\n            throw new Error('Client edges are not yet supported.');\n          }\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    }\n\n    return true;\n  };\n\n  _proto._readRequiredField = function _readRequiredField(selection, record, data) {\n    switch (selection.field.kind) {\n      case SCALAR_FIELD:\n        return this._readScalar(selection.field, record, data);\n\n      case LINKED_FIELD:\n        if (selection.field.plural) {\n          return this._readPluralLink(selection.field, record, data);\n        } else {\n          return this._readLink(selection.field, record, data);\n        }\n\n      case RELAY_RESOLVER:\n        if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n          throw new Error('Relay Resolver fields are not yet supported.');\n        }\n\n        return this._readResolverField(selection.field, record, data);\n\n      default:\n        selection.field.kind;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n    }\n  };\n\n  _proto._readResolverField = function _readResolverField(field, record, data) {\n    var _this = this;\n\n    var _field$alias;\n\n    var resolverModule = field.resolverModule,\n        fragment = field.fragment;\n    var storageKey = getStorageKey(field, this._variables);\n    var resolverID = ClientID.generateClientID(RelayModernRecord.getDataID(record), storageKey); // Found when reading the resolver fragment, which can happen either when\n    // evaluating the resolver and it calls readFragment, or when checking if the\n    // inputs have changed since a previous evaluation:\n\n    var fragmentValue;\n    var fragmentReaderSelector;\n    var fragmentMissingRequiredFields;\n    var previousMissingRequriedFields;\n    var fragmentSeenRecordIDs = new Set();\n\n    var getDataForResolverFragment = function getDataForResolverFragment(singularReaderSelector) {\n      if (fragmentValue != null) {\n        // It was already read when checking for input staleness; no need to read it again.\n        // Note that the variables like fragmentSeenRecordIDs in the outer closure will have\n        // already been set and will still be used in this case.\n        return fragmentValue;\n      }\n\n      fragmentReaderSelector = singularReaderSelector;\n      var existingSeenRecords = _this._seenRecords;\n\n      try {\n        var _resolverFragmentData;\n\n        _this._seenRecords = fragmentSeenRecordIDs;\n        var resolverFragmentData = {};\n        previousMissingRequriedFields = _this._missingRequiredFields;\n        _this._missingRequiredFields = null;\n\n        _this._createInlineDataOrResolverFragmentPointer(singularReaderSelector.node, record, resolverFragmentData);\n\n        fragmentMissingRequiredFields = _this._missingRequiredFields;\n        fragmentValue = (_resolverFragmentData = resolverFragmentData[FRAGMENTS_KEY]) === null || _resolverFragmentData === void 0 ? void 0 : _resolverFragmentData[fragment.name];\n        !(typeof fragmentValue === 'object' && fragmentValue !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Expected reader data to contain a __fragments property with a property for the fragment named \".concat(fragment.name, \", but it is missing.\")) : invariant(false) : void 0;\n        return fragmentValue;\n      } finally {\n        _this._seenRecords = existingSeenRecords;\n        _this._missingRequiredFields = previousMissingRequriedFields;\n      }\n    };\n\n    var resolverContext = {\n      getDataForResolverFragment: getDataForResolverFragment\n    };\n\n    var _this$_resolverCache$ = this._resolverCache.readFromCacheOrEvaluate(record, field, this._variables, function () {\n      var key = {\n        __id: RelayModernRecord.getDataID(record),\n        __fragmentOwner: _this._owner,\n        __fragments: (0, _defineProperty2[\"default\"])({}, fragment.name, {})\n      };\n      return withResolverContext(resolverContext, function () {\n        // $FlowFixMe[prop-missing] - resolver module's type signature is a lie\n        var resolverResult = resolverModule(key);\n        return {\n          resolverResult: resolverResult,\n          fragmentValue: fragmentValue,\n          resolverID: resolverID,\n          seenRecordIDs: fragmentSeenRecordIDs,\n          readerSelector: fragmentReaderSelector,\n          missingRequiredFields: fragmentMissingRequiredFields\n        };\n      });\n    }, getDataForResolverFragment),\n        result = _this$_resolverCache$[0],\n        seenRecord = _this$_resolverCache$[1],\n        missingRequiredFields = _this$_resolverCache$[2];\n\n    if (missingRequiredFields != null) {\n      this._addMissingRequiredFields(missingRequiredFields);\n    }\n\n    if (seenRecord != null) {\n      this._seenRecords.add(seenRecord);\n    }\n\n    var applicationName = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    data[applicationName] = result;\n    return result;\n  };\n\n  _proto._readClientEdge = function _readClientEdge(field, record, data) {\n    var _backingField$alias;\n\n    var backingField = field.backingField; // Because ReaderClientExtension doesn't have `alias` or `name` and so I don't know\n    // how to get its applicationName or storageKey yet:\n\n    !(backingField.kind !== 'ClientExtension') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Client extension client edges are not yet implemented.') : invariant(false) : void 0;\n    var applicationName = (_backingField$alias = backingField.alias) !== null && _backingField$alias !== void 0 ? _backingField$alias : backingField.name;\n    var backingFieldData = {};\n\n    this._traverseSelections([backingField], record, backingFieldData);\n\n    var destinationDataID = backingFieldData[applicationName];\n\n    if (destinationDataID == null) {\n      data[applicationName] = destinationDataID;\n      return;\n    }\n\n    !(typeof destinationDataID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Plural client edges not are yet implemented') : invariant(false) : void 0; // FIXME support plural\n    // Not wrapping the push/pop in a try/finally because if we throw, the\n    // Reader object is not usable after that anyway.\n\n    this._clientEdgeTraversalPath.push({\n      readerClientEdge: field,\n      clientEdgeDestinationID: destinationDataID\n    });\n\n    var prevData = data[applicationName];\n    !(prevData == null || typeof prevData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;\n\n    var value = this._traverse(field.linkedField, destinationDataID, // $FlowFixMe[incompatible-variance]\n    prevData);\n\n    data[applicationName] = value;\n\n    this._clientEdgeTraversalPath.pop();\n  };\n\n  _proto._readFlightField = function _readFlightField(field, record, data) {\n    var _field$alias2;\n\n    var applicationName = (_field$alias2 = field.alias) !== null && _field$alias2 !== void 0 ? _field$alias2 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var reactFlightClientResponseRecordID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (reactFlightClientResponseRecordID == null) {\n      data[applicationName] = reactFlightClientResponseRecordID;\n\n      if (reactFlightClientResponseRecordID === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return reactFlightClientResponseRecordID;\n    }\n\n    var reactFlightClientResponseRecord = this._recordSource.get(reactFlightClientResponseRecordID);\n\n    this._seenRecords.add(reactFlightClientResponseRecordID);\n\n    if (reactFlightClientResponseRecord == null) {\n      data[applicationName] = reactFlightClientResponseRecord;\n\n      if (reactFlightClientResponseRecord === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return reactFlightClientResponseRecord;\n    }\n\n    var clientResponse = getReactFlightClientResponse(reactFlightClientResponseRecord);\n    data[applicationName] = clientResponse;\n    return clientResponse;\n  };\n\n  _proto._readScalar = function _readScalar(field, record, data) {\n    var _field$alias3;\n\n    var applicationName = (_field$alias3 = field.alias) !== null && _field$alias3 !== void 0 ? _field$alias3 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var value = RelayModernRecord.getValue(record, storageKey);\n\n    if (value === undefined) {\n      this._markDataAsMissing();\n    }\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readLink = function _readLink(field, record, data) {\n    var _field$alias4;\n\n    var applicationName = (_field$alias4 = field.alias) !== null && _field$alias4 !== void 0 ? _field$alias4 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (linkedID == null) {\n      data[applicationName] = linkedID;\n\n      if (linkedID === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return linkedID;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || typeof prevData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0; // $FlowFixMe[incompatible-variance]\n\n    var value = this._traverse(field, linkedID, prevData);\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readActorChange = function _readActorChange(field, record, data) {\n    var _field$alias5;\n\n    var applicationName = (_field$alias5 = field.alias) !== null && _field$alias5 !== void 0 ? _field$alias5 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var externalRef = RelayModernRecord.getActorLinkedRecordID(record, storageKey);\n\n    if (externalRef == null) {\n      data[applicationName] = externalRef;\n\n      if (externalRef === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return data[applicationName];\n    }\n\n    var actorIdentifier = externalRef[0],\n        dataID = externalRef[1];\n    var fragmentRef = {};\n\n    this._createFragmentPointer(field.fragmentSpread, {\n      __id: dataID\n    }, fragmentRef);\n\n    data[applicationName] = {\n      __fragmentRef: fragmentRef,\n      __viewer: actorIdentifier\n    };\n    return data[applicationName];\n  };\n\n  _proto._readPluralLink = function _readPluralLink(field, record, data) {\n    var _this2 = this;\n\n    var _field$alias6;\n\n    var applicationName = (_field$alias6 = field.alias) !== null && _field$alias6 !== void 0 ? _field$alias6 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);\n\n    if (linkedIDs == null) {\n      data[applicationName] = linkedIDs;\n\n      if (linkedIDs === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return linkedIDs;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || Array.isArray(prevData)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an array, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;\n    var linkedArray = prevData || [];\n    linkedIDs.forEach(function (linkedID, nextIndex) {\n      if (linkedID == null) {\n        if (linkedID === undefined) {\n          _this2._markDataAsMissing();\n        } // $FlowFixMe[cannot-write]\n\n\n        linkedArray[nextIndex] = linkedID;\n        return;\n      }\n\n      var prevItem = linkedArray[nextIndex];\n      !(prevItem == null || typeof prevItem === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevItem) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n      // $FlowFixMe[incompatible-variance]\n\n      linkedArray[nextIndex] = _this2._traverse(field, linkedID, prevItem);\n    });\n    data[applicationName] = linkedArray;\n    return linkedArray;\n  }\n  /**\n   * Reads a ReaderModuleImport, which was generated from using the @module\n   * directive.\n   */\n  ;\n\n  _proto._readModuleImport = function _readModuleImport(moduleImport, record, data) {\n    // Determine the component module from the store: if the field is missing\n    // it means we don't know what component to render the match with.\n    var componentKey = getModuleComponentKey(moduleImport.documentName);\n    var component = RelayModernRecord.getValue(record, componentKey);\n\n    if (component == null) {\n      if (component === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return;\n    } // Otherwise, read the fragment and module associated to the concrete\n    // type, and put that data with the result:\n    // - For the matched fragment, create the relevant fragment pointer and add\n    //   the expected fragmentPropName\n    // - For the matched module, create a reference to the module\n\n\n    this._createFragmentPointer({\n      kind: 'FragmentSpread',\n      name: moduleImport.fragmentName,\n      args: moduleImport.args\n    }, record, data);\n\n    data[FRAGMENT_PROP_NAME_KEY] = moduleImport.fragmentPropName;\n    data[MODULE_COMPONENT_KEY] = component;\n  };\n\n  _proto._createFragmentPointer = function _createFragmentPointer(fragmentSpread, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    } // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[fragmentSpread.name] = fragmentSpread.args ? getArgumentValues(fragmentSpread.args, this._variables) : {};\n    data[FRAGMENT_OWNER_KEY] = this._owner;\n    data[IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] = this._isWithinUnmatchedTypeRefinement;\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n      if (this._clientEdgeTraversalPath.length > 0 && this._clientEdgeTraversalPath[this._clientEdgeTraversalPath.length - 1] !== null) {\n        data[CLIENT_EDGE_TRAVERSAL_PATH] = (0, _toConsumableArray2[\"default\"])(this._clientEdgeTraversalPath);\n      }\n    }\n  };\n\n  _proto._createInlineDataOrResolverFragmentPointer = function _createInlineDataOrResolverFragmentPointer(fragmentSpreadOrFragment, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    }\n\n    var inlineData = {};\n    var parentFragmentName = this._fragmentName;\n    this._fragmentName = fragmentSpreadOrFragment.name;\n\n    this._traverseSelections(fragmentSpreadOrFragment.selections, record, inlineData);\n\n    this._fragmentName = parentFragmentName; // $FlowFixMe[cannot-write] - writing into read-only field\n\n    fragmentPointers[fragmentSpreadOrFragment.name] = inlineData;\n  };\n\n  _proto._addMissingRequiredFields = function _addMissingRequiredFields(additional) {\n    if (this._missingRequiredFields == null) {\n      this._missingRequiredFields = additional;\n      return;\n    }\n\n    if (this._missingRequiredFields.action === 'THROW') {\n      return;\n    }\n\n    if (additional.action === 'THROW') {\n      this._missingRequiredFields = additional;\n      return;\n    }\n\n    this._missingRequiredFields = {\n      action: 'LOG',\n      fields: [].concat((0, _toConsumableArray2[\"default\"])(this._missingRequiredFields.fields), (0, _toConsumableArray2[\"default\"])(additional.fields))\n    };\n  };\n\n  return RelayReader;\n}();\n\nmodule.exports = {\n  read: read\n};","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/store/RelayReader.js"],"names":["_interopRequireDefault","require","_defineProperty2","_toConsumableArray2","_require","ACTOR_CHANGE","CLIENT_EDGE","CLIENT_EXTENSION","CONDITION","DEFER","FLIGHT_FIELD","FRAGMENT_SPREAD","INLINE_DATA_FRAGMENT_SPREAD","INLINE_FRAGMENT","LINKED_FIELD","MODULE_IMPORT","RELAY_RESOLVER","REQUIRED_FIELD","SCALAR_FIELD","STREAM","RelayFeatureFlags","ClientID","RelayModernRecord","_require2","getReactFlightClientResponse","_require3","CLIENT_EDGE_TRAVERSAL_PATH","FRAGMENT_OWNER_KEY","FRAGMENT_PROP_NAME_KEY","FRAGMENTS_KEY","ID_KEY","IS_WITHIN_UNMATCHED_TYPE_REFINEMENT","MODULE_COMPONENT_KEY","ROOT_ID","getArgumentValues","getModuleComponentKey","getStorageKey","_require4","NoopResolverCache","_require5","withResolverContext","_require6","generateTypeID","invariant","read","recordSource","selector","resolverCache","reader","RelayReader","_selector$clientEdgeT","_clientEdgeTraversalPath","ENABLE_CLIENT_EDGES","clientEdgeTraversalPath","length","_missingClientEdges","_isMissingData","_isWithinUnmatchedTypeRefinement","_missingRequiredFields","_owner","owner","_recordSource","_seenRecords","Set","_selector","_variables","variables","_resolverCache","_fragmentName","node","name","_proto","prototype","_this$_selector","dataID","isWithinUnmatchedTypeRefinement","abstractKey","record","get","isDataExpectedToBePresent","recordType","getType","type","_recordType","typeID","typeRecord","implementsInterface","getValue","data","_traverse","isMissingData","missingClientEdges","seenRecords","missingRequiredFields","_markDataAsMissing","top","push","request","readerClientEdge","operation","clientEdgeDestinationID","prevData","add","undefined","hadRequiredData","_traverseSelections","selections","_getVariableValue","hasOwnProperty","process","env","NODE_ENV","_maybeReportUnexpectedNull","fieldPath","action","_this$_missingRequire","field","path","fields","concat","i","selection","kind","fieldValue","_readRequiredField","_readScalar","plural","_readPluralLink","_readLink","conditionValue","Boolean","condition","passingValue","hasExpectedData","typeName","_hasExpectedData","parentIsMissingData","parentIsWithinUnmatchedTypeRefinement","_typeName","ENABLE_RELAY_RESOLVERS","Error","_readResolverField","_createFragmentPointer","_readModuleImport","_createInlineDataOrResolverFragmentPointer","alreadyMissingClientEdges","_hasExpectedData2","pop","_hasExpectedData3","ENABLE_REACT_FLIGHT_COMPONENT_FIELD","_readFlightField","_readActorChange","_readClientEdge","_this","_field$alias","resolverModule","fragment","storageKey","resolverID","generateClientID","getDataID","fragmentValue","fragmentReaderSelector","fragmentMissingRequiredFields","previousMissingRequriedFields","fragmentSeenRecordIDs","getDataForResolverFragment","singularReaderSelector","existingSeenRecords","_resolverFragmentData","resolverFragmentData","resolverContext","_this$_resolverCache$","readFromCacheOrEvaluate","key","__id","__fragmentOwner","__fragments","resolverResult","seenRecordIDs","readerSelector","result","seenRecord","_addMissingRequiredFields","applicationName","alias","_backingField$alias","backingField","backingFieldData","destinationDataID","value","linkedField","_field$alias2","reactFlightClientResponseRecordID","getLinkedRecordID","reactFlightClientResponseRecord","clientResponse","_field$alias3","_field$alias4","linkedID","_field$alias5","externalRef","getActorLinkedRecordID","actorIdentifier","fragmentRef","fragmentSpread","__fragmentRef","__viewer","_this2","_field$alias6","linkedIDs","getLinkedRecordIDs","Array","isArray","linkedArray","forEach","nextIndex","prevItem","moduleImport","componentKey","documentName","component","fragmentName","args","fragmentPropName","fragmentPointers","fragmentSpreadOrFragment","inlineData","parentFragmentName","additional","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _require = require('../util/RelayConcreteNode'),\n    ACTOR_CHANGE = _require.ACTOR_CHANGE,\n    CLIENT_EDGE = _require.CLIENT_EDGE,\n    CLIENT_EXTENSION = _require.CLIENT_EXTENSION,\n    CONDITION = _require.CONDITION,\n    DEFER = _require.DEFER,\n    FLIGHT_FIELD = _require.FLIGHT_FIELD,\n    FRAGMENT_SPREAD = _require.FRAGMENT_SPREAD,\n    INLINE_DATA_FRAGMENT_SPREAD = _require.INLINE_DATA_FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = _require.INLINE_FRAGMENT,\n    LINKED_FIELD = _require.LINKED_FIELD,\n    MODULE_IMPORT = _require.MODULE_IMPORT,\n    RELAY_RESOLVER = _require.RELAY_RESOLVER,\n    REQUIRED_FIELD = _require.REQUIRED_FIELD,\n    SCALAR_FIELD = _require.SCALAR_FIELD,\n    STREAM = _require.STREAM;\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar ClientID = require('./ClientID');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require2 = require('./RelayStoreReactFlightUtils'),\n    getReactFlightClientResponse = _require2.getReactFlightClientResponse;\n\nvar _require3 = require('./RelayStoreUtils'),\n    CLIENT_EDGE_TRAVERSAL_PATH = _require3.CLIENT_EDGE_TRAVERSAL_PATH,\n    FRAGMENT_OWNER_KEY = _require3.FRAGMENT_OWNER_KEY,\n    FRAGMENT_PROP_NAME_KEY = _require3.FRAGMENT_PROP_NAME_KEY,\n    FRAGMENTS_KEY = _require3.FRAGMENTS_KEY,\n    ID_KEY = _require3.ID_KEY,\n    IS_WITHIN_UNMATCHED_TYPE_REFINEMENT = _require3.IS_WITHIN_UNMATCHED_TYPE_REFINEMENT,\n    MODULE_COMPONENT_KEY = _require3.MODULE_COMPONENT_KEY,\n    ROOT_ID = _require3.ROOT_ID,\n    getArgumentValues = _require3.getArgumentValues,\n    getModuleComponentKey = _require3.getModuleComponentKey,\n    getStorageKey = _require3.getStorageKey;\n\nvar _require4 = require('./ResolverCache'),\n    NoopResolverCache = _require4.NoopResolverCache;\n\nvar _require5 = require('./ResolverFragments'),\n    withResolverContext = _require5.withResolverContext;\n\nvar _require6 = require('./TypeID'),\n    generateTypeID = _require6.generateTypeID;\n\nvar invariant = require('invariant');\n\nfunction read(recordSource, selector, resolverCache) {\n  var reader = new RelayReader(recordSource, selector, resolverCache !== null && resolverCache !== void 0 ? resolverCache : new NoopResolverCache());\n  return reader.read();\n}\n/**\n * @private\n */\n\n\nvar RelayReader = /*#__PURE__*/function () {\n  function RelayReader(recordSource, selector, resolverCache) {\n    var _selector$clientEdgeT;\n\n    this._clientEdgeTraversalPath = RelayFeatureFlags.ENABLE_CLIENT_EDGES && ((_selector$clientEdgeT = selector.clientEdgeTraversalPath) === null || _selector$clientEdgeT === void 0 ? void 0 : _selector$clientEdgeT.length) ? (0, _toConsumableArray2[\"default\"])(selector.clientEdgeTraversalPath) : [];\n    this._missingClientEdges = [];\n    this._isMissingData = false;\n    this._isWithinUnmatchedTypeRefinement = false;\n    this._missingRequiredFields = null;\n    this._owner = selector.owner;\n    this._recordSource = recordSource;\n    this._seenRecords = new Set();\n    this._selector = selector;\n    this._variables = selector.variables;\n    this._resolverCache = resolverCache;\n    this._fragmentName = selector.node.name;\n  }\n\n  var _proto = RelayReader.prototype;\n\n  _proto.read = function read() {\n    var _this$_selector = this._selector,\n        node = _this$_selector.node,\n        dataID = _this$_selector.dataID,\n        isWithinUnmatchedTypeRefinement = _this$_selector.isWithinUnmatchedTypeRefinement;\n    var abstractKey = node.abstractKey;\n\n    var record = this._recordSource.get(dataID); // Relay historically allowed child fragments to be read even if the root object\n    // did not match the type of the fragment: either the root object has a different\n    // concrete type than the fragment (for concrete fragments) or the root object does\n    // not conform to the interface/union for abstract fragments.\n    // For suspense purposes, however, we want to accurately compute whether any data\n    // is missing: but if the fragment type doesn't match (or a parent type didn't\n    // match), then no data is expected to be present.\n    // By default data is expected to be present unless this selector was read out\n    // from within a non-matching type refinement in a parent fragment:\n\n\n    var isDataExpectedToBePresent = !isWithinUnmatchedTypeRefinement; // If this is a concrete fragment and the concrete type of the record does not\n    // match, then no data is expected to be present.\n\n    if (isDataExpectedToBePresent && abstractKey == null && record != null) {\n      var recordType = RelayModernRecord.getType(record);\n\n      if (recordType !== node.type && // The root record type is a special `__Root` type and may not match the\n      // type on the ast, so ignore type mismatches at the root.\n      // We currently detect whether we're at the root by checking against ROOT_ID,\n      // but this does not work for mutations/subscriptions which generate unique\n      // root ids. This is acceptable in practice as we don't read data for mutations/\n      // subscriptions in a situation where we would use isMissingData to decide whether\n      // to suspend or not.\n      // TODO T96653810: Correctly detect reading from root of mutation/subscription\n      dataID !== ROOT_ID) {\n        isDataExpectedToBePresent = false;\n      }\n    } // If this is an abstract fragment (and the precise refinement GK is enabled)\n    // then data is only expected to be present if the record type is known to\n    // implement the interface. If we aren't sure whether the record implements\n    // the interface, that itself constitutes \"expected\" data being missing.\n\n\n    if (isDataExpectedToBePresent && abstractKey != null && record != null) {\n      var _recordType = RelayModernRecord.getType(record);\n\n      var typeID = generateTypeID(_recordType);\n\n      var typeRecord = this._recordSource.get(typeID);\n\n      var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n\n      if (implementsInterface === false) {\n        // Type known to not implement the interface\n        isDataExpectedToBePresent = false;\n      } else if (implementsInterface == null) {\n        // Don't know if the type implements the interface or not\n        this._isMissingData = true;\n      }\n    }\n\n    this._isWithinUnmatchedTypeRefinement = !isDataExpectedToBePresent;\n\n    var data = this._traverse(node, dataID, null);\n\n    return {\n      data: data,\n      isMissingData: this._isMissingData && isDataExpectedToBePresent,\n      missingClientEdges: RelayFeatureFlags.ENABLE_CLIENT_EDGES && this._missingClientEdges.length ? this._missingClientEdges : null,\n      seenRecords: this._seenRecords,\n      selector: this._selector,\n      missingRequiredFields: this._missingRequiredFields\n    };\n  };\n\n  _proto._markDataAsMissing = function _markDataAsMissing() {\n    this._isMissingData = true;\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && this._clientEdgeTraversalPath.length) {\n      var top = this._clientEdgeTraversalPath[this._clientEdgeTraversalPath.length - 1]; // Top can be null if we've traversed past a client edge into an ordinary\n      // client extension field; we never want to fetch in response to missing\n      // data off of a client extension field.\n\n      if (top !== null) {\n        this._missingClientEdges.push({\n          request: top.readerClientEdge.operation,\n          clientEdgeDestinationID: top.clientEdgeDestinationID\n        });\n      }\n    }\n  };\n\n  _proto._traverse = function _traverse(node, dataID, prevData) {\n    var record = this._recordSource.get(dataID);\n\n    this._seenRecords.add(dataID);\n\n    if (record == null) {\n      if (record === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return record;\n    }\n\n    var data = prevData || {};\n\n    var hadRequiredData = this._traverseSelections(node.selections, record, data);\n\n    return hadRequiredData ? data : null;\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n    return this._variables[name];\n  };\n\n  _proto._maybeReportUnexpectedNull = function _maybeReportUnexpectedNull(fieldPath, action, record) {\n    var _this$_missingRequire;\n\n    if (((_this$_missingRequire = this._missingRequiredFields) === null || _this$_missingRequire === void 0 ? void 0 : _this$_missingRequire.action) === 'THROW') {\n      // Chained @required directives may cause a parent `@required(action:\n      // THROW)` field to become null, so the first missing field we\n      // encounter is likely to be the root cause of the error.\n      return;\n    }\n\n    var owner = this._fragmentName;\n\n    switch (action) {\n      case 'THROW':\n        this._missingRequiredFields = {\n          action: action,\n          field: {\n            path: fieldPath,\n            owner: owner\n          }\n        };\n        return;\n\n      case 'LOG':\n        if (this._missingRequiredFields == null) {\n          this._missingRequiredFields = {\n            action: action,\n            fields: [{\n              path: fieldPath,\n              owner: owner\n            }]\n          };\n        } else {\n          this._missingRequiredFields = {\n            action: action,\n            fields: [].concat((0, _toConsumableArray2[\"default\"])(this._missingRequiredFields.fields), [{\n              path: fieldPath,\n              owner: owner\n            }])\n          };\n        }\n\n        return;\n\n      default:\n        action;\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, record, data)\n  /* had all expected data */\n  {\n    for (var i = 0; i < selections.length; i++) {\n      var selection = selections[i];\n\n      switch (selection.kind) {\n        case REQUIRED_FIELD:\n          var fieldValue = this._readRequiredField(selection, record, data);\n\n          if (fieldValue == null) {\n            var action = selection.action;\n\n            if (action !== 'NONE') {\n              this._maybeReportUnexpectedNull(selection.path, action, record);\n            } // We are going to throw, or our parent is going to get nulled out.\n            // Either way, sibling values are going to be ignored, so we can\n            // bail early here as an optimization.\n\n\n            return false;\n          }\n\n          break;\n\n        case SCALAR_FIELD:\n          this._readScalar(selection, record, data);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            this._readPluralLink(selection, record, data);\n          } else {\n            this._readLink(selection, record, data);\n          }\n\n          break;\n\n        case CONDITION:\n          var conditionValue = Boolean(this._getVariableValue(selection.condition));\n\n          if (conditionValue === selection.passingValue) {\n            var hasExpectedData = this._traverseSelections(selection.selections, record, data);\n\n            if (!hasExpectedData) {\n              return false;\n            }\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var abstractKey = selection.abstractKey;\n\n            if (abstractKey == null) {\n              // concrete type refinement: only read data if the type exactly matches\n              var typeName = RelayModernRecord.getType(record);\n\n              if (typeName != null && typeName === selection.type) {\n                var _hasExpectedData = this._traverseSelections(selection.selections, record, data);\n\n                if (!_hasExpectedData) {\n                  return false;\n                }\n              }\n            } else {\n              // Similar to the logic in read(): data is only expected to be present\n              // if the record is known to conform to the interface. If we don't know\n              // whether the type conforms or not, that constitutes missing data.\n              // store flags to reset after reading\n              var parentIsMissingData = this._isMissingData;\n              var parentIsWithinUnmatchedTypeRefinement = this._isWithinUnmatchedTypeRefinement;\n\n              var _typeName = RelayModernRecord.getType(record);\n\n              var typeID = generateTypeID(_typeName);\n\n              var typeRecord = this._recordSource.get(typeID);\n\n              var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement || implementsInterface === false;\n\n              this._traverseSelections(selection.selections, record, data);\n\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement;\n\n              if (implementsInterface === false) {\n                // Type known to not implement the interface, no data expected\n                this._isMissingData = parentIsMissingData;\n              } else if (implementsInterface == null) {\n                // Don't know if the type implements the interface or not\n                this._markDataAsMissing();\n              }\n            }\n\n            break;\n          }\n\n        case RELAY_RESOLVER:\n          {\n            if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n              throw new Error('Relay Resolver fields are not yet supported.');\n            }\n\n            this._readResolverField(selection, record, data);\n\n            break;\n          }\n\n        case FRAGMENT_SPREAD:\n          this._createFragmentPointer(selection, record, data);\n\n          break;\n\n        case MODULE_IMPORT:\n          this._readModuleImport(selection, record, data);\n\n          break;\n\n        case INLINE_DATA_FRAGMENT_SPREAD:\n          this._createInlineDataOrResolverFragmentPointer(selection, record, data);\n\n          break;\n\n        case DEFER:\n        case CLIENT_EXTENSION:\n          {\n            var isMissingData = this._isMissingData;\n            var alreadyMissingClientEdges = this._missingClientEdges.length;\n\n            if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n              this._clientEdgeTraversalPath.push(null);\n            }\n\n            var _hasExpectedData2 = this._traverseSelections(selection.selections, record, data); // The only case where we want to suspend due to missing data off of\n            // a client extension is if we reached a client edge that we might be\n            // able to fetch:\n\n\n            this._isMissingData = isMissingData || this._missingClientEdges.length > alreadyMissingClientEdges;\n\n            if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n              this._clientEdgeTraversalPath.pop();\n            }\n\n            if (!_hasExpectedData2) {\n              return false;\n            }\n\n            break;\n          }\n\n        case STREAM:\n          {\n            var _hasExpectedData3 = this._traverseSelections(selection.selections, record, data);\n\n            if (!_hasExpectedData3) {\n              return false;\n            }\n\n            break;\n          }\n\n        case FLIGHT_FIELD:\n          if (RelayFeatureFlags.ENABLE_REACT_FLIGHT_COMPONENT_FIELD) {\n            this._readFlightField(selection, record, data);\n          } else {\n            throw new Error('Flight fields are not yet supported.');\n          }\n\n          break;\n\n        case ACTOR_CHANGE:\n          this._readActorChange(selection, record, data);\n\n          break;\n\n        case CLIENT_EDGE:\n          if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n            this._readClientEdge(selection, record, data);\n          } else {\n            throw new Error('Client edges are not yet supported.');\n          }\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    }\n\n    return true;\n  };\n\n  _proto._readRequiredField = function _readRequiredField(selection, record, data) {\n    switch (selection.field.kind) {\n      case SCALAR_FIELD:\n        return this._readScalar(selection.field, record, data);\n\n      case LINKED_FIELD:\n        if (selection.field.plural) {\n          return this._readPluralLink(selection.field, record, data);\n        } else {\n          return this._readLink(selection.field, record, data);\n        }\n\n      case RELAY_RESOLVER:\n        if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n          throw new Error('Relay Resolver fields are not yet supported.');\n        }\n\n        return this._readResolverField(selection.field, record, data);\n\n      default:\n        selection.field.kind;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n    }\n  };\n\n  _proto._readResolverField = function _readResolverField(field, record, data) {\n    var _this = this;\n\n    var _field$alias;\n\n    var resolverModule = field.resolverModule,\n        fragment = field.fragment;\n    var storageKey = getStorageKey(field, this._variables);\n    var resolverID = ClientID.generateClientID(RelayModernRecord.getDataID(record), storageKey); // Found when reading the resolver fragment, which can happen either when\n    // evaluating the resolver and it calls readFragment, or when checking if the\n    // inputs have changed since a previous evaluation:\n\n    var fragmentValue;\n    var fragmentReaderSelector;\n    var fragmentMissingRequiredFields;\n    var previousMissingRequriedFields;\n    var fragmentSeenRecordIDs = new Set();\n\n    var getDataForResolverFragment = function getDataForResolverFragment(singularReaderSelector) {\n      if (fragmentValue != null) {\n        // It was already read when checking for input staleness; no need to read it again.\n        // Note that the variables like fragmentSeenRecordIDs in the outer closure will have\n        // already been set and will still be used in this case.\n        return fragmentValue;\n      }\n\n      fragmentReaderSelector = singularReaderSelector;\n      var existingSeenRecords = _this._seenRecords;\n\n      try {\n        var _resolverFragmentData;\n\n        _this._seenRecords = fragmentSeenRecordIDs;\n        var resolverFragmentData = {};\n        previousMissingRequriedFields = _this._missingRequiredFields;\n        _this._missingRequiredFields = null;\n\n        _this._createInlineDataOrResolverFragmentPointer(singularReaderSelector.node, record, resolverFragmentData);\n\n        fragmentMissingRequiredFields = _this._missingRequiredFields;\n        fragmentValue = (_resolverFragmentData = resolverFragmentData[FRAGMENTS_KEY]) === null || _resolverFragmentData === void 0 ? void 0 : _resolverFragmentData[fragment.name];\n        !(typeof fragmentValue === 'object' && fragmentValue !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Expected reader data to contain a __fragments property with a property for the fragment named \".concat(fragment.name, \", but it is missing.\")) : invariant(false) : void 0;\n        return fragmentValue;\n      } finally {\n        _this._seenRecords = existingSeenRecords;\n        _this._missingRequiredFields = previousMissingRequriedFields;\n      }\n    };\n\n    var resolverContext = {\n      getDataForResolverFragment: getDataForResolverFragment\n    };\n\n    var _this$_resolverCache$ = this._resolverCache.readFromCacheOrEvaluate(record, field, this._variables, function () {\n      var key = {\n        __id: RelayModernRecord.getDataID(record),\n        __fragmentOwner: _this._owner,\n        __fragments: (0, _defineProperty2[\"default\"])({}, fragment.name, {})\n      };\n      return withResolverContext(resolverContext, function () {\n        // $FlowFixMe[prop-missing] - resolver module's type signature is a lie\n        var resolverResult = resolverModule(key);\n        return {\n          resolverResult: resolverResult,\n          fragmentValue: fragmentValue,\n          resolverID: resolverID,\n          seenRecordIDs: fragmentSeenRecordIDs,\n          readerSelector: fragmentReaderSelector,\n          missingRequiredFields: fragmentMissingRequiredFields\n        };\n      });\n    }, getDataForResolverFragment),\n        result = _this$_resolverCache$[0],\n        seenRecord = _this$_resolverCache$[1],\n        missingRequiredFields = _this$_resolverCache$[2];\n\n    if (missingRequiredFields != null) {\n      this._addMissingRequiredFields(missingRequiredFields);\n    }\n\n    if (seenRecord != null) {\n      this._seenRecords.add(seenRecord);\n    }\n\n    var applicationName = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    data[applicationName] = result;\n    return result;\n  };\n\n  _proto._readClientEdge = function _readClientEdge(field, record, data) {\n    var _backingField$alias;\n\n    var backingField = field.backingField; // Because ReaderClientExtension doesn't have `alias` or `name` and so I don't know\n    // how to get its applicationName or storageKey yet:\n\n    !(backingField.kind !== 'ClientExtension') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Client extension client edges are not yet implemented.') : invariant(false) : void 0;\n    var applicationName = (_backingField$alias = backingField.alias) !== null && _backingField$alias !== void 0 ? _backingField$alias : backingField.name;\n    var backingFieldData = {};\n\n    this._traverseSelections([backingField], record, backingFieldData);\n\n    var destinationDataID = backingFieldData[applicationName];\n\n    if (destinationDataID == null) {\n      data[applicationName] = destinationDataID;\n      return;\n    }\n\n    !(typeof destinationDataID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Plural client edges not are yet implemented') : invariant(false) : void 0; // FIXME support plural\n    // Not wrapping the push/pop in a try/finally because if we throw, the\n    // Reader object is not usable after that anyway.\n\n    this._clientEdgeTraversalPath.push({\n      readerClientEdge: field,\n      clientEdgeDestinationID: destinationDataID\n    });\n\n    var prevData = data[applicationName];\n    !(prevData == null || typeof prevData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;\n\n    var value = this._traverse(field.linkedField, destinationDataID, // $FlowFixMe[incompatible-variance]\n    prevData);\n\n    data[applicationName] = value;\n\n    this._clientEdgeTraversalPath.pop();\n  };\n\n  _proto._readFlightField = function _readFlightField(field, record, data) {\n    var _field$alias2;\n\n    var applicationName = (_field$alias2 = field.alias) !== null && _field$alias2 !== void 0 ? _field$alias2 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var reactFlightClientResponseRecordID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (reactFlightClientResponseRecordID == null) {\n      data[applicationName] = reactFlightClientResponseRecordID;\n\n      if (reactFlightClientResponseRecordID === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return reactFlightClientResponseRecordID;\n    }\n\n    var reactFlightClientResponseRecord = this._recordSource.get(reactFlightClientResponseRecordID);\n\n    this._seenRecords.add(reactFlightClientResponseRecordID);\n\n    if (reactFlightClientResponseRecord == null) {\n      data[applicationName] = reactFlightClientResponseRecord;\n\n      if (reactFlightClientResponseRecord === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return reactFlightClientResponseRecord;\n    }\n\n    var clientResponse = getReactFlightClientResponse(reactFlightClientResponseRecord);\n    data[applicationName] = clientResponse;\n    return clientResponse;\n  };\n\n  _proto._readScalar = function _readScalar(field, record, data) {\n    var _field$alias3;\n\n    var applicationName = (_field$alias3 = field.alias) !== null && _field$alias3 !== void 0 ? _field$alias3 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var value = RelayModernRecord.getValue(record, storageKey);\n\n    if (value === undefined) {\n      this._markDataAsMissing();\n    }\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readLink = function _readLink(field, record, data) {\n    var _field$alias4;\n\n    var applicationName = (_field$alias4 = field.alias) !== null && _field$alias4 !== void 0 ? _field$alias4 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (linkedID == null) {\n      data[applicationName] = linkedID;\n\n      if (linkedID === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return linkedID;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || typeof prevData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0; // $FlowFixMe[incompatible-variance]\n\n    var value = this._traverse(field, linkedID, prevData);\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readActorChange = function _readActorChange(field, record, data) {\n    var _field$alias5;\n\n    var applicationName = (_field$alias5 = field.alias) !== null && _field$alias5 !== void 0 ? _field$alias5 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var externalRef = RelayModernRecord.getActorLinkedRecordID(record, storageKey);\n\n    if (externalRef == null) {\n      data[applicationName] = externalRef;\n\n      if (externalRef === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return data[applicationName];\n    }\n\n    var actorIdentifier = externalRef[0],\n        dataID = externalRef[1];\n    var fragmentRef = {};\n\n    this._createFragmentPointer(field.fragmentSpread, {\n      __id: dataID\n    }, fragmentRef);\n\n    data[applicationName] = {\n      __fragmentRef: fragmentRef,\n      __viewer: actorIdentifier\n    };\n    return data[applicationName];\n  };\n\n  _proto._readPluralLink = function _readPluralLink(field, record, data) {\n    var _this2 = this;\n\n    var _field$alias6;\n\n    var applicationName = (_field$alias6 = field.alias) !== null && _field$alias6 !== void 0 ? _field$alias6 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);\n\n    if (linkedIDs == null) {\n      data[applicationName] = linkedIDs;\n\n      if (linkedIDs === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return linkedIDs;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || Array.isArray(prevData)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an array, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;\n    var linkedArray = prevData || [];\n    linkedIDs.forEach(function (linkedID, nextIndex) {\n      if (linkedID == null) {\n        if (linkedID === undefined) {\n          _this2._markDataAsMissing();\n        } // $FlowFixMe[cannot-write]\n\n\n        linkedArray[nextIndex] = linkedID;\n        return;\n      }\n\n      var prevItem = linkedArray[nextIndex];\n      !(prevItem == null || typeof prevItem === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevItem) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n      // $FlowFixMe[incompatible-variance]\n\n      linkedArray[nextIndex] = _this2._traverse(field, linkedID, prevItem);\n    });\n    data[applicationName] = linkedArray;\n    return linkedArray;\n  }\n  /**\n   * Reads a ReaderModuleImport, which was generated from using the @module\n   * directive.\n   */\n  ;\n\n  _proto._readModuleImport = function _readModuleImport(moduleImport, record, data) {\n    // Determine the component module from the store: if the field is missing\n    // it means we don't know what component to render the match with.\n    var componentKey = getModuleComponentKey(moduleImport.documentName);\n    var component = RelayModernRecord.getValue(record, componentKey);\n\n    if (component == null) {\n      if (component === undefined) {\n        this._markDataAsMissing();\n      }\n\n      return;\n    } // Otherwise, read the fragment and module associated to the concrete\n    // type, and put that data with the result:\n    // - For the matched fragment, create the relevant fragment pointer and add\n    //   the expected fragmentPropName\n    // - For the matched module, create a reference to the module\n\n\n    this._createFragmentPointer({\n      kind: 'FragmentSpread',\n      name: moduleImport.fragmentName,\n      args: moduleImport.args\n    }, record, data);\n\n    data[FRAGMENT_PROP_NAME_KEY] = moduleImport.fragmentPropName;\n    data[MODULE_COMPONENT_KEY] = component;\n  };\n\n  _proto._createFragmentPointer = function _createFragmentPointer(fragmentSpread, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    } // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[fragmentSpread.name] = fragmentSpread.args ? getArgumentValues(fragmentSpread.args, this._variables) : {};\n    data[FRAGMENT_OWNER_KEY] = this._owner;\n    data[IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] = this._isWithinUnmatchedTypeRefinement;\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n      if (this._clientEdgeTraversalPath.length > 0 && this._clientEdgeTraversalPath[this._clientEdgeTraversalPath.length - 1] !== null) {\n        data[CLIENT_EDGE_TRAVERSAL_PATH] = (0, _toConsumableArray2[\"default\"])(this._clientEdgeTraversalPath);\n      }\n    }\n  };\n\n  _proto._createInlineDataOrResolverFragmentPointer = function _createInlineDataOrResolverFragmentPointer(fragmentSpreadOrFragment, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    }\n\n    var inlineData = {};\n    var parentFragmentName = this._fragmentName;\n    this._fragmentName = fragmentSpreadOrFragment.name;\n\n    this._traverseSelections(fragmentSpreadOrFragment.selections, record, inlineData);\n\n    this._fragmentName = parentFragmentName; // $FlowFixMe[cannot-write] - writing into read-only field\n\n    fragmentPointers[fragmentSpreadOrFragment.name] = inlineData;\n  };\n\n  _proto._addMissingRequiredFields = function _addMissingRequiredFields(additional) {\n    if (this._missingRequiredFields == null) {\n      this._missingRequiredFields = additional;\n      return;\n    }\n\n    if (this._missingRequiredFields.action === 'THROW') {\n      return;\n    }\n\n    if (additional.action === 'THROW') {\n      this._missingRequiredFields = additional;\n      return;\n    }\n\n    this._missingRequiredFields = {\n      action: 'LOG',\n      fields: [].concat((0, _toConsumableArray2[\"default\"])(this._missingRequiredFields.fields), (0, _toConsumableArray2[\"default\"])(additional.fields))\n    };\n  };\n\n  return RelayReader;\n}();\n\nmodule.exports = {\n  read: read\n};"]},"metadata":{},"sourceType":"script"}