{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar RelayRecordSourceMutator = require('../mutations/RelayRecordSourceMutator');\n\nvar RelayRecordSourceProxy = require('../mutations/RelayRecordSourceProxy');\n\nvar getOperation = require('../util/getOperation');\n\nvar RelayConcreteNode = require('../util/RelayConcreteNode');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar _require = require('./ClientID'),\n    isClientID = _require.isClientID;\n\nvar cloneRelayHandleSourceField = require('./cloneRelayHandleSourceField');\n\nvar cloneRelayScalarHandleSourceField = require('./cloneRelayScalarHandleSourceField');\n\nvar _require2 = require('./RelayConcreteVariables'),\n    getLocalVariables = _require2.getLocalVariables;\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require3 = require('./RelayRecordState'),\n    EXISTENT = _require3.EXISTENT,\n    UNKNOWN = _require3.UNKNOWN;\n\nvar RelayStoreReactFlightUtils = require('./RelayStoreReactFlightUtils');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar _require4 = require('./TypeID'),\n    generateTypeID = _require4.generateTypeID;\n\nvar invariant = require('invariant');\n\nvar ACTOR_CHANGE = RelayConcreteNode.ACTOR_CHANGE,\n    CONDITION = RelayConcreteNode.CONDITION,\n    CLIENT_COMPONENT = RelayConcreteNode.CLIENT_COMPONENT,\n    CLIENT_EXTENSION = RelayConcreteNode.CLIENT_EXTENSION,\n    DEFER = RelayConcreteNode.DEFER,\n    FLIGHT_FIELD = RelayConcreteNode.FLIGHT_FIELD,\n    FRAGMENT_SPREAD = RelayConcreteNode.FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = RelayConcreteNode.INLINE_FRAGMENT,\n    LINKED_FIELD = RelayConcreteNode.LINKED_FIELD,\n    LINKED_HANDLE = RelayConcreteNode.LINKED_HANDLE,\n    MODULE_IMPORT = RelayConcreteNode.MODULE_IMPORT,\n    SCALAR_FIELD = RelayConcreteNode.SCALAR_FIELD,\n    SCALAR_HANDLE = RelayConcreteNode.SCALAR_HANDLE,\n    STREAM = RelayConcreteNode.STREAM,\n    TYPE_DISCRIMINATOR = RelayConcreteNode.TYPE_DISCRIMINATOR;\nvar ROOT_ID = RelayStoreUtils.ROOT_ID,\n    getModuleOperationKey = RelayStoreUtils.getModuleOperationKey,\n    getStorageKey = RelayStoreUtils.getStorageKey,\n    getArgumentValues = RelayStoreUtils.getArgumentValues;\n/**\n * Synchronously check whether the records required to fulfill the given\n * `selector` are present in `source`.\n *\n * If a field is missing, it uses the provided handlers to attempt to substitute\n * data. The `target` will store all records that are modified because of a\n * successful substitution.\n *\n * If all records are present, returns `true`, otherwise `false`.\n */\n\nfunction check(getSourceForActor, getTargetForActor, defaultActorIdentifier, selector, handlers, operationLoader, getDataID, shouldProcessClientComponents) {\n  var dataID = selector.dataID,\n      node = selector.node,\n      variables = selector.variables;\n  var checker = new DataChecker(getSourceForActor, getTargetForActor, defaultActorIdentifier, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents);\n  return checker.check(node, dataID);\n}\n/**\n * @private\n */\n\n\nvar DataChecker = /*#__PURE__*/function () {\n  function DataChecker(getSourceForActor, getTargetForActor, defaultActorIdentifier, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents) {\n    this._getSourceForActor = getSourceForActor;\n    this._getTargetForActor = getTargetForActor;\n    this._getDataID = getDataID;\n    this._source = getSourceForActor(defaultActorIdentifier);\n    this._mutatorRecordSourceProxyCache = new Map();\n\n    var _this$_getMutatorAndR = this._getMutatorAndRecordProxyForActor(defaultActorIdentifier),\n        mutator = _this$_getMutatorAndR[0],\n        recordSourceProxy = _this$_getMutatorAndR[1];\n\n    this._mostRecentlyInvalidatedAt = null;\n    this._handlers = handlers;\n    this._mutator = mutator;\n    this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;\n    this._recordSourceProxy = recordSourceProxy;\n    this._recordWasMissing = false;\n    this._variables = variables;\n    this._shouldProcessClientComponents = shouldProcessClientComponents;\n  }\n\n  var _proto = DataChecker.prototype;\n\n  _proto._getMutatorAndRecordProxyForActor = function _getMutatorAndRecordProxyForActor(actorIdentifier) {\n    var tuple = this._mutatorRecordSourceProxyCache.get(actorIdentifier);\n\n    if (tuple == null) {\n      var target = this._getTargetForActor(actorIdentifier);\n\n      var mutator = new RelayRecordSourceMutator(this._getSourceForActor(actorIdentifier), target);\n      var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID);\n      tuple = [mutator, recordSourceProxy];\n\n      this._mutatorRecordSourceProxyCache.set(actorIdentifier, tuple);\n    }\n\n    return tuple;\n  };\n\n  _proto.check = function check(node, dataID) {\n    this._traverse(node, dataID);\n\n    return this._recordWasMissing === true ? {\n      status: 'missing',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    } : {\n      status: 'available',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    };\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n    return this._variables[name];\n  };\n\n  _proto._handleMissing = function _handleMissing() {\n    this._recordWasMissing = true;\n  };\n\n  _proto._getDataForHandlers = function _getDataForHandlers(field, dataID) {\n    return {\n      /* $FlowFixMe[class-object-subtyping] added when improving typing for\n       * this parameters */\n      args: field.args ? getArgumentValues(field.args, this._variables) : {},\n      // Getting a snapshot of the record state is potentially expensive since\n      // we will need to merge the sink and source records. Since we do not create\n      // any new records in this process, it is probably reasonable to provide\n      // handlers with a copy of the source record.\n      // The only thing that the provided record will not contain is fields\n      // added by previous handlers.\n      record: this._source.get(dataID)\n    };\n  };\n\n  _proto._handleMissingScalarField = function _handleMissingScalarField(field, dataID) {\n    if (field.name === 'id' && field.alias == null && isClientID(dataID)) {\n      return undefined;\n    }\n\n    var _this$_getDataForHand = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand.args,\n        record = _this$_getDataForHand.record;\n\n    var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var handler = _step.value;\n\n        if (handler.kind === 'scalar') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingLinkField = function _handleMissingLinkField(field, dataID) {\n    var _this$_getDataForHand2 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand2.args,\n        record = _this$_getDataForHand2.record;\n\n    var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var handler = _step2.value;\n\n        if (handler.kind === 'linked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined && (newValue === null || this._mutator.getStatus(newValue) === EXISTENT)) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingPluralLinkField = function _handleMissingPluralLinkField(field, dataID) {\n    var _this = this;\n\n    var _this$_getDataForHand3 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand3.args,\n        record = _this$_getDataForHand3.record;\n\n    var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var handler = _step3.value;\n\n        if (handler.kind === 'pluralLinked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue != null) {\n            var allItemsKnown = newValue.every(function (linkedID) {\n              return linkedID != null && _this._mutator.getStatus(linkedID) === EXISTENT;\n            });\n\n            if (allItemsKnown) {\n              return newValue;\n            }\n          } else if (newValue === null) {\n            return null;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._traverse = function _traverse(node, dataID) {\n    var status = this._mutator.getStatus(dataID);\n\n    if (status === UNKNOWN) {\n      this._handleMissing();\n    }\n\n    if (status === EXISTENT) {\n      var record = this._source.get(dataID);\n\n      var invalidatedAt = RelayModernRecord.getInvalidationEpoch(record);\n\n      if (invalidatedAt != null) {\n        this._mostRecentlyInvalidatedAt = this._mostRecentlyInvalidatedAt != null ? Math.max(this._mostRecentlyInvalidatedAt, invalidatedAt) : invalidatedAt;\n      }\n\n      this._traverseSelections(node.selections, dataID);\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, dataID) {\n    var _this2 = this;\n\n    selections.forEach(function (selection) {\n      switch (selection.kind) {\n        case SCALAR_FIELD:\n          _this2._checkScalar(selection, dataID);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            _this2._checkPluralLink(selection, dataID);\n          } else {\n            _this2._checkLink(selection, dataID);\n          }\n\n          break;\n\n        case ACTOR_CHANGE:\n          _this2._checkActorChange(selection.linkedField, dataID);\n\n          break;\n\n        case CONDITION:\n          var conditionValue = Boolean(_this2._getVariableValue(selection.condition));\n\n          if (conditionValue === selection.passingValue) {\n            _this2._traverseSelections(selection.selections, dataID);\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var _abstractKey = selection.abstractKey;\n\n            if (_abstractKey == null) {\n              // concrete type refinement: only check data if the type exactly matches\n              var typeName = _this2._mutator.getType(dataID);\n\n              if (typeName === selection.type) {\n                _this2._traverseSelections(selection.selections, dataID);\n              }\n            } else {\n              // Abstract refinement: check data depending on whether the type\n              // conforms to the interface/union or not:\n              // - Type known to _not_ implement the interface: don't check the selections.\n              // - Type is known _to_ implement the interface: check selections.\n              // - Unknown whether the type implements the interface: don't check the selections\n              //   and treat the data as missing; we do this because the Relay Compiler\n              //   guarantees that the type discriminator will always be fetched.\n              var _recordType = _this2._mutator.getType(dataID);\n\n              !(_recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n\n              var _typeID = generateTypeID(_recordType);\n\n              var _implementsInterface = _this2._mutator.getValue(_typeID, _abstractKey);\n\n              if (_implementsInterface === true) {\n                _this2._traverseSelections(selection.selections, dataID);\n              } else if (_implementsInterface == null) {\n                // unsure if the type implements the interface: data is\n                // missing so don't bother reading the fragment\n                _this2._handleMissing();\n              } // else false: known to not implement the interface\n\n            }\n\n            break;\n          }\n\n        case LINKED_HANDLE:\n          {\n            // Handles have no selections themselves; traverse the original field\n            // where the handle was set-up instead.\n            var handleField = cloneRelayHandleSourceField(selection, selections, _this2._variables);\n\n            if (handleField.plural) {\n              _this2._checkPluralLink(handleField, dataID);\n            } else {\n              _this2._checkLink(handleField, dataID);\n            }\n\n            break;\n          }\n\n        case SCALAR_HANDLE:\n          {\n            var _handleField = cloneRelayScalarHandleSourceField(selection, selections, _this2._variables);\n\n            _this2._checkScalar(_handleField, dataID);\n\n            break;\n          }\n\n        case MODULE_IMPORT:\n          _this2._checkModuleImport(selection, dataID);\n\n          break;\n\n        case DEFER:\n        case STREAM:\n          _this2._traverseSelections(selection.selections, dataID);\n\n          break;\n\n        case FRAGMENT_SPREAD:\n          var prevVariables = _this2._variables;\n          _this2._variables = getLocalVariables(_this2._variables, selection.fragment.argumentDefinitions, selection.args);\n\n          _this2._traverseSelections(selection.fragment.selections, dataID);\n\n          _this2._variables = prevVariables;\n          break;\n\n        case CLIENT_EXTENSION:\n          var recordWasMissing = _this2._recordWasMissing;\n\n          _this2._traverseSelections(selection.selections, dataID);\n\n          _this2._recordWasMissing = recordWasMissing;\n          break;\n\n        case TYPE_DISCRIMINATOR:\n          var abstractKey = selection.abstractKey;\n\n          var recordType = _this2._mutator.getType(dataID);\n\n          !(recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n          var typeID = generateTypeID(recordType);\n\n          var implementsInterface = _this2._mutator.getValue(typeID, abstractKey);\n\n          if (implementsInterface == null) {\n            // unsure if the type implements the interface: data is\n            // missing\n            _this2._handleMissing();\n          } // else: if it does or doesn't implement, we don't need to check or skip anything else\n\n\n          break;\n\n        case FLIGHT_FIELD:\n          if (RelayFeatureFlags.ENABLE_REACT_FLIGHT_COMPONENT_FIELD) {\n            _this2._checkFlightField(selection, dataID);\n          } else {\n            throw new Error('Flight fields are not yet supported.');\n          }\n\n          break;\n\n        case CLIENT_COMPONENT:\n          if (_this2._shouldProcessClientComponents === false) {\n            break;\n          }\n\n          _this2._traverseSelections(selection.fragment.selections, dataID);\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    });\n  };\n\n  _proto._checkModuleImport = function _checkModuleImport(moduleImport, dataID) {\n    var operationLoader = this._operationLoader;\n    !(operationLoader !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using `@module`.') : invariant(false) : void 0;\n    var operationKey = getModuleOperationKey(moduleImport.documentName);\n\n    var operationReference = this._mutator.getValue(dataID, operationKey);\n\n    if (operationReference == null) {\n      if (operationReference === undefined) {\n        this._handleMissing();\n      }\n\n      return;\n    }\n\n    var normalizationRootNode = operationLoader.get(operationReference);\n\n    if (normalizationRootNode != null) {\n      var operation = getOperation(normalizationRootNode);\n      var prevVariables = this._variables;\n      this._variables = getLocalVariables(this._variables, operation.argumentDefinitions, moduleImport.args);\n\n      this._traverse(operation, dataID);\n\n      this._variables = prevVariables;\n    } else {\n      // If the fragment is not available, we assume that the data cannot have been\n      // processed yet and must therefore be missing.\n      this._handleMissing();\n    }\n  };\n\n  _proto._checkScalar = function _checkScalar(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var fieldValue = this._mutator.getValue(dataID, storageKey);\n\n    if (fieldValue === undefined) {\n      fieldValue = this._handleMissingScalarField(field, dataID);\n\n      if (fieldValue !== undefined) {\n        this._mutator.setValue(dataID, storageKey, fieldValue);\n      }\n    }\n  };\n\n  _proto._checkLink = function _checkLink(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);\n\n    if (linkedID === undefined) {\n      linkedID = this._handleMissingLinkField(field, dataID);\n\n      if (linkedID != null) {\n        this._mutator.setLinkedRecordID(dataID, storageKey, linkedID);\n      } else if (linkedID === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedID != null) {\n      this._traverse(field, linkedID);\n    }\n  };\n\n  _proto._checkPluralLink = function _checkPluralLink(field, dataID) {\n    var _this3 = this;\n\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedIDs = this._mutator.getLinkedRecordIDs(dataID, storageKey);\n\n    if (linkedIDs === undefined) {\n      linkedIDs = this._handleMissingPluralLinkField(field, dataID);\n\n      if (linkedIDs != null) {\n        this._mutator.setLinkedRecordIDs(dataID, storageKey, linkedIDs);\n      } else if (linkedIDs === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedIDs) {\n      linkedIDs.forEach(function (linkedID) {\n        if (linkedID != null) {\n          _this3._traverse(field, linkedID);\n        }\n      });\n    }\n  };\n\n  _proto._checkActorChange = function _checkActorChange(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var record = this._source.get(dataID);\n\n    var tuple = record != null ? RelayModernRecord.getActorLinkedRecordID(record, storageKey) : record;\n\n    if (tuple == null) {\n      if (tuple === undefined) {\n        this._handleMissing();\n      }\n    } else {\n      var _actorIdentifier = tuple[0],\n          linkedID = tuple[1];\n      var prevSource = this._source;\n      var prevMutator = this._mutator;\n      var prevRecordSourceProxy = this._recordSourceProxy;\n\n      var _this$_getMutatorAndR2 = this._getMutatorAndRecordProxyForActor(_actorIdentifier),\n          mutator = _this$_getMutatorAndR2[0],\n          recordSourceProxy = _this$_getMutatorAndR2[1];\n\n      this._source = this._getSourceForActor(_actorIdentifier);\n      this._mutator = mutator;\n      this._recordSourceProxy = recordSourceProxy;\n\n      this._traverse(field, linkedID);\n\n      this._source = prevSource;\n      this._mutator = prevMutator;\n      this._recordSourceProxy = prevRecordSourceProxy;\n    }\n  };\n\n  _proto._checkFlightField = function _checkFlightField(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);\n\n    if (linkedID == null) {\n      if (linkedID === undefined) {\n        this._handleMissing();\n\n        return;\n      }\n\n      return;\n    }\n\n    var tree = this._mutator.getValue(linkedID, RelayStoreReactFlightUtils.REACT_FLIGHT_TREE_STORAGE_KEY);\n\n    var reachableExecutableDefinitions = this._mutator.getValue(linkedID, RelayStoreReactFlightUtils.REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY);\n\n    if (tree == null || !Array.isArray(reachableExecutableDefinitions)) {\n      this._handleMissing();\n\n      return;\n    }\n\n    var operationLoader = this._operationLoader;\n    !(operationLoader !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using ' + 'React Flight.') : invariant(false) : void 0; // In Flight, the variables that are in scope for reachable executable\n    // definitions aren't the same as what's in scope for the outer query.\n\n    var prevVariables = this._variables; // $FlowFixMe[incompatible-cast]\n\n    var _iterator4 = (0, _createForOfIteratorHelper2[\"default\"])(reachableExecutableDefinitions),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var definition = _step4.value;\n        this._variables = definition.variables;\n        var normalizationRootNode = operationLoader.get(definition.module);\n\n        if (normalizationRootNode != null) {\n          var operation = getOperation(normalizationRootNode);\n\n          this._traverseSelections(operation.selections, ROOT_ID);\n        } else {\n          // If the fragment is not available, we assume that the data cannot have\n          // been processed yet and must therefore be missing.\n          this._handleMissing();\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    this._variables = prevVariables;\n  };\n\n  return DataChecker;\n}();\n\nmodule.exports = {\n  check: check\n};","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/store/DataChecker.js"],"names":["_interopRequireDefault","require","_createForOfIteratorHelper2","RelayRecordSourceMutator","RelayRecordSourceProxy","getOperation","RelayConcreteNode","RelayFeatureFlags","_require","isClientID","cloneRelayHandleSourceField","cloneRelayScalarHandleSourceField","_require2","getLocalVariables","RelayModernRecord","_require3","EXISTENT","UNKNOWN","RelayStoreReactFlightUtils","RelayStoreUtils","_require4","generateTypeID","invariant","ACTOR_CHANGE","CONDITION","CLIENT_COMPONENT","CLIENT_EXTENSION","DEFER","FLIGHT_FIELD","FRAGMENT_SPREAD","INLINE_FRAGMENT","LINKED_FIELD","LINKED_HANDLE","MODULE_IMPORT","SCALAR_FIELD","SCALAR_HANDLE","STREAM","TYPE_DISCRIMINATOR","ROOT_ID","getModuleOperationKey","getStorageKey","getArgumentValues","check","getSourceForActor","getTargetForActor","defaultActorIdentifier","selector","handlers","operationLoader","getDataID","shouldProcessClientComponents","dataID","node","variables","checker","DataChecker","_getSourceForActor","_getTargetForActor","_getDataID","_source","_mutatorRecordSourceProxyCache","Map","_this$_getMutatorAndR","_getMutatorAndRecordProxyForActor","mutator","recordSourceProxy","_mostRecentlyInvalidatedAt","_handlers","_mutator","_operationLoader","_recordSourceProxy","_recordWasMissing","_variables","_shouldProcessClientComponents","_proto","prototype","actorIdentifier","tuple","get","target","set","_traverse","status","mostRecentlyInvalidatedAt","_getVariableValue","name","hasOwnProperty","process","env","NODE_ENV","_handleMissing","_getDataForHandlers","field","args","record","_handleMissingScalarField","alias","undefined","_this$_getDataForHand","_iterator","_step","s","n","done","handler","value","kind","newValue","handle","err","e","f","_handleMissingLinkField","_this$_getDataForHand2","_iterator2","_step2","getStatus","_handleMissingPluralLinkField","_this","_this$_getDataForHand3","_iterator3","_step3","allItemsKnown","every","linkedID","invalidatedAt","getInvalidationEpoch","Math","max","_traverseSelections","selections","_this2","forEach","selection","_checkScalar","plural","_checkPluralLink","_checkLink","_checkActorChange","linkedField","conditionValue","Boolean","condition","passingValue","_abstractKey","abstractKey","typeName","getType","type","_recordType","_typeID","_implementsInterface","getValue","handleField","_handleField","_checkModuleImport","prevVariables","fragment","argumentDefinitions","recordWasMissing","recordType","typeID","implementsInterface","ENABLE_REACT_FLIGHT_COMPONENT_FIELD","_checkFlightField","Error","moduleImport","operationKey","documentName","operationReference","normalizationRootNode","operation","storageKey","fieldValue","setValue","getLinkedRecordID","setLinkedRecordID","_this3","linkedIDs","getLinkedRecordIDs","setLinkedRecordIDs","getActorLinkedRecordID","_actorIdentifier","prevSource","prevMutator","prevRecordSourceProxy","_this$_getMutatorAndR2","tree","REACT_FLIGHT_TREE_STORAGE_KEY","reachableExecutableDefinitions","REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY","Array","isArray","_iterator4","_step4","definition","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar RelayRecordSourceMutator = require('../mutations/RelayRecordSourceMutator');\n\nvar RelayRecordSourceProxy = require('../mutations/RelayRecordSourceProxy');\n\nvar getOperation = require('../util/getOperation');\n\nvar RelayConcreteNode = require('../util/RelayConcreteNode');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar _require = require('./ClientID'),\n    isClientID = _require.isClientID;\n\nvar cloneRelayHandleSourceField = require('./cloneRelayHandleSourceField');\n\nvar cloneRelayScalarHandleSourceField = require('./cloneRelayScalarHandleSourceField');\n\nvar _require2 = require('./RelayConcreteVariables'),\n    getLocalVariables = _require2.getLocalVariables;\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require3 = require('./RelayRecordState'),\n    EXISTENT = _require3.EXISTENT,\n    UNKNOWN = _require3.UNKNOWN;\n\nvar RelayStoreReactFlightUtils = require('./RelayStoreReactFlightUtils');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar _require4 = require('./TypeID'),\n    generateTypeID = _require4.generateTypeID;\n\nvar invariant = require('invariant');\n\nvar ACTOR_CHANGE = RelayConcreteNode.ACTOR_CHANGE,\n    CONDITION = RelayConcreteNode.CONDITION,\n    CLIENT_COMPONENT = RelayConcreteNode.CLIENT_COMPONENT,\n    CLIENT_EXTENSION = RelayConcreteNode.CLIENT_EXTENSION,\n    DEFER = RelayConcreteNode.DEFER,\n    FLIGHT_FIELD = RelayConcreteNode.FLIGHT_FIELD,\n    FRAGMENT_SPREAD = RelayConcreteNode.FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = RelayConcreteNode.INLINE_FRAGMENT,\n    LINKED_FIELD = RelayConcreteNode.LINKED_FIELD,\n    LINKED_HANDLE = RelayConcreteNode.LINKED_HANDLE,\n    MODULE_IMPORT = RelayConcreteNode.MODULE_IMPORT,\n    SCALAR_FIELD = RelayConcreteNode.SCALAR_FIELD,\n    SCALAR_HANDLE = RelayConcreteNode.SCALAR_HANDLE,\n    STREAM = RelayConcreteNode.STREAM,\n    TYPE_DISCRIMINATOR = RelayConcreteNode.TYPE_DISCRIMINATOR;\nvar ROOT_ID = RelayStoreUtils.ROOT_ID,\n    getModuleOperationKey = RelayStoreUtils.getModuleOperationKey,\n    getStorageKey = RelayStoreUtils.getStorageKey,\n    getArgumentValues = RelayStoreUtils.getArgumentValues;\n/**\n * Synchronously check whether the records required to fulfill the given\n * `selector` are present in `source`.\n *\n * If a field is missing, it uses the provided handlers to attempt to substitute\n * data. The `target` will store all records that are modified because of a\n * successful substitution.\n *\n * If all records are present, returns `true`, otherwise `false`.\n */\n\nfunction check(getSourceForActor, getTargetForActor, defaultActorIdentifier, selector, handlers, operationLoader, getDataID, shouldProcessClientComponents) {\n  var dataID = selector.dataID,\n      node = selector.node,\n      variables = selector.variables;\n  var checker = new DataChecker(getSourceForActor, getTargetForActor, defaultActorIdentifier, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents);\n  return checker.check(node, dataID);\n}\n/**\n * @private\n */\n\n\nvar DataChecker = /*#__PURE__*/function () {\n  function DataChecker(getSourceForActor, getTargetForActor, defaultActorIdentifier, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents) {\n    this._getSourceForActor = getSourceForActor;\n    this._getTargetForActor = getTargetForActor;\n    this._getDataID = getDataID;\n    this._source = getSourceForActor(defaultActorIdentifier);\n    this._mutatorRecordSourceProxyCache = new Map();\n\n    var _this$_getMutatorAndR = this._getMutatorAndRecordProxyForActor(defaultActorIdentifier),\n        mutator = _this$_getMutatorAndR[0],\n        recordSourceProxy = _this$_getMutatorAndR[1];\n\n    this._mostRecentlyInvalidatedAt = null;\n    this._handlers = handlers;\n    this._mutator = mutator;\n    this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;\n    this._recordSourceProxy = recordSourceProxy;\n    this._recordWasMissing = false;\n    this._variables = variables;\n    this._shouldProcessClientComponents = shouldProcessClientComponents;\n  }\n\n  var _proto = DataChecker.prototype;\n\n  _proto._getMutatorAndRecordProxyForActor = function _getMutatorAndRecordProxyForActor(actorIdentifier) {\n    var tuple = this._mutatorRecordSourceProxyCache.get(actorIdentifier);\n\n    if (tuple == null) {\n      var target = this._getTargetForActor(actorIdentifier);\n\n      var mutator = new RelayRecordSourceMutator(this._getSourceForActor(actorIdentifier), target);\n      var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID);\n      tuple = [mutator, recordSourceProxy];\n\n      this._mutatorRecordSourceProxyCache.set(actorIdentifier, tuple);\n    }\n\n    return tuple;\n  };\n\n  _proto.check = function check(node, dataID) {\n    this._traverse(node, dataID);\n\n    return this._recordWasMissing === true ? {\n      status: 'missing',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    } : {\n      status: 'available',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    };\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n    return this._variables[name];\n  };\n\n  _proto._handleMissing = function _handleMissing() {\n    this._recordWasMissing = true;\n  };\n\n  _proto._getDataForHandlers = function _getDataForHandlers(field, dataID) {\n    return {\n      /* $FlowFixMe[class-object-subtyping] added when improving typing for\n       * this parameters */\n      args: field.args ? getArgumentValues(field.args, this._variables) : {},\n      // Getting a snapshot of the record state is potentially expensive since\n      // we will need to merge the sink and source records. Since we do not create\n      // any new records in this process, it is probably reasonable to provide\n      // handlers with a copy of the source record.\n      // The only thing that the provided record will not contain is fields\n      // added by previous handlers.\n      record: this._source.get(dataID)\n    };\n  };\n\n  _proto._handleMissingScalarField = function _handleMissingScalarField(field, dataID) {\n    if (field.name === 'id' && field.alias == null && isClientID(dataID)) {\n      return undefined;\n    }\n\n    var _this$_getDataForHand = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand.args,\n        record = _this$_getDataForHand.record;\n\n    var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var handler = _step.value;\n\n        if (handler.kind === 'scalar') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingLinkField = function _handleMissingLinkField(field, dataID) {\n    var _this$_getDataForHand2 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand2.args,\n        record = _this$_getDataForHand2.record;\n\n    var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var handler = _step2.value;\n\n        if (handler.kind === 'linked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined && (newValue === null || this._mutator.getStatus(newValue) === EXISTENT)) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingPluralLinkField = function _handleMissingPluralLinkField(field, dataID) {\n    var _this = this;\n\n    var _this$_getDataForHand3 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand3.args,\n        record = _this$_getDataForHand3.record;\n\n    var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var handler = _step3.value;\n\n        if (handler.kind === 'pluralLinked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue != null) {\n            var allItemsKnown = newValue.every(function (linkedID) {\n              return linkedID != null && _this._mutator.getStatus(linkedID) === EXISTENT;\n            });\n\n            if (allItemsKnown) {\n              return newValue;\n            }\n          } else if (newValue === null) {\n            return null;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._traverse = function _traverse(node, dataID) {\n    var status = this._mutator.getStatus(dataID);\n\n    if (status === UNKNOWN) {\n      this._handleMissing();\n    }\n\n    if (status === EXISTENT) {\n      var record = this._source.get(dataID);\n\n      var invalidatedAt = RelayModernRecord.getInvalidationEpoch(record);\n\n      if (invalidatedAt != null) {\n        this._mostRecentlyInvalidatedAt = this._mostRecentlyInvalidatedAt != null ? Math.max(this._mostRecentlyInvalidatedAt, invalidatedAt) : invalidatedAt;\n      }\n\n      this._traverseSelections(node.selections, dataID);\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, dataID) {\n    var _this2 = this;\n\n    selections.forEach(function (selection) {\n      switch (selection.kind) {\n        case SCALAR_FIELD:\n          _this2._checkScalar(selection, dataID);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            _this2._checkPluralLink(selection, dataID);\n          } else {\n            _this2._checkLink(selection, dataID);\n          }\n\n          break;\n\n        case ACTOR_CHANGE:\n          _this2._checkActorChange(selection.linkedField, dataID);\n\n          break;\n\n        case CONDITION:\n          var conditionValue = Boolean(_this2._getVariableValue(selection.condition));\n\n          if (conditionValue === selection.passingValue) {\n            _this2._traverseSelections(selection.selections, dataID);\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var _abstractKey = selection.abstractKey;\n\n            if (_abstractKey == null) {\n              // concrete type refinement: only check data if the type exactly matches\n              var typeName = _this2._mutator.getType(dataID);\n\n              if (typeName === selection.type) {\n                _this2._traverseSelections(selection.selections, dataID);\n              }\n            } else {\n              // Abstract refinement: check data depending on whether the type\n              // conforms to the interface/union or not:\n              // - Type known to _not_ implement the interface: don't check the selections.\n              // - Type is known _to_ implement the interface: check selections.\n              // - Unknown whether the type implements the interface: don't check the selections\n              //   and treat the data as missing; we do this because the Relay Compiler\n              //   guarantees that the type discriminator will always be fetched.\n              var _recordType = _this2._mutator.getType(dataID);\n\n              !(_recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n\n              var _typeID = generateTypeID(_recordType);\n\n              var _implementsInterface = _this2._mutator.getValue(_typeID, _abstractKey);\n\n              if (_implementsInterface === true) {\n                _this2._traverseSelections(selection.selections, dataID);\n              } else if (_implementsInterface == null) {\n                // unsure if the type implements the interface: data is\n                // missing so don't bother reading the fragment\n                _this2._handleMissing();\n              } // else false: known to not implement the interface\n\n            }\n\n            break;\n          }\n\n        case LINKED_HANDLE:\n          {\n            // Handles have no selections themselves; traverse the original field\n            // where the handle was set-up instead.\n            var handleField = cloneRelayHandleSourceField(selection, selections, _this2._variables);\n\n            if (handleField.plural) {\n              _this2._checkPluralLink(handleField, dataID);\n            } else {\n              _this2._checkLink(handleField, dataID);\n            }\n\n            break;\n          }\n\n        case SCALAR_HANDLE:\n          {\n            var _handleField = cloneRelayScalarHandleSourceField(selection, selections, _this2._variables);\n\n            _this2._checkScalar(_handleField, dataID);\n\n            break;\n          }\n\n        case MODULE_IMPORT:\n          _this2._checkModuleImport(selection, dataID);\n\n          break;\n\n        case DEFER:\n        case STREAM:\n          _this2._traverseSelections(selection.selections, dataID);\n\n          break;\n\n        case FRAGMENT_SPREAD:\n          var prevVariables = _this2._variables;\n          _this2._variables = getLocalVariables(_this2._variables, selection.fragment.argumentDefinitions, selection.args);\n\n          _this2._traverseSelections(selection.fragment.selections, dataID);\n\n          _this2._variables = prevVariables;\n          break;\n\n        case CLIENT_EXTENSION:\n          var recordWasMissing = _this2._recordWasMissing;\n\n          _this2._traverseSelections(selection.selections, dataID);\n\n          _this2._recordWasMissing = recordWasMissing;\n          break;\n\n        case TYPE_DISCRIMINATOR:\n          var abstractKey = selection.abstractKey;\n\n          var recordType = _this2._mutator.getType(dataID);\n\n          !(recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n          var typeID = generateTypeID(recordType);\n\n          var implementsInterface = _this2._mutator.getValue(typeID, abstractKey);\n\n          if (implementsInterface == null) {\n            // unsure if the type implements the interface: data is\n            // missing\n            _this2._handleMissing();\n          } // else: if it does or doesn't implement, we don't need to check or skip anything else\n\n\n          break;\n\n        case FLIGHT_FIELD:\n          if (RelayFeatureFlags.ENABLE_REACT_FLIGHT_COMPONENT_FIELD) {\n            _this2._checkFlightField(selection, dataID);\n          } else {\n            throw new Error('Flight fields are not yet supported.');\n          }\n\n          break;\n\n        case CLIENT_COMPONENT:\n          if (_this2._shouldProcessClientComponents === false) {\n            break;\n          }\n\n          _this2._traverseSelections(selection.fragment.selections, dataID);\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    });\n  };\n\n  _proto._checkModuleImport = function _checkModuleImport(moduleImport, dataID) {\n    var operationLoader = this._operationLoader;\n    !(operationLoader !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using `@module`.') : invariant(false) : void 0;\n    var operationKey = getModuleOperationKey(moduleImport.documentName);\n\n    var operationReference = this._mutator.getValue(dataID, operationKey);\n\n    if (operationReference == null) {\n      if (operationReference === undefined) {\n        this._handleMissing();\n      }\n\n      return;\n    }\n\n    var normalizationRootNode = operationLoader.get(operationReference);\n\n    if (normalizationRootNode != null) {\n      var operation = getOperation(normalizationRootNode);\n      var prevVariables = this._variables;\n      this._variables = getLocalVariables(this._variables, operation.argumentDefinitions, moduleImport.args);\n\n      this._traverse(operation, dataID);\n\n      this._variables = prevVariables;\n    } else {\n      // If the fragment is not available, we assume that the data cannot have been\n      // processed yet and must therefore be missing.\n      this._handleMissing();\n    }\n  };\n\n  _proto._checkScalar = function _checkScalar(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var fieldValue = this._mutator.getValue(dataID, storageKey);\n\n    if (fieldValue === undefined) {\n      fieldValue = this._handleMissingScalarField(field, dataID);\n\n      if (fieldValue !== undefined) {\n        this._mutator.setValue(dataID, storageKey, fieldValue);\n      }\n    }\n  };\n\n  _proto._checkLink = function _checkLink(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);\n\n    if (linkedID === undefined) {\n      linkedID = this._handleMissingLinkField(field, dataID);\n\n      if (linkedID != null) {\n        this._mutator.setLinkedRecordID(dataID, storageKey, linkedID);\n      } else if (linkedID === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedID != null) {\n      this._traverse(field, linkedID);\n    }\n  };\n\n  _proto._checkPluralLink = function _checkPluralLink(field, dataID) {\n    var _this3 = this;\n\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedIDs = this._mutator.getLinkedRecordIDs(dataID, storageKey);\n\n    if (linkedIDs === undefined) {\n      linkedIDs = this._handleMissingPluralLinkField(field, dataID);\n\n      if (linkedIDs != null) {\n        this._mutator.setLinkedRecordIDs(dataID, storageKey, linkedIDs);\n      } else if (linkedIDs === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedIDs) {\n      linkedIDs.forEach(function (linkedID) {\n        if (linkedID != null) {\n          _this3._traverse(field, linkedID);\n        }\n      });\n    }\n  };\n\n  _proto._checkActorChange = function _checkActorChange(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var record = this._source.get(dataID);\n\n    var tuple = record != null ? RelayModernRecord.getActorLinkedRecordID(record, storageKey) : record;\n\n    if (tuple == null) {\n      if (tuple === undefined) {\n        this._handleMissing();\n      }\n    } else {\n      var _actorIdentifier = tuple[0],\n          linkedID = tuple[1];\n      var prevSource = this._source;\n      var prevMutator = this._mutator;\n      var prevRecordSourceProxy = this._recordSourceProxy;\n\n      var _this$_getMutatorAndR2 = this._getMutatorAndRecordProxyForActor(_actorIdentifier),\n          mutator = _this$_getMutatorAndR2[0],\n          recordSourceProxy = _this$_getMutatorAndR2[1];\n\n      this._source = this._getSourceForActor(_actorIdentifier);\n      this._mutator = mutator;\n      this._recordSourceProxy = recordSourceProxy;\n\n      this._traverse(field, linkedID);\n\n      this._source = prevSource;\n      this._mutator = prevMutator;\n      this._recordSourceProxy = prevRecordSourceProxy;\n    }\n  };\n\n  _proto._checkFlightField = function _checkFlightField(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);\n\n    if (linkedID == null) {\n      if (linkedID === undefined) {\n        this._handleMissing();\n\n        return;\n      }\n\n      return;\n    }\n\n    var tree = this._mutator.getValue(linkedID, RelayStoreReactFlightUtils.REACT_FLIGHT_TREE_STORAGE_KEY);\n\n    var reachableExecutableDefinitions = this._mutator.getValue(linkedID, RelayStoreReactFlightUtils.REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY);\n\n    if (tree == null || !Array.isArray(reachableExecutableDefinitions)) {\n      this._handleMissing();\n\n      return;\n    }\n\n    var operationLoader = this._operationLoader;\n    !(operationLoader !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using ' + 'React Flight.') : invariant(false) : void 0; // In Flight, the variables that are in scope for reachable executable\n    // definitions aren't the same as what's in scope for the outer query.\n\n    var prevVariables = this._variables; // $FlowFixMe[incompatible-cast]\n\n    var _iterator4 = (0, _createForOfIteratorHelper2[\"default\"])(reachableExecutableDefinitions),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var definition = _step4.value;\n        this._variables = definition.variables;\n        var normalizationRootNode = operationLoader.get(definition.module);\n\n        if (normalizationRootNode != null) {\n          var operation = getOperation(normalizationRootNode);\n\n          this._traverseSelections(operation.selections, ROOT_ID);\n        } else {\n          // If the fragment is not available, we assume that the data cannot have\n          // been processed yet and must therefore be missing.\n          this._handleMissing();\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    this._variables = prevVariables;\n  };\n\n  return DataChecker;\n}();\n\nmodule.exports = {\n  check: check\n};"]},"metadata":{},"sourceType":"script"}