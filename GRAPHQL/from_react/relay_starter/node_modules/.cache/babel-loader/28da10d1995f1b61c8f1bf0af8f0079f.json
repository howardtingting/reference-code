{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _require = require('../../store/ClientID'),\n    generateClientID = _require.generateClientID;\n\nvar _require2 = require('../../store/RelayStoreUtils'),\n    getStableStorageKey = _require2.getStableStorageKey;\n\nvar getRelayHandleKey = require('../../util/getRelayHandleKey');\n\nvar ConnectionInterface = require('./ConnectionInterface');\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar CONNECTION = 'connection'; // Per-instance incrementing index used to generate unique edge IDs\n\nvar NEXT_EDGE_INDEX = '__connection_next_edge_index';\n/**\n * @public\n *\n * A default runtime handler for connection fields that appends newly fetched\n * edges onto the end of a connection, regardless of the arguments used to fetch\n * those edges.\n */\n\nfunction update(store, payload) {\n  var record = store.get(payload.dataID);\n\n  if (!record) {\n    return;\n  }\n\n  var _ConnectionInterface$ = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$.EDGES,\n      END_CURSOR = _ConnectionInterface$.END_CURSOR,\n      HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE,\n      HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE,\n      PAGE_INFO = _ConnectionInterface$.PAGE_INFO,\n      PAGE_INFO_TYPE = _ConnectionInterface$.PAGE_INFO_TYPE,\n      START_CURSOR = _ConnectionInterface$.START_CURSOR;\n\n  var serverConnection = record.getLinkedRecord(payload.fieldKey);\n  var serverPageInfo = serverConnection && serverConnection.getLinkedRecord(PAGE_INFO);\n\n  if (!serverConnection) {\n    record.setValue(null, payload.handleKey);\n    return;\n  } // In rare cases the handleKey field may be unset even though the client\n  // connection record exists, in this case new edges should still be merged\n  // into the existing client connection record (and the field reset to point\n  // to that record).\n\n\n  var clientConnectionID = generateClientID(record.getDataID(), payload.handleKey);\n  var clientConnectionField = record.getLinkedRecord(payload.handleKey);\n  var clientConnection = clientConnectionField !== null && clientConnectionField !== void 0 ? clientConnectionField : store.get(clientConnectionID);\n  var clientPageInfo = clientConnection && clientConnection.getLinkedRecord(PAGE_INFO);\n\n  if (!clientConnection) {\n    // Initial fetch with data: copy fields from the server record\n    var connection = store.create(clientConnectionID, serverConnection.getType());\n    connection.setValue(0, NEXT_EDGE_INDEX);\n    connection.copyFieldsFrom(serverConnection);\n    var serverEdges = serverConnection.getLinkedRecords(EDGES);\n\n    if (serverEdges) {\n      serverEdges = serverEdges.map(function (edge) {\n        return buildConnectionEdge(store, connection, edge);\n      });\n      connection.setLinkedRecords(serverEdges, EDGES);\n    }\n\n    record.setLinkedRecord(connection, payload.handleKey);\n    clientPageInfo = store.create(generateClientID(connection.getDataID(), PAGE_INFO), PAGE_INFO_TYPE);\n    clientPageInfo.setValue(false, HAS_NEXT_PAGE);\n    clientPageInfo.setValue(false, HAS_PREV_PAGE);\n    clientPageInfo.setValue(null, END_CURSOR);\n    clientPageInfo.setValue(null, START_CURSOR);\n\n    if (serverPageInfo) {\n      clientPageInfo.copyFieldsFrom(serverPageInfo);\n    }\n\n    connection.setLinkedRecord(clientPageInfo, PAGE_INFO);\n  } else {\n    if (clientConnectionField == null) {\n      // If the handleKey field was unset but the client connection record\n      // existed, update the field to point to the record\n      record.setLinkedRecord(clientConnection, payload.handleKey);\n    }\n\n    var _connection = clientConnection; // Subsequent fetches:\n    // - updated fields on the connection\n    // - merge prev/next edges, de-duplicating by node id\n    // - synthesize page info fields\n\n    var _serverEdges = serverConnection.getLinkedRecords(EDGES);\n\n    if (_serverEdges) {\n      _serverEdges = _serverEdges.map(function (edge) {\n        return buildConnectionEdge(store, _connection, edge);\n      });\n    }\n\n    var prevEdges = _connection.getLinkedRecords(EDGES);\n\n    var prevPageInfo = _connection.getLinkedRecord(PAGE_INFO);\n\n    _connection.copyFieldsFrom(serverConnection); // Reset EDGES and PAGE_INFO fields\n\n\n    if (prevEdges) {\n      _connection.setLinkedRecords(prevEdges, EDGES);\n    }\n\n    if (prevPageInfo) {\n      _connection.setLinkedRecord(prevPageInfo, PAGE_INFO);\n    }\n\n    var nextEdges = [];\n    var args = payload.args;\n\n    if (prevEdges && _serverEdges) {\n      if (args.after != null) {\n        // Forward pagination from the end of the connection: append edges\n        if (clientPageInfo && args.after === clientPageInfo.getValue(END_CURSOR)) {\n          var nodeIDs = new Set();\n          mergeEdges(prevEdges, nextEdges, nodeIDs);\n          mergeEdges(_serverEdges, nextEdges, nodeIDs);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected after cursor `%s`, edges must ' + 'be fetched from the end of the list (`%s`).', args.after, clientPageInfo && clientPageInfo.getValue(END_CURSOR)) : void 0;\n          return;\n        }\n      } else if (args.before != null) {\n        // Backward pagination from the start of the connection: prepend edges\n        if (clientPageInfo && args.before === clientPageInfo.getValue(START_CURSOR)) {\n          var _nodeIDs = new Set();\n\n          mergeEdges(_serverEdges, nextEdges, _nodeIDs);\n          mergeEdges(prevEdges, nextEdges, _nodeIDs);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected before cursor `%s`, edges must ' + 'be fetched from the beginning of the list (`%s`).', args.before, clientPageInfo && clientPageInfo.getValue(START_CURSOR)) : void 0;\n          return;\n        }\n      } else {\n        // The connection was refetched from the beginning/end: replace edges\n        nextEdges = _serverEdges;\n      }\n    } else if (_serverEdges) {\n      nextEdges = _serverEdges;\n    } else {\n      nextEdges = prevEdges;\n    } // Update edges only if they were updated, the null check is\n    // for Flow (prevEdges could be null).\n\n\n    if (nextEdges != null && nextEdges !== prevEdges) {\n      _connection.setLinkedRecords(nextEdges, EDGES);\n    } // Page info should be updated even if no new edge were returned.\n\n\n    if (clientPageInfo && serverPageInfo) {\n      if (args.after == null && args.before == null) {\n        // The connection was refetched from the beginning/end: replace\n        // page_info\n        clientPageInfo.copyFieldsFrom(serverPageInfo);\n      } else if (args.before != null || args.after == null && args.last) {\n        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_PREV_PAGE), HAS_PREV_PAGE);\n        var startCursor = serverPageInfo.getValue(START_CURSOR);\n\n        if (typeof startCursor === 'string') {\n          clientPageInfo.setValue(startCursor, START_CURSOR);\n        }\n      } else if (args.after != null || args.before == null && args.first) {\n        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_NEXT_PAGE), HAS_NEXT_PAGE);\n        var endCursor = serverPageInfo.getValue(END_CURSOR);\n\n        if (typeof endCursor === 'string') {\n          clientPageInfo.setValue(endCursor, END_CURSOR);\n        }\n      }\n    }\n  }\n}\n/**\n * @public\n *\n * Given a record and the name of the schema field for which a connection was\n * fetched, returns the linked connection record.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * The `friends` connection record can be accessed with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   // Access fields on the connection:\n *   const edges = friends.getLinkedRecords('edges');\n * }\n * ```\n *\n * TODO: t15733312\n * Currently we haven't run into this case yet, but we need to add a `getConnections`\n * that returns an array of the connections under the same `key` regardless of the variables.\n */\n\n\nfunction getConnection(record, key, filters) {\n  var handleKey = getRelayHandleKey(CONNECTION, key, null);\n  return record.getLinkedRecord(handleKey, filters);\n}\n/**\n * @public\n *\n * Given a record ID, the key of a connection field, and optional filters used\n * to identify the connection, returns the connection ID.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<user-id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *     edges {\n *       node {\n *         id\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * The ID of the `friends` connection record can be accessed with:\n *\n * ```\n * store => {\n *   const connectionID = ConnectionHandler.getConnectionID('<user-id>', 'FriendsFragment_friends');\n * }\n * ```\n */\n\n\nfunction getConnectionID(recordID, key, filters) {\n  var handleKey = getRelayHandleKey(CONNECTION, key, null);\n  var storageKey = getStableStorageKey(handleKey, filters);\n  return generateClientID(recordID, storageKey);\n}\n/**\n * @public\n *\n * Inserts an edge after the given cursor, or at the end of the list if no\n * cursor is provided.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * An edge can be appended with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   const edge = store.create('<edge-id>', 'FriendsEdge');\n *   ConnectionHandler.insertEdgeAfter(friends, edge);\n * }\n * ```\n */\n\n\nfunction insertEdgeAfter(record, newEdge, cursor) {\n  var _ConnectionInterface$2 = ConnectionInterface.get(),\n      CURSOR = _ConnectionInterface$2.CURSOR,\n      EDGES = _ConnectionInterface$2.EDGES;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    record.setLinkedRecords([newEdge], EDGES);\n    return;\n  }\n\n  var nextEdges;\n\n  if (cursor == null) {\n    nextEdges = edges.concat(newEdge);\n  } else {\n    nextEdges = [];\n    var foundCursor = false;\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n      nextEdges.push(edge);\n\n      if (edge == null) {\n        continue;\n      }\n\n      var edgeCursor = edge.getValue(CURSOR);\n\n      if (cursor === edgeCursor) {\n        nextEdges.push(newEdge);\n        foundCursor = true;\n      }\n    }\n\n    if (!foundCursor) {\n      nextEdges.push(newEdge);\n    }\n  }\n\n  record.setLinkedRecords(nextEdges, EDGES);\n}\n/**\n * @public\n *\n * Creates an edge for a connection record, given a node and edge type.\n */\n\n\nfunction createEdge(store, record, node, edgeType) {\n  var _ConnectionInterface$3 = ConnectionInterface.get(),\n      NODE = _ConnectionInterface$3.NODE; // An index-based client ID could easily conflict (unless it was\n  // auto-incrementing, but there is nowhere to the store the id)\n  // Instead, construct a client ID based on the connection ID and node ID,\n  // which will only conflict if the same node is added to the same connection\n  // twice. This is acceptable since the `insertEdge*` functions ignore\n  // duplicates.\n\n\n  var edgeID = generateClientID(record.getDataID(), node.getDataID());\n  var edge = store.get(edgeID);\n\n  if (!edge) {\n    edge = store.create(edgeID, edgeType);\n  }\n\n  edge.setLinkedRecord(node, NODE);\n\n  if (edge.getValue('cursor') == null) {\n    // Always use null instead of undefined value for cursor\n    // to avoid considering it as missing data\n    edge.setValue(null, 'cursor');\n  }\n\n  return edge;\n}\n/**\n * @public\n *\n * Inserts an edge before the given cursor, or at the beginning of the list if\n * no cursor is provided.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * An edge can be prepended with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   const edge = store.create('<edge-id>', 'FriendsEdge');\n *   ConnectionHandler.insertEdgeBefore(friends, edge);\n * }\n * ```\n */\n\n\nfunction insertEdgeBefore(record, newEdge, cursor) {\n  var _ConnectionInterface$4 = ConnectionInterface.get(),\n      CURSOR = _ConnectionInterface$4.CURSOR,\n      EDGES = _ConnectionInterface$4.EDGES;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    record.setLinkedRecords([newEdge], EDGES);\n    return;\n  }\n\n  var nextEdges;\n\n  if (cursor == null) {\n    nextEdges = [newEdge].concat(edges);\n  } else {\n    nextEdges = [];\n    var foundCursor = false;\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n\n      if (edge != null) {\n        var edgeCursor = edge.getValue(CURSOR);\n\n        if (cursor === edgeCursor) {\n          nextEdges.push(newEdge);\n          foundCursor = true;\n        }\n      }\n\n      nextEdges.push(edge);\n    }\n\n    if (!foundCursor) {\n      nextEdges.unshift(newEdge);\n    }\n  }\n\n  record.setLinkedRecords(nextEdges, EDGES);\n}\n/**\n * @public\n *\n * Remove any edges whose `node.id` matches the given id.\n */\n\n\nfunction deleteNode(record, nodeID) {\n  var _ConnectionInterface$5 = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$5.EDGES,\n      NODE = _ConnectionInterface$5.NODE;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    return;\n  }\n\n  var nextEdges;\n\n  for (var ii = 0; ii < edges.length; ii++) {\n    var edge = edges[ii];\n    var node = edge && edge.getLinkedRecord(NODE);\n\n    if (node != null && node.getDataID() === nodeID) {\n      if (nextEdges === undefined) {\n        nextEdges = edges.slice(0, ii);\n      }\n    } else if (nextEdges !== undefined) {\n      nextEdges.push(edge);\n    }\n  }\n\n  if (nextEdges !== undefined) {\n    record.setLinkedRecords(nextEdges, EDGES);\n  }\n}\n/**\n * @internal\n *\n * Creates a copy of an edge with a unique ID based on per-connection-instance\n * incrementing edge index. This is necessary to avoid collisions between edges,\n * which can occur because (edge) client IDs are assigned deterministically\n * based on the path from the nearest node with an id.\n *\n * Example: if the first N edges of the same connection are refetched, the edges\n * from the second fetch will be assigned the same IDs as the first fetch, even\n * though the nodes they point to may be different (or the same and in different\n * order).\n */\n\n\nfunction buildConnectionEdge(store, connection, edge) {\n  if (edge == null) {\n    return edge;\n  }\n\n  var _ConnectionInterface$6 = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$6.EDGES;\n\n  var edgeIndex = connection.getValue(NEXT_EDGE_INDEX);\n  !(typeof edgeIndex === 'number') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ConnectionHandler: Expected %s to be a number, got `%s`.', NEXT_EDGE_INDEX, edgeIndex) : invariant(false) : void 0;\n  var edgeID = generateClientID(connection.getDataID(), EDGES, edgeIndex);\n  var connectionEdge = store.create(edgeID, edge.getType());\n  connectionEdge.copyFieldsFrom(edge);\n\n  if (connectionEdge.getValue('cursor') == null) {\n    // Always use null instead of undefined value for cursor\n    // to avoid considering it as missing data\n    connectionEdge.setValue(null, 'cursor');\n  }\n\n  connection.setValue(edgeIndex + 1, NEXT_EDGE_INDEX);\n  return connectionEdge;\n}\n/**\n * @internal\n *\n * Adds the source edges to the target edges, skipping edges with\n * duplicate node ids.\n */\n\n\nfunction mergeEdges(sourceEdges, targetEdges, nodeIDs) {\n  var _ConnectionInterface$7 = ConnectionInterface.get(),\n      NODE = _ConnectionInterface$7.NODE;\n\n  for (var ii = 0; ii < sourceEdges.length; ii++) {\n    var edge = sourceEdges[ii];\n\n    if (!edge) {\n      continue;\n    }\n\n    var node = edge.getLinkedRecord(NODE);\n    var nodeID = node && node.getDataID();\n\n    if (nodeID) {\n      if (nodeIDs.has(nodeID)) {\n        continue;\n      }\n\n      nodeIDs.add(nodeID);\n    }\n\n    targetEdges.push(edge);\n  }\n}\n\nmodule.exports = {\n  buildConnectionEdge: buildConnectionEdge,\n  createEdge: createEdge,\n  deleteNode: deleteNode,\n  getConnection: getConnection,\n  getConnectionID: getConnectionID,\n  insertEdgeAfter: insertEdgeAfter,\n  insertEdgeBefore: insertEdgeBefore,\n  update: update\n};","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/handlers/connection/ConnectionHandler.js"],"names":["_require","require","generateClientID","_require2","getStableStorageKey","getRelayHandleKey","ConnectionInterface","invariant","warning","CONNECTION","NEXT_EDGE_INDEX","update","store","payload","record","get","dataID","_ConnectionInterface$","EDGES","END_CURSOR","HAS_NEXT_PAGE","HAS_PREV_PAGE","PAGE_INFO","PAGE_INFO_TYPE","START_CURSOR","serverConnection","getLinkedRecord","fieldKey","serverPageInfo","setValue","handleKey","clientConnectionID","getDataID","clientConnectionField","clientConnection","clientPageInfo","connection","create","getType","copyFieldsFrom","serverEdges","getLinkedRecords","map","edge","buildConnectionEdge","setLinkedRecords","setLinkedRecord","_connection","_serverEdges","prevEdges","prevPageInfo","nextEdges","args","after","getValue","nodeIDs","Set","mergeEdges","process","env","NODE_ENV","before","_nodeIDs","last","startCursor","first","endCursor","getConnection","key","filters","getConnectionID","recordID","storageKey","insertEdgeAfter","newEdge","cursor","_ConnectionInterface$2","CURSOR","edges","concat","foundCursor","ii","length","push","edgeCursor","createEdge","node","edgeType","_ConnectionInterface$3","NODE","edgeID","insertEdgeBefore","_ConnectionInterface$4","unshift","deleteNode","nodeID","_ConnectionInterface$5","undefined","slice","_ConnectionInterface$6","edgeIndex","connectionEdge","sourceEdges","targetEdges","_ConnectionInterface$7","has","add","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,sBAAD,CAAtB;AAAA,IACIC,gBAAgB,GAAGF,QAAQ,CAACE,gBADhC;;AAGA,IAAIC,SAAS,GAAGF,OAAO,CAAC,6BAAD,CAAvB;AAAA,IACIG,mBAAmB,GAAGD,SAAS,CAACC,mBADpC;;AAGA,IAAIC,iBAAiB,GAAGJ,OAAO,CAAC,8BAAD,CAA/B;;AAEA,IAAIK,mBAAmB,GAAGL,OAAO,CAAC,uBAAD,CAAjC;;AAEA,IAAIM,SAAS,GAAGN,OAAO,CAAC,WAAD,CAAvB;;AAEA,IAAIO,OAAO,GAAGP,OAAO,CAAC,kBAAD,CAArB;;AAEA,IAAIQ,UAAU,GAAG,YAAjB,C,CAA+B;;AAE/B,IAAIC,eAAe,GAAG,8BAAtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,MAAT,CAAgBC,KAAhB,EAAuBC,OAAvB,EAAgC;AAC9B,MAAIC,MAAM,GAAGF,KAAK,CAACG,GAAN,CAAUF,OAAO,CAACG,MAAlB,CAAb;;AAEA,MAAI,CAACF,MAAL,EAAa;AACX;AACD;;AAED,MAAIG,qBAAqB,GAAGX,mBAAmB,CAACS,GAApB,EAA5B;AAAA,MACIG,KAAK,GAAGD,qBAAqB,CAACC,KADlC;AAAA,MAEIC,UAAU,GAAGF,qBAAqB,CAACE,UAFvC;AAAA,MAGIC,aAAa,GAAGH,qBAAqB,CAACG,aAH1C;AAAA,MAIIC,aAAa,GAAGJ,qBAAqB,CAACI,aAJ1C;AAAA,MAKIC,SAAS,GAAGL,qBAAqB,CAACK,SALtC;AAAA,MAMIC,cAAc,GAAGN,qBAAqB,CAACM,cAN3C;AAAA,MAOIC,YAAY,GAAGP,qBAAqB,CAACO,YAPzC;;AASA,MAAIC,gBAAgB,GAAGX,MAAM,CAACY,eAAP,CAAuBb,OAAO,CAACc,QAA/B,CAAvB;AACA,MAAIC,cAAc,GAAGH,gBAAgB,IAAIA,gBAAgB,CAACC,eAAjB,CAAiCJ,SAAjC,CAAzC;;AAEA,MAAI,CAACG,gBAAL,EAAuB;AACrBX,IAAAA,MAAM,CAACe,QAAP,CAAgB,IAAhB,EAAsBhB,OAAO,CAACiB,SAA9B;AACA;AACD,GAtB6B,CAsB5B;AACF;AACA;AACA;;;AAGA,MAAIC,kBAAkB,GAAG7B,gBAAgB,CAACY,MAAM,CAACkB,SAAP,EAAD,EAAqBnB,OAAO,CAACiB,SAA7B,CAAzC;AACA,MAAIG,qBAAqB,GAAGnB,MAAM,CAACY,eAAP,CAAuBb,OAAO,CAACiB,SAA/B,CAA5B;AACA,MAAII,gBAAgB,GAAGD,qBAAqB,KAAK,IAA1B,IAAkCA,qBAAqB,KAAK,KAAK,CAAjE,GAAqEA,qBAArE,GAA6FrB,KAAK,CAACG,GAAN,CAAUgB,kBAAV,CAApH;AACA,MAAII,cAAc,GAAGD,gBAAgB,IAAIA,gBAAgB,CAACR,eAAjB,CAAiCJ,SAAjC,CAAzC;;AAEA,MAAI,CAACY,gBAAL,EAAuB;AACrB;AACA,QAAIE,UAAU,GAAGxB,KAAK,CAACyB,MAAN,CAAaN,kBAAb,EAAiCN,gBAAgB,CAACa,OAAjB,EAAjC,CAAjB;AACAF,IAAAA,UAAU,CAACP,QAAX,CAAoB,CAApB,EAAuBnB,eAAvB;AACA0B,IAAAA,UAAU,CAACG,cAAX,CAA0Bd,gBAA1B;AACA,QAAIe,WAAW,GAAGf,gBAAgB,CAACgB,gBAAjB,CAAkCvB,KAAlC,CAAlB;;AAEA,QAAIsB,WAAJ,EAAiB;AACfA,MAAAA,WAAW,GAAGA,WAAW,CAACE,GAAZ,CAAgB,UAAUC,IAAV,EAAgB;AAC5C,eAAOC,mBAAmB,CAAChC,KAAD,EAAQwB,UAAR,EAAoBO,IAApB,CAA1B;AACD,OAFa,CAAd;AAGAP,MAAAA,UAAU,CAACS,gBAAX,CAA4BL,WAA5B,EAAyCtB,KAAzC;AACD;;AAEDJ,IAAAA,MAAM,CAACgC,eAAP,CAAuBV,UAAvB,EAAmCvB,OAAO,CAACiB,SAA3C;AACAK,IAAAA,cAAc,GAAGvB,KAAK,CAACyB,MAAN,CAAanC,gBAAgB,CAACkC,UAAU,CAACJ,SAAX,EAAD,EAAyBV,SAAzB,CAA7B,EAAkEC,cAAlE,CAAjB;AACAY,IAAAA,cAAc,CAACN,QAAf,CAAwB,KAAxB,EAA+BT,aAA/B;AACAe,IAAAA,cAAc,CAACN,QAAf,CAAwB,KAAxB,EAA+BR,aAA/B;AACAc,IAAAA,cAAc,CAACN,QAAf,CAAwB,IAAxB,EAA8BV,UAA9B;AACAgB,IAAAA,cAAc,CAACN,QAAf,CAAwB,IAAxB,EAA8BL,YAA9B;;AAEA,QAAII,cAAJ,EAAoB;AAClBO,MAAAA,cAAc,CAACI,cAAf,CAA8BX,cAA9B;AACD;;AAEDQ,IAAAA,UAAU,CAACU,eAAX,CAA2BX,cAA3B,EAA2Cb,SAA3C;AACD,GA1BD,MA0BO;AACL,QAAIW,qBAAqB,IAAI,IAA7B,EAAmC;AACjC;AACA;AACAnB,MAAAA,MAAM,CAACgC,eAAP,CAAuBZ,gBAAvB,EAAyCrB,OAAO,CAACiB,SAAjD;AACD;;AAED,QAAIiB,WAAW,GAAGb,gBAAlB,CAPK,CAO+B;AACpC;AACA;AACA;;AAEA,QAAIc,YAAY,GAAGvB,gBAAgB,CAACgB,gBAAjB,CAAkCvB,KAAlC,CAAnB;;AAEA,QAAI8B,YAAJ,EAAkB;AAChBA,MAAAA,YAAY,GAAGA,YAAY,CAACN,GAAb,CAAiB,UAAUC,IAAV,EAAgB;AAC9C,eAAOC,mBAAmB,CAAChC,KAAD,EAAQmC,WAAR,EAAqBJ,IAArB,CAA1B;AACD,OAFc,CAAf;AAGD;;AAED,QAAIM,SAAS,GAAGF,WAAW,CAACN,gBAAZ,CAA6BvB,KAA7B,CAAhB;;AAEA,QAAIgC,YAAY,GAAGH,WAAW,CAACrB,eAAZ,CAA4BJ,SAA5B,CAAnB;;AAEAyB,IAAAA,WAAW,CAACR,cAAZ,CAA2Bd,gBAA3B,EAxBK,CAwByC;;;AAG9C,QAAIwB,SAAJ,EAAe;AACbF,MAAAA,WAAW,CAACF,gBAAZ,CAA6BI,SAA7B,EAAwC/B,KAAxC;AACD;;AAED,QAAIgC,YAAJ,EAAkB;AAChBH,MAAAA,WAAW,CAACD,eAAZ,CAA4BI,YAA5B,EAA0C5B,SAA1C;AACD;;AAED,QAAI6B,SAAS,GAAG,EAAhB;AACA,QAAIC,IAAI,GAAGvC,OAAO,CAACuC,IAAnB;;AAEA,QAAIH,SAAS,IAAID,YAAjB,EAA+B;AAC7B,UAAII,IAAI,CAACC,KAAL,IAAc,IAAlB,EAAwB;AACtB;AACA,YAAIlB,cAAc,IAAIiB,IAAI,CAACC,KAAL,KAAelB,cAAc,CAACmB,QAAf,CAAwBnC,UAAxB,CAArC,EAA0E;AACxE,cAAIoC,OAAO,GAAG,IAAIC,GAAJ,EAAd;AACAC,UAAAA,UAAU,CAACR,SAAD,EAAYE,SAAZ,EAAuBI,OAAvB,CAAV;AACAE,UAAAA,UAAU,CAACT,YAAD,EAAeG,SAAf,EAA0BI,OAA1B,CAAV;AACD,SAJD,MAIO;AACLG,UAAAA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCpD,OAAO,CAAC,KAAD,EAAQ,qDAAqD,6CAA7D,EAA4G4C,IAAI,CAACC,KAAjH,EAAwHlB,cAAc,IAAIA,cAAc,CAACmB,QAAf,CAAwBnC,UAAxB,CAA1I,CAA/C,GAAgO,KAAK,CAArO;AACA;AACD;AACF,OAVD,MAUO,IAAIiC,IAAI,CAACS,MAAL,IAAe,IAAnB,EAAyB;AAC9B;AACA,YAAI1B,cAAc,IAAIiB,IAAI,CAACS,MAAL,KAAgB1B,cAAc,CAACmB,QAAf,CAAwB9B,YAAxB,CAAtC,EAA6E;AAC3E,cAAIsC,QAAQ,GAAG,IAAIN,GAAJ,EAAf;;AAEAC,UAAAA,UAAU,CAACT,YAAD,EAAeG,SAAf,EAA0BW,QAA1B,CAAV;AACAL,UAAAA,UAAU,CAACR,SAAD,EAAYE,SAAZ,EAAuBW,QAAvB,CAAV;AACD,SALD,MAKO;AACLJ,UAAAA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCpD,OAAO,CAAC,KAAD,EAAQ,sDAAsD,mDAA9D,EAAmH4C,IAAI,CAACS,MAAxH,EAAgI1B,cAAc,IAAIA,cAAc,CAACmB,QAAf,CAAwB9B,YAAxB,CAAlJ,CAA/C,GAA0O,KAAK,CAA/O;AACA;AACD;AACF,OAXM,MAWA;AACL;AACA2B,QAAAA,SAAS,GAAGH,YAAZ;AACD;AACF,KA1BD,MA0BO,IAAIA,YAAJ,EAAkB;AACvBG,MAAAA,SAAS,GAAGH,YAAZ;AACD,KAFM,MAEA;AACLG,MAAAA,SAAS,GAAGF,SAAZ;AACD,KApEI,CAoEH;AACF;;;AAGA,QAAIE,SAAS,IAAI,IAAb,IAAqBA,SAAS,KAAKF,SAAvC,EAAkD;AAChDF,MAAAA,WAAW,CAACF,gBAAZ,CAA6BM,SAA7B,EAAwCjC,KAAxC;AACD,KA1EI,CA0EH;;;AAGF,QAAIiB,cAAc,IAAIP,cAAtB,EAAsC;AACpC,UAAIwB,IAAI,CAACC,KAAL,IAAc,IAAd,IAAsBD,IAAI,CAACS,MAAL,IAAe,IAAzC,EAA+C;AAC7C;AACA;AACA1B,QAAAA,cAAc,CAACI,cAAf,CAA8BX,cAA9B;AACD,OAJD,MAIO,IAAIwB,IAAI,CAACS,MAAL,IAAe,IAAf,IAAuBT,IAAI,CAACC,KAAL,IAAc,IAAd,IAAsBD,IAAI,CAACW,IAAtD,EAA4D;AACjE5B,QAAAA,cAAc,CAACN,QAAf,CAAwB,CAAC,CAACD,cAAc,CAAC0B,QAAf,CAAwBjC,aAAxB,CAA1B,EAAkEA,aAAlE;AACA,YAAI2C,WAAW,GAAGpC,cAAc,CAAC0B,QAAf,CAAwB9B,YAAxB,CAAlB;;AAEA,YAAI,OAAOwC,WAAP,KAAuB,QAA3B,EAAqC;AACnC7B,UAAAA,cAAc,CAACN,QAAf,CAAwBmC,WAAxB,EAAqCxC,YAArC;AACD;AACF,OAPM,MAOA,IAAI4B,IAAI,CAACC,KAAL,IAAc,IAAd,IAAsBD,IAAI,CAACS,MAAL,IAAe,IAAf,IAAuBT,IAAI,CAACa,KAAtD,EAA6D;AAClE9B,QAAAA,cAAc,CAACN,QAAf,CAAwB,CAAC,CAACD,cAAc,CAAC0B,QAAf,CAAwBlC,aAAxB,CAA1B,EAAkEA,aAAlE;AACA,YAAI8C,SAAS,GAAGtC,cAAc,CAAC0B,QAAf,CAAwBnC,UAAxB,CAAhB;;AAEA,YAAI,OAAO+C,SAAP,KAAqB,QAAzB,EAAmC;AACjC/B,UAAAA,cAAc,CAACN,QAAf,CAAwBqC,SAAxB,EAAmC/C,UAAnC;AACD;AACF;AACF;AACF;AACF;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASgD,aAAT,CAAuBrD,MAAvB,EAA+BsD,GAA/B,EAAoCC,OAApC,EAA6C;AAC3C,MAAIvC,SAAS,GAAGzB,iBAAiB,CAACI,UAAD,EAAa2D,GAAb,EAAkB,IAAlB,CAAjC;AACA,SAAOtD,MAAM,CAACY,eAAP,CAAuBI,SAAvB,EAAkCuC,OAAlC,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASC,eAAT,CAAyBC,QAAzB,EAAmCH,GAAnC,EAAwCC,OAAxC,EAAiD;AAC/C,MAAIvC,SAAS,GAAGzB,iBAAiB,CAACI,UAAD,EAAa2D,GAAb,EAAkB,IAAlB,CAAjC;AACA,MAAII,UAAU,GAAGpE,mBAAmB,CAAC0B,SAAD,EAAYuC,OAAZ,CAApC;AACA,SAAOnE,gBAAgB,CAACqE,QAAD,EAAWC,UAAX,CAAvB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASC,eAAT,CAAyB3D,MAAzB,EAAiC4D,OAAjC,EAA0CC,MAA1C,EAAkD;AAChD,MAAIC,sBAAsB,GAAGtE,mBAAmB,CAACS,GAApB,EAA7B;AAAA,MACI8D,MAAM,GAAGD,sBAAsB,CAACC,MADpC;AAAA,MAEI3D,KAAK,GAAG0D,sBAAsB,CAAC1D,KAFnC;;AAIA,MAAI4D,KAAK,GAAGhE,MAAM,CAAC2B,gBAAP,CAAwBvB,KAAxB,CAAZ;;AAEA,MAAI,CAAC4D,KAAL,EAAY;AACVhE,IAAAA,MAAM,CAAC+B,gBAAP,CAAwB,CAAC6B,OAAD,CAAxB,EAAmCxD,KAAnC;AACA;AACD;;AAED,MAAIiC,SAAJ;;AAEA,MAAIwB,MAAM,IAAI,IAAd,EAAoB;AAClBxB,IAAAA,SAAS,GAAG2B,KAAK,CAACC,MAAN,CAAaL,OAAb,CAAZ;AACD,GAFD,MAEO;AACLvB,IAAAA,SAAS,GAAG,EAAZ;AACA,QAAI6B,WAAW,GAAG,KAAlB;;AAEA,SAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGH,KAAK,CAACI,MAA5B,EAAoCD,EAAE,EAAtC,EAA0C;AACxC,UAAItC,IAAI,GAAGmC,KAAK,CAACG,EAAD,CAAhB;AACA9B,MAAAA,SAAS,CAACgC,IAAV,CAAexC,IAAf;;AAEA,UAAIA,IAAI,IAAI,IAAZ,EAAkB;AAChB;AACD;;AAED,UAAIyC,UAAU,GAAGzC,IAAI,CAACW,QAAL,CAAcuB,MAAd,CAAjB;;AAEA,UAAIF,MAAM,KAAKS,UAAf,EAA2B;AACzBjC,QAAAA,SAAS,CAACgC,IAAV,CAAeT,OAAf;AACAM,QAAAA,WAAW,GAAG,IAAd;AACD;AACF;;AAED,QAAI,CAACA,WAAL,EAAkB;AAChB7B,MAAAA,SAAS,CAACgC,IAAV,CAAeT,OAAf;AACD;AACF;;AAED5D,EAAAA,MAAM,CAAC+B,gBAAP,CAAwBM,SAAxB,EAAmCjC,KAAnC;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAASmE,UAAT,CAAoBzE,KAApB,EAA2BE,MAA3B,EAAmCwE,IAAnC,EAAyCC,QAAzC,EAAmD;AACjD,MAAIC,sBAAsB,GAAGlF,mBAAmB,CAACS,GAApB,EAA7B;AAAA,MACI0E,IAAI,GAAGD,sBAAsB,CAACC,IADlC,CADiD,CAET;AACxC;AACA;AACA;AACA;AACA;;;AAGA,MAAIC,MAAM,GAAGxF,gBAAgB,CAACY,MAAM,CAACkB,SAAP,EAAD,EAAqBsD,IAAI,CAACtD,SAAL,EAArB,CAA7B;AACA,MAAIW,IAAI,GAAG/B,KAAK,CAACG,GAAN,CAAU2E,MAAV,CAAX;;AAEA,MAAI,CAAC/C,IAAL,EAAW;AACTA,IAAAA,IAAI,GAAG/B,KAAK,CAACyB,MAAN,CAAaqD,MAAb,EAAqBH,QAArB,CAAP;AACD;;AAED5C,EAAAA,IAAI,CAACG,eAAL,CAAqBwC,IAArB,EAA2BG,IAA3B;;AAEA,MAAI9C,IAAI,CAACW,QAAL,CAAc,QAAd,KAA2B,IAA/B,EAAqC;AACnC;AACA;AACAX,IAAAA,IAAI,CAACd,QAAL,CAAc,IAAd,EAAoB,QAApB;AACD;;AAED,SAAOc,IAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASgD,gBAAT,CAA0B7E,MAA1B,EAAkC4D,OAAlC,EAA2CC,MAA3C,EAAmD;AACjD,MAAIiB,sBAAsB,GAAGtF,mBAAmB,CAACS,GAApB,EAA7B;AAAA,MACI8D,MAAM,GAAGe,sBAAsB,CAACf,MADpC;AAAA,MAEI3D,KAAK,GAAG0E,sBAAsB,CAAC1E,KAFnC;;AAIA,MAAI4D,KAAK,GAAGhE,MAAM,CAAC2B,gBAAP,CAAwBvB,KAAxB,CAAZ;;AAEA,MAAI,CAAC4D,KAAL,EAAY;AACVhE,IAAAA,MAAM,CAAC+B,gBAAP,CAAwB,CAAC6B,OAAD,CAAxB,EAAmCxD,KAAnC;AACA;AACD;;AAED,MAAIiC,SAAJ;;AAEA,MAAIwB,MAAM,IAAI,IAAd,EAAoB;AAClBxB,IAAAA,SAAS,GAAG,CAACuB,OAAD,EAAUK,MAAV,CAAiBD,KAAjB,CAAZ;AACD,GAFD,MAEO;AACL3B,IAAAA,SAAS,GAAG,EAAZ;AACA,QAAI6B,WAAW,GAAG,KAAlB;;AAEA,SAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGH,KAAK,CAACI,MAA5B,EAAoCD,EAAE,EAAtC,EAA0C;AACxC,UAAItC,IAAI,GAAGmC,KAAK,CAACG,EAAD,CAAhB;;AAEA,UAAItC,IAAI,IAAI,IAAZ,EAAkB;AAChB,YAAIyC,UAAU,GAAGzC,IAAI,CAACW,QAAL,CAAcuB,MAAd,CAAjB;;AAEA,YAAIF,MAAM,KAAKS,UAAf,EAA2B;AACzBjC,UAAAA,SAAS,CAACgC,IAAV,CAAeT,OAAf;AACAM,UAAAA,WAAW,GAAG,IAAd;AACD;AACF;;AAED7B,MAAAA,SAAS,CAACgC,IAAV,CAAexC,IAAf;AACD;;AAED,QAAI,CAACqC,WAAL,EAAkB;AAChB7B,MAAAA,SAAS,CAAC0C,OAAV,CAAkBnB,OAAlB;AACD;AACF;;AAED5D,EAAAA,MAAM,CAAC+B,gBAAP,CAAwBM,SAAxB,EAAmCjC,KAAnC;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAAS4E,UAAT,CAAoBhF,MAApB,EAA4BiF,MAA5B,EAAoC;AAClC,MAAIC,sBAAsB,GAAG1F,mBAAmB,CAACS,GAApB,EAA7B;AAAA,MACIG,KAAK,GAAG8E,sBAAsB,CAAC9E,KADnC;AAAA,MAEIuE,IAAI,GAAGO,sBAAsB,CAACP,IAFlC;;AAIA,MAAIX,KAAK,GAAGhE,MAAM,CAAC2B,gBAAP,CAAwBvB,KAAxB,CAAZ;;AAEA,MAAI,CAAC4D,KAAL,EAAY;AACV;AACD;;AAED,MAAI3B,SAAJ;;AAEA,OAAK,IAAI8B,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGH,KAAK,CAACI,MAA5B,EAAoCD,EAAE,EAAtC,EAA0C;AACxC,QAAItC,IAAI,GAAGmC,KAAK,CAACG,EAAD,CAAhB;AACA,QAAIK,IAAI,GAAG3C,IAAI,IAAIA,IAAI,CAACjB,eAAL,CAAqB+D,IAArB,CAAnB;;AAEA,QAAIH,IAAI,IAAI,IAAR,IAAgBA,IAAI,CAACtD,SAAL,OAAqB+D,MAAzC,EAAiD;AAC/C,UAAI5C,SAAS,KAAK8C,SAAlB,EAA6B;AAC3B9C,QAAAA,SAAS,GAAG2B,KAAK,CAACoB,KAAN,CAAY,CAAZ,EAAejB,EAAf,CAAZ;AACD;AACF,KAJD,MAIO,IAAI9B,SAAS,KAAK8C,SAAlB,EAA6B;AAClC9C,MAAAA,SAAS,CAACgC,IAAV,CAAexC,IAAf;AACD;AACF;;AAED,MAAIQ,SAAS,KAAK8C,SAAlB,EAA6B;AAC3BnF,IAAAA,MAAM,CAAC+B,gBAAP,CAAwBM,SAAxB,EAAmCjC,KAAnC;AACD;AACF;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAAS0B,mBAAT,CAA6BhC,KAA7B,EAAoCwB,UAApC,EAAgDO,IAAhD,EAAsD;AACpD,MAAIA,IAAI,IAAI,IAAZ,EAAkB;AAChB,WAAOA,IAAP;AACD;;AAED,MAAIwD,sBAAsB,GAAG7F,mBAAmB,CAACS,GAApB,EAA7B;AAAA,MACIG,KAAK,GAAGiF,sBAAsB,CAACjF,KADnC;;AAGA,MAAIkF,SAAS,GAAGhE,UAAU,CAACkB,QAAX,CAAoB5C,eAApB,CAAhB;AACA,IAAE,OAAO0F,SAAP,KAAqB,QAAvB,IAAmC1C,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCrD,SAAS,CAAC,KAAD,EAAQ,0DAAR,EAAoEG,eAApE,EAAqF0F,SAArF,CAAjD,GAAmJ7F,SAAS,CAAC,KAAD,CAA/L,GAAyM,KAAK,CAA9M;AACA,MAAImF,MAAM,GAAGxF,gBAAgB,CAACkC,UAAU,CAACJ,SAAX,EAAD,EAAyBd,KAAzB,EAAgCkF,SAAhC,CAA7B;AACA,MAAIC,cAAc,GAAGzF,KAAK,CAACyB,MAAN,CAAaqD,MAAb,EAAqB/C,IAAI,CAACL,OAAL,EAArB,CAArB;AACA+D,EAAAA,cAAc,CAAC9D,cAAf,CAA8BI,IAA9B;;AAEA,MAAI0D,cAAc,CAAC/C,QAAf,CAAwB,QAAxB,KAAqC,IAAzC,EAA+C;AAC7C;AACA;AACA+C,IAAAA,cAAc,CAACxE,QAAf,CAAwB,IAAxB,EAA8B,QAA9B;AACD;;AAEDO,EAAAA,UAAU,CAACP,QAAX,CAAoBuE,SAAS,GAAG,CAAhC,EAAmC1F,eAAnC;AACA,SAAO2F,cAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAAS5C,UAAT,CAAoB6C,WAApB,EAAiCC,WAAjC,EAA8ChD,OAA9C,EAAuD;AACrD,MAAIiD,sBAAsB,GAAGlG,mBAAmB,CAACS,GAApB,EAA7B;AAAA,MACI0E,IAAI,GAAGe,sBAAsB,CAACf,IADlC;;AAGA,OAAK,IAAIR,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGqB,WAAW,CAACpB,MAAlC,EAA0CD,EAAE,EAA5C,EAAgD;AAC9C,QAAItC,IAAI,GAAG2D,WAAW,CAACrB,EAAD,CAAtB;;AAEA,QAAI,CAACtC,IAAL,EAAW;AACT;AACD;;AAED,QAAI2C,IAAI,GAAG3C,IAAI,CAACjB,eAAL,CAAqB+D,IAArB,CAAX;AACA,QAAIM,MAAM,GAAGT,IAAI,IAAIA,IAAI,CAACtD,SAAL,EAArB;;AAEA,QAAI+D,MAAJ,EAAY;AACV,UAAIxC,OAAO,CAACkD,GAAR,CAAYV,MAAZ,CAAJ,EAAyB;AACvB;AACD;;AAEDxC,MAAAA,OAAO,CAACmD,GAAR,CAAYX,MAAZ;AACD;;AAEDQ,IAAAA,WAAW,CAACpB,IAAZ,CAAiBxC,IAAjB;AACD;AACF;;AAEDgE,MAAM,CAACC,OAAP,GAAiB;AACfhE,EAAAA,mBAAmB,EAAEA,mBADN;AAEfyC,EAAAA,UAAU,EAAEA,UAFG;AAGfS,EAAAA,UAAU,EAAEA,UAHG;AAIf3B,EAAAA,aAAa,EAAEA,aAJA;AAKfG,EAAAA,eAAe,EAAEA,eALF;AAMfG,EAAAA,eAAe,EAAEA,eANF;AAOfkB,EAAAA,gBAAgB,EAAEA,gBAPH;AAQfhF,EAAAA,MAAM,EAAEA;AARO,CAAjB","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _require = require('../../store/ClientID'),\n    generateClientID = _require.generateClientID;\n\nvar _require2 = require('../../store/RelayStoreUtils'),\n    getStableStorageKey = _require2.getStableStorageKey;\n\nvar getRelayHandleKey = require('../../util/getRelayHandleKey');\n\nvar ConnectionInterface = require('./ConnectionInterface');\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar CONNECTION = 'connection'; // Per-instance incrementing index used to generate unique edge IDs\n\nvar NEXT_EDGE_INDEX = '__connection_next_edge_index';\n/**\n * @public\n *\n * A default runtime handler for connection fields that appends newly fetched\n * edges onto the end of a connection, regardless of the arguments used to fetch\n * those edges.\n */\n\nfunction update(store, payload) {\n  var record = store.get(payload.dataID);\n\n  if (!record) {\n    return;\n  }\n\n  var _ConnectionInterface$ = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$.EDGES,\n      END_CURSOR = _ConnectionInterface$.END_CURSOR,\n      HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE,\n      HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE,\n      PAGE_INFO = _ConnectionInterface$.PAGE_INFO,\n      PAGE_INFO_TYPE = _ConnectionInterface$.PAGE_INFO_TYPE,\n      START_CURSOR = _ConnectionInterface$.START_CURSOR;\n\n  var serverConnection = record.getLinkedRecord(payload.fieldKey);\n  var serverPageInfo = serverConnection && serverConnection.getLinkedRecord(PAGE_INFO);\n\n  if (!serverConnection) {\n    record.setValue(null, payload.handleKey);\n    return;\n  } // In rare cases the handleKey field may be unset even though the client\n  // connection record exists, in this case new edges should still be merged\n  // into the existing client connection record (and the field reset to point\n  // to that record).\n\n\n  var clientConnectionID = generateClientID(record.getDataID(), payload.handleKey);\n  var clientConnectionField = record.getLinkedRecord(payload.handleKey);\n  var clientConnection = clientConnectionField !== null && clientConnectionField !== void 0 ? clientConnectionField : store.get(clientConnectionID);\n  var clientPageInfo = clientConnection && clientConnection.getLinkedRecord(PAGE_INFO);\n\n  if (!clientConnection) {\n    // Initial fetch with data: copy fields from the server record\n    var connection = store.create(clientConnectionID, serverConnection.getType());\n    connection.setValue(0, NEXT_EDGE_INDEX);\n    connection.copyFieldsFrom(serverConnection);\n    var serverEdges = serverConnection.getLinkedRecords(EDGES);\n\n    if (serverEdges) {\n      serverEdges = serverEdges.map(function (edge) {\n        return buildConnectionEdge(store, connection, edge);\n      });\n      connection.setLinkedRecords(serverEdges, EDGES);\n    }\n\n    record.setLinkedRecord(connection, payload.handleKey);\n    clientPageInfo = store.create(generateClientID(connection.getDataID(), PAGE_INFO), PAGE_INFO_TYPE);\n    clientPageInfo.setValue(false, HAS_NEXT_PAGE);\n    clientPageInfo.setValue(false, HAS_PREV_PAGE);\n    clientPageInfo.setValue(null, END_CURSOR);\n    clientPageInfo.setValue(null, START_CURSOR);\n\n    if (serverPageInfo) {\n      clientPageInfo.copyFieldsFrom(serverPageInfo);\n    }\n\n    connection.setLinkedRecord(clientPageInfo, PAGE_INFO);\n  } else {\n    if (clientConnectionField == null) {\n      // If the handleKey field was unset but the client connection record\n      // existed, update the field to point to the record\n      record.setLinkedRecord(clientConnection, payload.handleKey);\n    }\n\n    var _connection = clientConnection; // Subsequent fetches:\n    // - updated fields on the connection\n    // - merge prev/next edges, de-duplicating by node id\n    // - synthesize page info fields\n\n    var _serverEdges = serverConnection.getLinkedRecords(EDGES);\n\n    if (_serverEdges) {\n      _serverEdges = _serverEdges.map(function (edge) {\n        return buildConnectionEdge(store, _connection, edge);\n      });\n    }\n\n    var prevEdges = _connection.getLinkedRecords(EDGES);\n\n    var prevPageInfo = _connection.getLinkedRecord(PAGE_INFO);\n\n    _connection.copyFieldsFrom(serverConnection); // Reset EDGES and PAGE_INFO fields\n\n\n    if (prevEdges) {\n      _connection.setLinkedRecords(prevEdges, EDGES);\n    }\n\n    if (prevPageInfo) {\n      _connection.setLinkedRecord(prevPageInfo, PAGE_INFO);\n    }\n\n    var nextEdges = [];\n    var args = payload.args;\n\n    if (prevEdges && _serverEdges) {\n      if (args.after != null) {\n        // Forward pagination from the end of the connection: append edges\n        if (clientPageInfo && args.after === clientPageInfo.getValue(END_CURSOR)) {\n          var nodeIDs = new Set();\n          mergeEdges(prevEdges, nextEdges, nodeIDs);\n          mergeEdges(_serverEdges, nextEdges, nodeIDs);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected after cursor `%s`, edges must ' + 'be fetched from the end of the list (`%s`).', args.after, clientPageInfo && clientPageInfo.getValue(END_CURSOR)) : void 0;\n          return;\n        }\n      } else if (args.before != null) {\n        // Backward pagination from the start of the connection: prepend edges\n        if (clientPageInfo && args.before === clientPageInfo.getValue(START_CURSOR)) {\n          var _nodeIDs = new Set();\n\n          mergeEdges(_serverEdges, nextEdges, _nodeIDs);\n          mergeEdges(prevEdges, nextEdges, _nodeIDs);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected before cursor `%s`, edges must ' + 'be fetched from the beginning of the list (`%s`).', args.before, clientPageInfo && clientPageInfo.getValue(START_CURSOR)) : void 0;\n          return;\n        }\n      } else {\n        // The connection was refetched from the beginning/end: replace edges\n        nextEdges = _serverEdges;\n      }\n    } else if (_serverEdges) {\n      nextEdges = _serverEdges;\n    } else {\n      nextEdges = prevEdges;\n    } // Update edges only if they were updated, the null check is\n    // for Flow (prevEdges could be null).\n\n\n    if (nextEdges != null && nextEdges !== prevEdges) {\n      _connection.setLinkedRecords(nextEdges, EDGES);\n    } // Page info should be updated even if no new edge were returned.\n\n\n    if (clientPageInfo && serverPageInfo) {\n      if (args.after == null && args.before == null) {\n        // The connection was refetched from the beginning/end: replace\n        // page_info\n        clientPageInfo.copyFieldsFrom(serverPageInfo);\n      } else if (args.before != null || args.after == null && args.last) {\n        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_PREV_PAGE), HAS_PREV_PAGE);\n        var startCursor = serverPageInfo.getValue(START_CURSOR);\n\n        if (typeof startCursor === 'string') {\n          clientPageInfo.setValue(startCursor, START_CURSOR);\n        }\n      } else if (args.after != null || args.before == null && args.first) {\n        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_NEXT_PAGE), HAS_NEXT_PAGE);\n        var endCursor = serverPageInfo.getValue(END_CURSOR);\n\n        if (typeof endCursor === 'string') {\n          clientPageInfo.setValue(endCursor, END_CURSOR);\n        }\n      }\n    }\n  }\n}\n/**\n * @public\n *\n * Given a record and the name of the schema field for which a connection was\n * fetched, returns the linked connection record.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * The `friends` connection record can be accessed with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   // Access fields on the connection:\n *   const edges = friends.getLinkedRecords('edges');\n * }\n * ```\n *\n * TODO: t15733312\n * Currently we haven't run into this case yet, but we need to add a `getConnections`\n * that returns an array of the connections under the same `key` regardless of the variables.\n */\n\n\nfunction getConnection(record, key, filters) {\n  var handleKey = getRelayHandleKey(CONNECTION, key, null);\n  return record.getLinkedRecord(handleKey, filters);\n}\n/**\n * @public\n *\n * Given a record ID, the key of a connection field, and optional filters used\n * to identify the connection, returns the connection ID.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<user-id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *     edges {\n *       node {\n *         id\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * The ID of the `friends` connection record can be accessed with:\n *\n * ```\n * store => {\n *   const connectionID = ConnectionHandler.getConnectionID('<user-id>', 'FriendsFragment_friends');\n * }\n * ```\n */\n\n\nfunction getConnectionID(recordID, key, filters) {\n  var handleKey = getRelayHandleKey(CONNECTION, key, null);\n  var storageKey = getStableStorageKey(handleKey, filters);\n  return generateClientID(recordID, storageKey);\n}\n/**\n * @public\n *\n * Inserts an edge after the given cursor, or at the end of the list if no\n * cursor is provided.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * An edge can be appended with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   const edge = store.create('<edge-id>', 'FriendsEdge');\n *   ConnectionHandler.insertEdgeAfter(friends, edge);\n * }\n * ```\n */\n\n\nfunction insertEdgeAfter(record, newEdge, cursor) {\n  var _ConnectionInterface$2 = ConnectionInterface.get(),\n      CURSOR = _ConnectionInterface$2.CURSOR,\n      EDGES = _ConnectionInterface$2.EDGES;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    record.setLinkedRecords([newEdge], EDGES);\n    return;\n  }\n\n  var nextEdges;\n\n  if (cursor == null) {\n    nextEdges = edges.concat(newEdge);\n  } else {\n    nextEdges = [];\n    var foundCursor = false;\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n      nextEdges.push(edge);\n\n      if (edge == null) {\n        continue;\n      }\n\n      var edgeCursor = edge.getValue(CURSOR);\n\n      if (cursor === edgeCursor) {\n        nextEdges.push(newEdge);\n        foundCursor = true;\n      }\n    }\n\n    if (!foundCursor) {\n      nextEdges.push(newEdge);\n    }\n  }\n\n  record.setLinkedRecords(nextEdges, EDGES);\n}\n/**\n * @public\n *\n * Creates an edge for a connection record, given a node and edge type.\n */\n\n\nfunction createEdge(store, record, node, edgeType) {\n  var _ConnectionInterface$3 = ConnectionInterface.get(),\n      NODE = _ConnectionInterface$3.NODE; // An index-based client ID could easily conflict (unless it was\n  // auto-incrementing, but there is nowhere to the store the id)\n  // Instead, construct a client ID based on the connection ID and node ID,\n  // which will only conflict if the same node is added to the same connection\n  // twice. This is acceptable since the `insertEdge*` functions ignore\n  // duplicates.\n\n\n  var edgeID = generateClientID(record.getDataID(), node.getDataID());\n  var edge = store.get(edgeID);\n\n  if (!edge) {\n    edge = store.create(edgeID, edgeType);\n  }\n\n  edge.setLinkedRecord(node, NODE);\n\n  if (edge.getValue('cursor') == null) {\n    // Always use null instead of undefined value for cursor\n    // to avoid considering it as missing data\n    edge.setValue(null, 'cursor');\n  }\n\n  return edge;\n}\n/**\n * @public\n *\n * Inserts an edge before the given cursor, or at the beginning of the list if\n * no cursor is provided.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * An edge can be prepended with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   const edge = store.create('<edge-id>', 'FriendsEdge');\n *   ConnectionHandler.insertEdgeBefore(friends, edge);\n * }\n * ```\n */\n\n\nfunction insertEdgeBefore(record, newEdge, cursor) {\n  var _ConnectionInterface$4 = ConnectionInterface.get(),\n      CURSOR = _ConnectionInterface$4.CURSOR,\n      EDGES = _ConnectionInterface$4.EDGES;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    record.setLinkedRecords([newEdge], EDGES);\n    return;\n  }\n\n  var nextEdges;\n\n  if (cursor == null) {\n    nextEdges = [newEdge].concat(edges);\n  } else {\n    nextEdges = [];\n    var foundCursor = false;\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n\n      if (edge != null) {\n        var edgeCursor = edge.getValue(CURSOR);\n\n        if (cursor === edgeCursor) {\n          nextEdges.push(newEdge);\n          foundCursor = true;\n        }\n      }\n\n      nextEdges.push(edge);\n    }\n\n    if (!foundCursor) {\n      nextEdges.unshift(newEdge);\n    }\n  }\n\n  record.setLinkedRecords(nextEdges, EDGES);\n}\n/**\n * @public\n *\n * Remove any edges whose `node.id` matches the given id.\n */\n\n\nfunction deleteNode(record, nodeID) {\n  var _ConnectionInterface$5 = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$5.EDGES,\n      NODE = _ConnectionInterface$5.NODE;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    return;\n  }\n\n  var nextEdges;\n\n  for (var ii = 0; ii < edges.length; ii++) {\n    var edge = edges[ii];\n    var node = edge && edge.getLinkedRecord(NODE);\n\n    if (node != null && node.getDataID() === nodeID) {\n      if (nextEdges === undefined) {\n        nextEdges = edges.slice(0, ii);\n      }\n    } else if (nextEdges !== undefined) {\n      nextEdges.push(edge);\n    }\n  }\n\n  if (nextEdges !== undefined) {\n    record.setLinkedRecords(nextEdges, EDGES);\n  }\n}\n/**\n * @internal\n *\n * Creates a copy of an edge with a unique ID based on per-connection-instance\n * incrementing edge index. This is necessary to avoid collisions between edges,\n * which can occur because (edge) client IDs are assigned deterministically\n * based on the path from the nearest node with an id.\n *\n * Example: if the first N edges of the same connection are refetched, the edges\n * from the second fetch will be assigned the same IDs as the first fetch, even\n * though the nodes they point to may be different (or the same and in different\n * order).\n */\n\n\nfunction buildConnectionEdge(store, connection, edge) {\n  if (edge == null) {\n    return edge;\n  }\n\n  var _ConnectionInterface$6 = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$6.EDGES;\n\n  var edgeIndex = connection.getValue(NEXT_EDGE_INDEX);\n  !(typeof edgeIndex === 'number') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ConnectionHandler: Expected %s to be a number, got `%s`.', NEXT_EDGE_INDEX, edgeIndex) : invariant(false) : void 0;\n  var edgeID = generateClientID(connection.getDataID(), EDGES, edgeIndex);\n  var connectionEdge = store.create(edgeID, edge.getType());\n  connectionEdge.copyFieldsFrom(edge);\n\n  if (connectionEdge.getValue('cursor') == null) {\n    // Always use null instead of undefined value for cursor\n    // to avoid considering it as missing data\n    connectionEdge.setValue(null, 'cursor');\n  }\n\n  connection.setValue(edgeIndex + 1, NEXT_EDGE_INDEX);\n  return connectionEdge;\n}\n/**\n * @internal\n *\n * Adds the source edges to the target edges, skipping edges with\n * duplicate node ids.\n */\n\n\nfunction mergeEdges(sourceEdges, targetEdges, nodeIDs) {\n  var _ConnectionInterface$7 = ConnectionInterface.get(),\n      NODE = _ConnectionInterface$7.NODE;\n\n  for (var ii = 0; ii < sourceEdges.length; ii++) {\n    var edge = sourceEdges[ii];\n\n    if (!edge) {\n      continue;\n    }\n\n    var node = edge.getLinkedRecord(NODE);\n    var nodeID = node && node.getDataID();\n\n    if (nodeID) {\n      if (nodeIDs.has(nodeID)) {\n        continue;\n      }\n\n      nodeIDs.add(nodeID);\n    }\n\n    targetEdges.push(edge);\n  }\n}\n\nmodule.exports = {\n  buildConnectionEdge: buildConnectionEdge,\n  createEdge: createEdge,\n  deleteNode: deleteNode,\n  getConnection: getConnection,\n  getConnectionID: getConnectionID,\n  insertEdgeAfter: insertEdgeAfter,\n  insertEdgeBefore: insertEdgeBefore,\n  update: update\n};"]},"metadata":{},"sourceType":"script"}