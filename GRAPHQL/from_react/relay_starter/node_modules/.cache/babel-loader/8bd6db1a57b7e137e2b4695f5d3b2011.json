{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar loadEntryPoint = require('./loadEntryPoint');\n\nvar _require = require('./loadQuery'),\n    useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;\n\nvar useIsMountedRef = require('./useIsMountedRef');\n\nvar _require2 = require('react'),\n    useCallback = _require2.useCallback,\n    useEffect = _require2.useEffect,\n    useRef = _require2.useRef,\n    useState = _require2.useState;\n\nvar initialNullEntryPointReferenceState = {\n  kind: 'NullEntryPointReference'\n};\n\nfunction useLoadEntryPoint(environmentProvider, entryPoint, options) {\n  var _options$TEST_ONLY__i, _options$TEST_ONLY__i2, _options$TEST_ONLY__i3, _options$TEST_ONLY__i4;\n  /**\n   * We want to always call `entryPointReference.dispose()` for every call to\n   * `setEntryPointReference(loadEntryPoint(...))` so that no leaks of data in Relay\n   * stores will occur.\n   *\n   * However, a call to `setState(newState)` is not always followed by a commit where\n   * this value is reflected in the state. Thus, we cannot reliably clean up each ref\n   * with `useEffect(() => () => entryPointReference.dispose(), [entryPointReference])`.\n   *\n   * Instead, we keep track of each call to `loadEntryPoint` in a ref.\n   * Relying on the fact that if a state change commits, no state changes that were\n   * initiated prior to the currently committing state change will ever subsequently\n   * commit, we can safely dispose of all preloaded entry point references\n   * associated with state changes initiated prior to the currently committing state\n   * change.\n   *\n   * Finally, when the hook unmounts, we also dispose of all remaining uncommitted\n   * entry point references.\n   */\n\n\n  useTrackLoadQueryInRender();\n  var initialEntryPointReferenceInternal = (_options$TEST_ONLY__i = options === null || options === void 0 ? void 0 : (_options$TEST_ONLY__i2 = options.TEST_ONLY__initialEntryPointData) === null || _options$TEST_ONLY__i2 === void 0 ? void 0 : _options$TEST_ONLY__i2.entryPointReference) !== null && _options$TEST_ONLY__i !== void 0 ? _options$TEST_ONLY__i : initialNullEntryPointReferenceState;\n  var initialEntryPointParamsInternal = (_options$TEST_ONLY__i3 = options === null || options === void 0 ? void 0 : (_options$TEST_ONLY__i4 = options.TEST_ONLY__initialEntryPointData) === null || _options$TEST_ONLY__i4 === void 0 ? void 0 : _options$TEST_ONLY__i4.entryPointParams) !== null && _options$TEST_ONLY__i3 !== void 0 ? _options$TEST_ONLY__i3 : null;\n  var isMountedRef = useIsMountedRef();\n  var undisposedEntryPointReferencesRef = useRef(new Set([initialEntryPointReferenceInternal]));\n\n  var _useState = useState(initialEntryPointReferenceInternal),\n      entryPointReference = _useState[0],\n      setEntryPointReference = _useState[1];\n\n  var _useState2 = useState(initialEntryPointParamsInternal),\n      entryPointParams = _useState2[0],\n      setEntryPointParams = _useState2[1];\n\n  var disposeEntryPoint = useCallback(function () {\n    if (isMountedRef.current) {\n      var nullEntryPointReference = {\n        kind: 'NullEntryPointReference'\n      };\n      undisposedEntryPointReferencesRef.current.add(nullEntryPointReference);\n      setEntryPointReference(nullEntryPointReference);\n    }\n  }, [setEntryPointReference, isMountedRef]);\n  var entryPointLoaderCallback = useCallback(function (params) {\n    if (isMountedRef.current) {\n      var updatedEntryPointReference = loadEntryPoint(environmentProvider, entryPoint, params);\n      undisposedEntryPointReferencesRef.current.add(updatedEntryPointReference);\n      setEntryPointReference(updatedEntryPointReference);\n      setEntryPointParams(params);\n    }\n  }, [environmentProvider, entryPoint, setEntryPointReference, isMountedRef]);\n  var maybeHiddenOrFastRefresh = useRef(false);\n  useEffect(function () {\n    return function () {\n      // Attempt to detect if the component was\n      // hidden (by Offscreen API), or fast refresh occured;\n      // Only in these situations would the effect cleanup\n      // for \"unmounting\" run multiple times, so if\n      // we are ever able to read this ref with a value\n      // of true, it means that one of these cases\n      // has happened.\n      maybeHiddenOrFastRefresh.current = true;\n    };\n  }, []);\n  useEffect(function () {\n    if (maybeHiddenOrFastRefresh.current === true) {\n      // This block only runs if the component has previously \"unmounted\"\n      // due to it being hidden by the Offscreen API, or during fast refresh.\n      // At this point, the current entryPointReference will have been disposed\n      // by the previous cleanup, so instead of attempting to\n      // do our regular commit setup, which would incorrectly leave our\n      // current entryPointReference disposed, we need to load the entryPoint again\n      // and force a re-render by calling entryPointLoaderCallback again,\n      // so that the entryPointReference's queries are correctly re-retained, and\n      // potentially refetched if necessary.\n      maybeHiddenOrFastRefresh.current = false;\n\n      if (entryPointReference.kind !== 'NullEntryPointReference' && entryPointParams != null) {\n        entryPointLoaderCallback(entryPointParams);\n      }\n\n      return;\n    } // When a new entryPointReference is committed, we iterate over all\n    // entrypoint refs in undisposedEntryPointReferences and dispose all of\n    // the refs that aren't the currently committed one. This ensures\n    // that we don't leave any dangling entrypoint references for the\n    // case that loadEntryPoint is called multiple times before commit; when\n    // this happens, multiple state updates will be scheduled, but only one\n    // will commit, meaning that we need to keep track of and dispose any\n    // query references that don't end up committing.\n    // - We are relying on the fact that sets iterate in insertion order, and we\n    // can remove items from a set as we iterate over it (i.e. no iterator\n    // invalidation issues.) Thus, it is safe to loop through\n    // undisposedEntryPointReferences until we find entryPointReference, and\n    // remove and dispose all previous references.\n    // - We are guaranteed to find entryPointReference in the set, because if a\n    // state change results in a commit, no state changes initiated prior to that\n    // one will be committed, and we are disposing and removing references\n    // associated with commits that were initiated prior to the currently\n    // committing state change. (A useEffect callback is called during the commit\n    // phase.)\n\n\n    var undisposedEntryPointReferences = undisposedEntryPointReferencesRef.current;\n\n    if (isMountedRef.current) {\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(undisposedEntryPointReferences),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var undisposedEntryPointReference = _step.value;\n\n          if (undisposedEntryPointReference === entryPointReference) {\n            break;\n          }\n\n          undisposedEntryPointReferences[\"delete\"](undisposedEntryPointReference);\n\n          if (undisposedEntryPointReference.kind !== 'NullEntryPointReference') {\n            undisposedEntryPointReference.dispose();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, [entryPointReference, entryPointParams, entryPointLoaderCallback, isMountedRef]);\n  useEffect(function () {\n    return function disposeAllRemainingEntryPointReferences() {\n      // undisposedEntryPointReferences.current is never reassigned\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(undisposedEntryPointReferencesRef.current),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var unhandledStateChange = _step2.value;\n\n          if (unhandledStateChange.kind !== 'NullEntryPointReference') {\n            unhandledStateChange.dispose();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    };\n  }, []);\n  return [entryPointReference.kind === 'NullEntryPointReference' ? null : entryPointReference, entryPointLoaderCallback, disposeEntryPoint];\n}\n\nmodule.exports = useLoadEntryPoint;","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/react-relay/lib/relay-hooks/useEntryPointLoader.js"],"names":["_interopRequireDefault","require","_createForOfIteratorHelper2","loadEntryPoint","_require","useTrackLoadQueryInRender","useIsMountedRef","_require2","useCallback","useEffect","useRef","useState","initialNullEntryPointReferenceState","kind","useLoadEntryPoint","environmentProvider","entryPoint","options","_options$TEST_ONLY__i","_options$TEST_ONLY__i2","_options$TEST_ONLY__i3","_options$TEST_ONLY__i4","initialEntryPointReferenceInternal","TEST_ONLY__initialEntryPointData","entryPointReference","initialEntryPointParamsInternal","entryPointParams","isMountedRef","undisposedEntryPointReferencesRef","Set","_useState","setEntryPointReference","_useState2","setEntryPointParams","disposeEntryPoint","current","nullEntryPointReference","add","entryPointLoaderCallback","params","updatedEntryPointReference","maybeHiddenOrFastRefresh","undisposedEntryPointReferences","_iterator","_step","s","n","done","undisposedEntryPointReference","value","dispose","err","e","f","disposeAllRemainingEntryPointReferences","_iterator2","_step2","unhandledStateChange","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar loadEntryPoint = require('./loadEntryPoint');\n\nvar _require = require('./loadQuery'),\n    useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;\n\nvar useIsMountedRef = require('./useIsMountedRef');\n\nvar _require2 = require('react'),\n    useCallback = _require2.useCallback,\n    useEffect = _require2.useEffect,\n    useRef = _require2.useRef,\n    useState = _require2.useState;\n\nvar initialNullEntryPointReferenceState = {\n  kind: 'NullEntryPointReference'\n};\n\nfunction useLoadEntryPoint(environmentProvider, entryPoint, options) {\n  var _options$TEST_ONLY__i, _options$TEST_ONLY__i2, _options$TEST_ONLY__i3, _options$TEST_ONLY__i4;\n\n  /**\n   * We want to always call `entryPointReference.dispose()` for every call to\n   * `setEntryPointReference(loadEntryPoint(...))` so that no leaks of data in Relay\n   * stores will occur.\n   *\n   * However, a call to `setState(newState)` is not always followed by a commit where\n   * this value is reflected in the state. Thus, we cannot reliably clean up each ref\n   * with `useEffect(() => () => entryPointReference.dispose(), [entryPointReference])`.\n   *\n   * Instead, we keep track of each call to `loadEntryPoint` in a ref.\n   * Relying on the fact that if a state change commits, no state changes that were\n   * initiated prior to the currently committing state change will ever subsequently\n   * commit, we can safely dispose of all preloaded entry point references\n   * associated with state changes initiated prior to the currently committing state\n   * change.\n   *\n   * Finally, when the hook unmounts, we also dispose of all remaining uncommitted\n   * entry point references.\n   */\n  useTrackLoadQueryInRender();\n  var initialEntryPointReferenceInternal = (_options$TEST_ONLY__i = options === null || options === void 0 ? void 0 : (_options$TEST_ONLY__i2 = options.TEST_ONLY__initialEntryPointData) === null || _options$TEST_ONLY__i2 === void 0 ? void 0 : _options$TEST_ONLY__i2.entryPointReference) !== null && _options$TEST_ONLY__i !== void 0 ? _options$TEST_ONLY__i : initialNullEntryPointReferenceState;\n  var initialEntryPointParamsInternal = (_options$TEST_ONLY__i3 = options === null || options === void 0 ? void 0 : (_options$TEST_ONLY__i4 = options.TEST_ONLY__initialEntryPointData) === null || _options$TEST_ONLY__i4 === void 0 ? void 0 : _options$TEST_ONLY__i4.entryPointParams) !== null && _options$TEST_ONLY__i3 !== void 0 ? _options$TEST_ONLY__i3 : null;\n  var isMountedRef = useIsMountedRef();\n  var undisposedEntryPointReferencesRef = useRef(new Set([initialEntryPointReferenceInternal]));\n\n  var _useState = useState(initialEntryPointReferenceInternal),\n      entryPointReference = _useState[0],\n      setEntryPointReference = _useState[1];\n\n  var _useState2 = useState(initialEntryPointParamsInternal),\n      entryPointParams = _useState2[0],\n      setEntryPointParams = _useState2[1];\n\n  var disposeEntryPoint = useCallback(function () {\n    if (isMountedRef.current) {\n      var nullEntryPointReference = {\n        kind: 'NullEntryPointReference'\n      };\n      undisposedEntryPointReferencesRef.current.add(nullEntryPointReference);\n      setEntryPointReference(nullEntryPointReference);\n    }\n  }, [setEntryPointReference, isMountedRef]);\n  var entryPointLoaderCallback = useCallback(function (params) {\n    if (isMountedRef.current) {\n      var updatedEntryPointReference = loadEntryPoint(environmentProvider, entryPoint, params);\n      undisposedEntryPointReferencesRef.current.add(updatedEntryPointReference);\n      setEntryPointReference(updatedEntryPointReference);\n      setEntryPointParams(params);\n    }\n  }, [environmentProvider, entryPoint, setEntryPointReference, isMountedRef]);\n  var maybeHiddenOrFastRefresh = useRef(false);\n  useEffect(function () {\n    return function () {\n      // Attempt to detect if the component was\n      // hidden (by Offscreen API), or fast refresh occured;\n      // Only in these situations would the effect cleanup\n      // for \"unmounting\" run multiple times, so if\n      // we are ever able to read this ref with a value\n      // of true, it means that one of these cases\n      // has happened.\n      maybeHiddenOrFastRefresh.current = true;\n    };\n  }, []);\n  useEffect(function () {\n    if (maybeHiddenOrFastRefresh.current === true) {\n      // This block only runs if the component has previously \"unmounted\"\n      // due to it being hidden by the Offscreen API, or during fast refresh.\n      // At this point, the current entryPointReference will have been disposed\n      // by the previous cleanup, so instead of attempting to\n      // do our regular commit setup, which would incorrectly leave our\n      // current entryPointReference disposed, we need to load the entryPoint again\n      // and force a re-render by calling entryPointLoaderCallback again,\n      // so that the entryPointReference's queries are correctly re-retained, and\n      // potentially refetched if necessary.\n      maybeHiddenOrFastRefresh.current = false;\n\n      if (entryPointReference.kind !== 'NullEntryPointReference' && entryPointParams != null) {\n        entryPointLoaderCallback(entryPointParams);\n      }\n\n      return;\n    } // When a new entryPointReference is committed, we iterate over all\n    // entrypoint refs in undisposedEntryPointReferences and dispose all of\n    // the refs that aren't the currently committed one. This ensures\n    // that we don't leave any dangling entrypoint references for the\n    // case that loadEntryPoint is called multiple times before commit; when\n    // this happens, multiple state updates will be scheduled, but only one\n    // will commit, meaning that we need to keep track of and dispose any\n    // query references that don't end up committing.\n    // - We are relying on the fact that sets iterate in insertion order, and we\n    // can remove items from a set as we iterate over it (i.e. no iterator\n    // invalidation issues.) Thus, it is safe to loop through\n    // undisposedEntryPointReferences until we find entryPointReference, and\n    // remove and dispose all previous references.\n    // - We are guaranteed to find entryPointReference in the set, because if a\n    // state change results in a commit, no state changes initiated prior to that\n    // one will be committed, and we are disposing and removing references\n    // associated with commits that were initiated prior to the currently\n    // committing state change. (A useEffect callback is called during the commit\n    // phase.)\n\n\n    var undisposedEntryPointReferences = undisposedEntryPointReferencesRef.current;\n\n    if (isMountedRef.current) {\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(undisposedEntryPointReferences),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var undisposedEntryPointReference = _step.value;\n\n          if (undisposedEntryPointReference === entryPointReference) {\n            break;\n          }\n\n          undisposedEntryPointReferences[\"delete\"](undisposedEntryPointReference);\n\n          if (undisposedEntryPointReference.kind !== 'NullEntryPointReference') {\n            undisposedEntryPointReference.dispose();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, [entryPointReference, entryPointParams, entryPointLoaderCallback, isMountedRef]);\n  useEffect(function () {\n    return function disposeAllRemainingEntryPointReferences() {\n      // undisposedEntryPointReferences.current is never reassigned\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(undisposedEntryPointReferencesRef.current),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var unhandledStateChange = _step2.value;\n\n          if (unhandledStateChange.kind !== 'NullEntryPointReference') {\n            unhandledStateChange.dispose();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    };\n  }, []);\n  return [entryPointReference.kind === 'NullEntryPointReference' ? null : entryPointReference, entryPointLoaderCallback, disposeEntryPoint];\n}\n\nmodule.exports = useLoadEntryPoint;"]},"metadata":{},"sourceType":"script"}