{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar invariant = require('invariant');\n\nvar React = require('react');\n\nvar _require = require('relay-runtime'),\n    Observable = _require.Observable,\n    PreloadableQueryRegistry = _require.PreloadableQueryRegistry,\n    RelayFeatureFlags = _require.RelayFeatureFlags,\n    ReplaySubject = _require.ReplaySubject,\n    fetchQueryDeduped = _require.__internal.fetchQueryDeduped,\n    createOperationDescriptor = _require.createOperationDescriptor,\n    getRequest = _require.getRequest,\n    getRequestIdentifier = _require.getRequestIdentifier;\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar RenderDispatcher = null;\nvar fetchKey = 100001;\n\nfunction useTrackLoadQueryInRender() {\n  if (RenderDispatcher === null) {\n    var _React$__SECRET_INTER, _React$__SECRET_INTER2; // Flow does not know of React internals (rightly so), but we need to\n    // ensure here that this function isn't called inside render.\n\n\n    RenderDispatcher = // $FlowFixMe[prop-missing]\n    (_React$__SECRET_INTER = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER === void 0 ? void 0 : (_React$__SECRET_INTER2 = _React$__SECRET_INTER.ReactCurrentDispatcher) === null || _React$__SECRET_INTER2 === void 0 ? void 0 : _React$__SECRET_INTER2.current;\n  }\n}\n\nfunction loadQuery(environment, preloadableRequest, variables, options, environmentProviderOptions) {\n  var _React$__SECRET_INTER3, _React$__SECRET_INTER4, _options$__nameForWar, _options$fetchPolicy; // This code ensures that we don't call loadQuery during render.\n\n\n  var CurrentDispatcher = // $FlowFixMe[prop-missing]\n  (_React$__SECRET_INTER3 = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER3 === void 0 ? void 0 : (_React$__SECRET_INTER4 = _React$__SECRET_INTER3.ReactCurrentDispatcher) === null || _React$__SECRET_INTER4 === void 0 ? void 0 : _React$__SECRET_INTER4.current;\n  process.env.NODE_ENV !== \"production\" ? warning(RenderDispatcher == null || CurrentDispatcher !== RenderDispatcher, 'Relay: `%s` should not be called inside a React render function.', (_options$__nameForWar = options === null || options === void 0 ? void 0 : options.__nameForWarning) !== null && _options$__nameForWar !== void 0 ? _options$__nameForWar : 'loadQuery') : void 0; // Every time you call loadQuery, we will generate a new fetchKey.\n  // This will ensure that every query reference that is created and\n  // passed to usePreloadedQuery is independently evaluated,\n  // even if they are for the same query/variables.\n  // Specifically, we want to avoid a case where we try to refetch a\n  // query by calling loadQuery a second time, and have the Suspense\n  // cache in usePreloadedQuery reuse the cached result instead of\n  // re-evaluating the new query ref and triggering a refetch if\n  // necessary.\n\n  fetchKey++;\n  var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : 'store-or-network';\n  var networkCacheConfig = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, options === null || options === void 0 ? void 0 : options.networkCacheConfig), {}, {\n    force: true\n  }); // executeWithNetworkSource will retain and execute an operation\n  // against the Relay store, given an Observable that would provide\n  // the network events for the operation.\n\n  var retainReference;\n  var didExecuteNetworkSource = false;\n\n  var executeWithNetworkSource = function executeWithNetworkSource(operation, networkObservable) {\n    didExecuteNetworkSource = true;\n    return environment.executeWithSource({\n      operation: operation,\n      source: networkObservable\n    });\n  }; // N.B. For loadQuery, we unconventionally want to return an Observable\n  // that isn't lazily executed, meaning that we don't want to wait\n  // until the returned Observable is subscribed to to actually start\n  // fetching and executing an operation; i.e. we want to execute the\n  // operation eagerly, when loadQuery is called.\n  // For this reason, we use an intermediate executionSubject which\n  // allows us to capture the events that occur during the eager execution\n  // of the operation, and then replay them to the Observable we\n  // ultimately return.\n\n\n  var executionSubject = new ReplaySubject();\n  var returnedObservable = Observable.create(function (sink) {\n    return executionSubject.subscribe(sink);\n  });\n  var unsubscribeFromNetworkRequest;\n  var networkError = null; // makeNetworkRequest will immediately start a raw network request if\n  // one isn't already in flight and return an Observable that when\n  // subscribed to will replay the network events that have occured so far,\n  // as well as subsequent events.\n\n  var didMakeNetworkRequest = false;\n\n  var makeNetworkRequest = function makeNetworkRequest(params) {\n    // N.B. this function is called synchronously or not at all\n    // didMakeNetworkRequest is safe to rely on in the returned value\n    // Even if the request gets deduped below, we still wan't to return an\n    // observable that provides the replayed network events for the query,\n    // so we set this to true before deduping, to guarantee that the\n    // `source` observable is returned.\n    didMakeNetworkRequest = true;\n    var observable;\n    var subject = new ReplaySubject();\n\n    if (RelayFeatureFlags.ENABLE_LOAD_QUERY_REQUEST_DEDUPING === true) {\n      // Here, we are calling fetchQueryDeduped at the network layer level,\n      // which ensures that only a single network request is active for a given\n      // (environment, identifier) pair.\n      // Since network requests can be started /before/ we have the query ast\n      // necessary to process the results, we need to dedupe the raw requests\n      // separately from deduping the operation execution; specifically,\n      // if `loadQuery` is called multiple times before the query ast is available,\n      // we still want the network request to be deduped.\n      // - If a duplicate active network request is found, it will return an\n      // Observable that replays the events of the already active request.\n      // - If no duplicate active network request is found, it will call the fetchFn\n      // to start the request, and return an Observable that will replay\n      // the events from the network request.\n      // We provide an extra key to the identifier to distinguish deduping\n      // of raw network requests vs deduping of operation executions.\n      var identifier = 'raw-network-request-' + getRequestIdentifier(params, variables);\n      observable = fetchQueryDeduped(environment, identifier, function () {\n        var network = environment.getNetwork();\n        return network.execute(params, variables, networkCacheConfig);\n      });\n    } else {\n      var network = environment.getNetwork();\n      observable = network.execute(params, variables, networkCacheConfig);\n    }\n\n    var _observable$subscribe = observable.subscribe({\n      error: function error(err) {\n        networkError = err;\n        subject.error(err);\n      },\n      next: function next(data) {\n        subject.next(data);\n      },\n      complete: function complete() {\n        subject.complete();\n      }\n    }),\n        unsubscribe = _observable$subscribe.unsubscribe;\n\n    unsubscribeFromNetworkRequest = unsubscribe;\n    return Observable.create(function (sink) {\n      var subjectSubscription = subject.subscribe(sink);\n      return function () {\n        subjectSubscription.unsubscribe();\n        unsubscribeFromNetworkRequest();\n      };\n    });\n  };\n\n  var unsubscribeFromExecution;\n\n  var executeDeduped = function executeDeduped(operation, fetchFn) {\n    if (RelayFeatureFlags.ENABLE_LOAD_QUERY_REQUEST_DEDUPING === true) {\n      // N.B. at this point, if we're calling execute with a query ast (OperationDescriptor),\n      // we are guaranteed to have started a network request. We set this to\n      // true here as well since `makeNetworkRequest` might get skipped in the case\n      // where the query ast is already available and the query executions get deduped.\n      // Even if the execution gets deduped below, we still wan't to return\n      // an observable that provides the replayed network events for the query,\n      // so we set this to true before deduping, to guarantee that the `source`\n      // observable is returned.\n      didMakeNetworkRequest = true;\n    } // Here, we are calling fetchQueryDeduped, which ensures that only\n    // a single operation is active for a given (environment, identifier) pair,\n    // and also tracks the active state of the operation, which is necessary\n    // for our Suspense infra to later be able to suspend (or not) on\n    // active operations. Even though we already dedupe raw network requests,\n    // we also need to dedupe and keep track operation execution for our Suspense\n    // infra, and we also want to avoid processing responses more than once, for\n    // the cases where `loadQuery` might be called multiple times after the query ast\n    // is available.\n    // - If a duplicate active operation is found, it will return an\n    // Observable that replays the events of the already active operation.\n    // - If no duplicate active operation is found, it will call the fetchFn\n    // to execute the operation, and return an Observable that will provide\n    // the events for executing the operation.\n\n\n    var _fetchQueryDeduped$su = fetchQueryDeduped(environment, operation.request.identifier, fetchFn).subscribe({\n      error: function error(err) {\n        executionSubject.error(err);\n      },\n      next: function next(data) {\n        executionSubject.next(data);\n      },\n      complete: function complete() {\n        executionSubject.complete();\n      }\n    });\n\n    unsubscribeFromExecution = _fetchQueryDeduped$su.unsubscribe;\n  };\n\n  var checkAvailabilityAndExecute = function checkAvailabilityAndExecute(concreteRequest) {\n    var operation = createOperationDescriptor(concreteRequest, variables, networkCacheConfig);\n    retainReference = environment.retain(operation);\n\n    if (fetchPolicy === 'store-only') {\n      return;\n    } // N.B. If the fetch policy allows fulfillment from the store but the\n    // environment already has the data for that operation cached in the store,\n    // then we do nothing.\n\n\n    var shouldFetch = fetchPolicy !== 'store-or-network' || environment.check(operation).status !== 'available';\n\n    if (shouldFetch) {\n      executeDeduped(operation, function () {\n        // N.B. Since we have the operation synchronously available here,\n        // we can immediately fetch and execute the operation.\n        var networkObservable = makeNetworkRequest(concreteRequest.params);\n        var executeObservable = executeWithNetworkSource(operation, networkObservable);\n        return executeObservable;\n      });\n    }\n  };\n\n  var params;\n  var cancelOnLoadCallback;\n  var queryId;\n\n  if (preloadableRequest.kind === 'PreloadableConcreteRequest') {\n    var preloadableConcreteRequest = preloadableRequest;\n    params = preloadableConcreteRequest.params;\n    var _params = params;\n    queryId = _params.id;\n    !(queryId !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: `loadQuery` requires that preloadable query `%s` has a persisted query id', params.name) : invariant(false) : void 0;\n\n    var _module = PreloadableQueryRegistry.get(queryId);\n\n    if (_module != null) {\n      checkAvailabilityAndExecute(_module);\n    } else {\n      // If the module isn't synchronously available, we launch the\n      // network request immediately if the fetchPolicy might produce\n      // a network fetch, regardless of the state of the store cache. We\n      // do this because we can't check if a query is cached without the\n      // ast, and we know that if we don't have the query ast\n      // available, then this query could've never been written to the\n      // store in the first place, so it couldn't have been cached.\n      var networkObservable = fetchPolicy === 'store-only' ? null : makeNetworkRequest(params); // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n\n      var _PreloadableQueryRegi = PreloadableQueryRegistry.onLoad(queryId, function (preloadedModule) {\n        cancelOnLoadCallback();\n        var operation = createOperationDescriptor(preloadedModule, variables, networkCacheConfig);\n        retainReference = environment.retain(operation);\n\n        if (networkObservable != null) {\n          executeDeduped(operation, function () {\n            return executeWithNetworkSource(operation, networkObservable);\n          });\n        }\n      });\n\n      cancelOnLoadCallback = _PreloadableQueryRegi.dispose;\n    }\n  } else {\n    var graphQlTaggedNode = preloadableRequest;\n    var request = getRequest(graphQlTaggedNode);\n    params = request.params;\n    queryId = params.cacheID != null ? params.cacheID : params.id;\n    checkAvailabilityAndExecute(request);\n  }\n\n  var isDisposed = false;\n  var isReleased = false;\n  var isNetworkRequestCancelled = false;\n\n  var releaseQuery = function releaseQuery() {\n    if (isReleased) {\n      return;\n    }\n\n    retainReference && retainReference.dispose();\n    isReleased = true;\n  };\n\n  var cancelNetworkRequest = function cancelNetworkRequest() {\n    if (isNetworkRequestCancelled) {\n      return;\n    }\n\n    if (didExecuteNetworkSource) {\n      unsubscribeFromExecution && unsubscribeFromExecution();\n    } else {\n      unsubscribeFromNetworkRequest && unsubscribeFromNetworkRequest();\n    }\n\n    cancelOnLoadCallback && cancelOnLoadCallback();\n    isNetworkRequestCancelled = true;\n  };\n\n  return {\n    kind: 'PreloadedQuery',\n    environment: environment,\n    environmentProviderOptions: environmentProviderOptions,\n    dispose: function dispose() {\n      if (isDisposed) {\n        return;\n      }\n\n      releaseQuery();\n      cancelNetworkRequest();\n      isDisposed = true;\n    },\n    releaseQuery: releaseQuery,\n    cancelNetworkRequest: cancelNetworkRequest,\n    fetchKey: fetchKey,\n    id: queryId,\n\n    // $FlowFixMe[unsafe-getters-setters] - this has no side effects\n    get isDisposed() {\n      return isDisposed || isReleased;\n    },\n\n    // $FlowFixMe[unsafe-getters-setters] - this has no side effects\n    get networkError() {\n      return networkError;\n    },\n\n    name: params.name,\n    networkCacheConfig: networkCacheConfig,\n    fetchPolicy: fetchPolicy,\n    source: didMakeNetworkRequest ? returnedObservable : undefined,\n    variables: variables\n  };\n}\n\nmodule.exports = {\n  loadQuery: loadQuery,\n  useTrackLoadQueryInRender: useTrackLoadQueryInRender\n};","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/react-relay/lib/relay-hooks/loadQuery.js"],"names":["_interopRequireDefault","require","_objectSpread2","invariant","React","_require","Observable","PreloadableQueryRegistry","RelayFeatureFlags","ReplaySubject","fetchQueryDeduped","__internal","createOperationDescriptor","getRequest","getRequestIdentifier","warning","RenderDispatcher","fetchKey","useTrackLoadQueryInRender","_React$__SECRET_INTER","_React$__SECRET_INTER2","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","current","loadQuery","environment","preloadableRequest","variables","options","environmentProviderOptions","_React$__SECRET_INTER3","_React$__SECRET_INTER4","_options$__nameForWar","_options$fetchPolicy","CurrentDispatcher","process","env","NODE_ENV","__nameForWarning","fetchPolicy","networkCacheConfig","force","retainReference","didExecuteNetworkSource","executeWithNetworkSource","operation","networkObservable","executeWithSource","source","executionSubject","returnedObservable","create","sink","subscribe","unsubscribeFromNetworkRequest","networkError","didMakeNetworkRequest","makeNetworkRequest","params","observable","subject","ENABLE_LOAD_QUERY_REQUEST_DEDUPING","identifier","network","getNetwork","execute","_observable$subscribe","error","err","next","data","complete","unsubscribe","subjectSubscription","unsubscribeFromExecution","executeDeduped","fetchFn","_fetchQueryDeduped$su","request","checkAvailabilityAndExecute","concreteRequest","retain","shouldFetch","check","status","executeObservable","cancelOnLoadCallback","queryId","kind","preloadableConcreteRequest","_params","id","name","_module","get","_PreloadableQueryRegi","onLoad","preloadedModule","dispose","graphQlTaggedNode","cacheID","isDisposed","isReleased","isNetworkRequestCancelled","releaseQuery","cancelNetworkRequest","undefined","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar invariant = require('invariant');\n\nvar React = require('react');\n\nvar _require = require('relay-runtime'),\n    Observable = _require.Observable,\n    PreloadableQueryRegistry = _require.PreloadableQueryRegistry,\n    RelayFeatureFlags = _require.RelayFeatureFlags,\n    ReplaySubject = _require.ReplaySubject,\n    fetchQueryDeduped = _require.__internal.fetchQueryDeduped,\n    createOperationDescriptor = _require.createOperationDescriptor,\n    getRequest = _require.getRequest,\n    getRequestIdentifier = _require.getRequestIdentifier;\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar RenderDispatcher = null;\nvar fetchKey = 100001;\n\nfunction useTrackLoadQueryInRender() {\n  if (RenderDispatcher === null) {\n    var _React$__SECRET_INTER, _React$__SECRET_INTER2;\n\n    // Flow does not know of React internals (rightly so), but we need to\n    // ensure here that this function isn't called inside render.\n    RenderDispatcher = // $FlowFixMe[prop-missing]\n    (_React$__SECRET_INTER = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER === void 0 ? void 0 : (_React$__SECRET_INTER2 = _React$__SECRET_INTER.ReactCurrentDispatcher) === null || _React$__SECRET_INTER2 === void 0 ? void 0 : _React$__SECRET_INTER2.current;\n  }\n}\n\nfunction loadQuery(environment, preloadableRequest, variables, options, environmentProviderOptions) {\n  var _React$__SECRET_INTER3, _React$__SECRET_INTER4, _options$__nameForWar, _options$fetchPolicy;\n\n  // This code ensures that we don't call loadQuery during render.\n  var CurrentDispatcher = // $FlowFixMe[prop-missing]\n  (_React$__SECRET_INTER3 = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER3 === void 0 ? void 0 : (_React$__SECRET_INTER4 = _React$__SECRET_INTER3.ReactCurrentDispatcher) === null || _React$__SECRET_INTER4 === void 0 ? void 0 : _React$__SECRET_INTER4.current;\n  process.env.NODE_ENV !== \"production\" ? warning(RenderDispatcher == null || CurrentDispatcher !== RenderDispatcher, 'Relay: `%s` should not be called inside a React render function.', (_options$__nameForWar = options === null || options === void 0 ? void 0 : options.__nameForWarning) !== null && _options$__nameForWar !== void 0 ? _options$__nameForWar : 'loadQuery') : void 0; // Every time you call loadQuery, we will generate a new fetchKey.\n  // This will ensure that every query reference that is created and\n  // passed to usePreloadedQuery is independently evaluated,\n  // even if they are for the same query/variables.\n  // Specifically, we want to avoid a case where we try to refetch a\n  // query by calling loadQuery a second time, and have the Suspense\n  // cache in usePreloadedQuery reuse the cached result instead of\n  // re-evaluating the new query ref and triggering a refetch if\n  // necessary.\n\n  fetchKey++;\n  var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : 'store-or-network';\n  var networkCacheConfig = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, options === null || options === void 0 ? void 0 : options.networkCacheConfig), {}, {\n    force: true\n  }); // executeWithNetworkSource will retain and execute an operation\n  // against the Relay store, given an Observable that would provide\n  // the network events for the operation.\n\n  var retainReference;\n  var didExecuteNetworkSource = false;\n\n  var executeWithNetworkSource = function executeWithNetworkSource(operation, networkObservable) {\n    didExecuteNetworkSource = true;\n    return environment.executeWithSource({\n      operation: operation,\n      source: networkObservable\n    });\n  }; // N.B. For loadQuery, we unconventionally want to return an Observable\n  // that isn't lazily executed, meaning that we don't want to wait\n  // until the returned Observable is subscribed to to actually start\n  // fetching and executing an operation; i.e. we want to execute the\n  // operation eagerly, when loadQuery is called.\n  // For this reason, we use an intermediate executionSubject which\n  // allows us to capture the events that occur during the eager execution\n  // of the operation, and then replay them to the Observable we\n  // ultimately return.\n\n\n  var executionSubject = new ReplaySubject();\n  var returnedObservable = Observable.create(function (sink) {\n    return executionSubject.subscribe(sink);\n  });\n  var unsubscribeFromNetworkRequest;\n  var networkError = null; // makeNetworkRequest will immediately start a raw network request if\n  // one isn't already in flight and return an Observable that when\n  // subscribed to will replay the network events that have occured so far,\n  // as well as subsequent events.\n\n  var didMakeNetworkRequest = false;\n\n  var makeNetworkRequest = function makeNetworkRequest(params) {\n    // N.B. this function is called synchronously or not at all\n    // didMakeNetworkRequest is safe to rely on in the returned value\n    // Even if the request gets deduped below, we still wan't to return an\n    // observable that provides the replayed network events for the query,\n    // so we set this to true before deduping, to guarantee that the\n    // `source` observable is returned.\n    didMakeNetworkRequest = true;\n    var observable;\n    var subject = new ReplaySubject();\n\n    if (RelayFeatureFlags.ENABLE_LOAD_QUERY_REQUEST_DEDUPING === true) {\n      // Here, we are calling fetchQueryDeduped at the network layer level,\n      // which ensures that only a single network request is active for a given\n      // (environment, identifier) pair.\n      // Since network requests can be started /before/ we have the query ast\n      // necessary to process the results, we need to dedupe the raw requests\n      // separately from deduping the operation execution; specifically,\n      // if `loadQuery` is called multiple times before the query ast is available,\n      // we still want the network request to be deduped.\n      // - If a duplicate active network request is found, it will return an\n      // Observable that replays the events of the already active request.\n      // - If no duplicate active network request is found, it will call the fetchFn\n      // to start the request, and return an Observable that will replay\n      // the events from the network request.\n      // We provide an extra key to the identifier to distinguish deduping\n      // of raw network requests vs deduping of operation executions.\n      var identifier = 'raw-network-request-' + getRequestIdentifier(params, variables);\n      observable = fetchQueryDeduped(environment, identifier, function () {\n        var network = environment.getNetwork();\n        return network.execute(params, variables, networkCacheConfig);\n      });\n    } else {\n      var network = environment.getNetwork();\n      observable = network.execute(params, variables, networkCacheConfig);\n    }\n\n    var _observable$subscribe = observable.subscribe({\n      error: function error(err) {\n        networkError = err;\n        subject.error(err);\n      },\n      next: function next(data) {\n        subject.next(data);\n      },\n      complete: function complete() {\n        subject.complete();\n      }\n    }),\n        unsubscribe = _observable$subscribe.unsubscribe;\n\n    unsubscribeFromNetworkRequest = unsubscribe;\n    return Observable.create(function (sink) {\n      var subjectSubscription = subject.subscribe(sink);\n      return function () {\n        subjectSubscription.unsubscribe();\n        unsubscribeFromNetworkRequest();\n      };\n    });\n  };\n\n  var unsubscribeFromExecution;\n\n  var executeDeduped = function executeDeduped(operation, fetchFn) {\n    if (RelayFeatureFlags.ENABLE_LOAD_QUERY_REQUEST_DEDUPING === true) {\n      // N.B. at this point, if we're calling execute with a query ast (OperationDescriptor),\n      // we are guaranteed to have started a network request. We set this to\n      // true here as well since `makeNetworkRequest` might get skipped in the case\n      // where the query ast is already available and the query executions get deduped.\n      // Even if the execution gets deduped below, we still wan't to return\n      // an observable that provides the replayed network events for the query,\n      // so we set this to true before deduping, to guarantee that the `source`\n      // observable is returned.\n      didMakeNetworkRequest = true;\n    } // Here, we are calling fetchQueryDeduped, which ensures that only\n    // a single operation is active for a given (environment, identifier) pair,\n    // and also tracks the active state of the operation, which is necessary\n    // for our Suspense infra to later be able to suspend (or not) on\n    // active operations. Even though we already dedupe raw network requests,\n    // we also need to dedupe and keep track operation execution for our Suspense\n    // infra, and we also want to avoid processing responses more than once, for\n    // the cases where `loadQuery` might be called multiple times after the query ast\n    // is available.\n    // - If a duplicate active operation is found, it will return an\n    // Observable that replays the events of the already active operation.\n    // - If no duplicate active operation is found, it will call the fetchFn\n    // to execute the operation, and return an Observable that will provide\n    // the events for executing the operation.\n\n\n    var _fetchQueryDeduped$su = fetchQueryDeduped(environment, operation.request.identifier, fetchFn).subscribe({\n      error: function error(err) {\n        executionSubject.error(err);\n      },\n      next: function next(data) {\n        executionSubject.next(data);\n      },\n      complete: function complete() {\n        executionSubject.complete();\n      }\n    });\n\n    unsubscribeFromExecution = _fetchQueryDeduped$su.unsubscribe;\n  };\n\n  var checkAvailabilityAndExecute = function checkAvailabilityAndExecute(concreteRequest) {\n    var operation = createOperationDescriptor(concreteRequest, variables, networkCacheConfig);\n    retainReference = environment.retain(operation);\n\n    if (fetchPolicy === 'store-only') {\n      return;\n    } // N.B. If the fetch policy allows fulfillment from the store but the\n    // environment already has the data for that operation cached in the store,\n    // then we do nothing.\n\n\n    var shouldFetch = fetchPolicy !== 'store-or-network' || environment.check(operation).status !== 'available';\n\n    if (shouldFetch) {\n      executeDeduped(operation, function () {\n        // N.B. Since we have the operation synchronously available here,\n        // we can immediately fetch and execute the operation.\n        var networkObservable = makeNetworkRequest(concreteRequest.params);\n        var executeObservable = executeWithNetworkSource(operation, networkObservable);\n        return executeObservable;\n      });\n    }\n  };\n\n  var params;\n  var cancelOnLoadCallback;\n  var queryId;\n\n  if (preloadableRequest.kind === 'PreloadableConcreteRequest') {\n    var preloadableConcreteRequest = preloadableRequest;\n    params = preloadableConcreteRequest.params;\n    var _params = params;\n    queryId = _params.id;\n    !(queryId !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: `loadQuery` requires that preloadable query `%s` has a persisted query id', params.name) : invariant(false) : void 0;\n\n    var _module = PreloadableQueryRegistry.get(queryId);\n\n    if (_module != null) {\n      checkAvailabilityAndExecute(_module);\n    } else {\n      // If the module isn't synchronously available, we launch the\n      // network request immediately if the fetchPolicy might produce\n      // a network fetch, regardless of the state of the store cache. We\n      // do this because we can't check if a query is cached without the\n      // ast, and we know that if we don't have the query ast\n      // available, then this query could've never been written to the\n      // store in the first place, so it couldn't have been cached.\n      var networkObservable = fetchPolicy === 'store-only' ? null : makeNetworkRequest(params); // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n\n      var _PreloadableQueryRegi = PreloadableQueryRegistry.onLoad(queryId, function (preloadedModule) {\n        cancelOnLoadCallback();\n        var operation = createOperationDescriptor(preloadedModule, variables, networkCacheConfig);\n        retainReference = environment.retain(operation);\n\n        if (networkObservable != null) {\n          executeDeduped(operation, function () {\n            return executeWithNetworkSource(operation, networkObservable);\n          });\n        }\n      });\n\n      cancelOnLoadCallback = _PreloadableQueryRegi.dispose;\n    }\n  } else {\n    var graphQlTaggedNode = preloadableRequest;\n    var request = getRequest(graphQlTaggedNode);\n    params = request.params;\n    queryId = params.cacheID != null ? params.cacheID : params.id;\n    checkAvailabilityAndExecute(request);\n  }\n\n  var isDisposed = false;\n  var isReleased = false;\n  var isNetworkRequestCancelled = false;\n\n  var releaseQuery = function releaseQuery() {\n    if (isReleased) {\n      return;\n    }\n\n    retainReference && retainReference.dispose();\n    isReleased = true;\n  };\n\n  var cancelNetworkRequest = function cancelNetworkRequest() {\n    if (isNetworkRequestCancelled) {\n      return;\n    }\n\n    if (didExecuteNetworkSource) {\n      unsubscribeFromExecution && unsubscribeFromExecution();\n    } else {\n      unsubscribeFromNetworkRequest && unsubscribeFromNetworkRequest();\n    }\n\n    cancelOnLoadCallback && cancelOnLoadCallback();\n    isNetworkRequestCancelled = true;\n  };\n\n  return {\n    kind: 'PreloadedQuery',\n    environment: environment,\n    environmentProviderOptions: environmentProviderOptions,\n    dispose: function dispose() {\n      if (isDisposed) {\n        return;\n      }\n\n      releaseQuery();\n      cancelNetworkRequest();\n      isDisposed = true;\n    },\n    releaseQuery: releaseQuery,\n    cancelNetworkRequest: cancelNetworkRequest,\n    fetchKey: fetchKey,\n    id: queryId,\n\n    // $FlowFixMe[unsafe-getters-setters] - this has no side effects\n    get isDisposed() {\n      return isDisposed || isReleased;\n    },\n\n    // $FlowFixMe[unsafe-getters-setters] - this has no side effects\n    get networkError() {\n      return networkError;\n    },\n\n    name: params.name,\n    networkCacheConfig: networkCacheConfig,\n    fetchPolicy: fetchPolicy,\n    source: didMakeNetworkRequest ? returnedObservable : undefined,\n    variables: variables\n  };\n}\n\nmodule.exports = {\n  loadQuery: loadQuery,\n  useTrackLoadQueryInRender: useTrackLoadQueryInRender\n};"]},"metadata":{},"sourceType":"script"}