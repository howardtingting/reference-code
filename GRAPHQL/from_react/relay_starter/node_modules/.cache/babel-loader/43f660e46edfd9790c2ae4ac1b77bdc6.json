{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar Observable = require('../network/RelayObservable');\n\nvar RelayReplaySubject = require('../util/RelayReplaySubject');\n\nvar invariant = require('invariant');\n\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\nvar requestCachesByEnvironment = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n/**\n * Fetches the given query and variables on the provided environment,\n * and de-dupes identical in-flight requests.\n *\n * Observing a request:\n * ====================\n * fetchQuery returns an Observable which you can call .subscribe()\n * on. subscribe() takes an Observer, which you can provide to\n * observe network events:\n *\n * ```\n * fetchQuery(environment, query, variables).subscribe({\n *   // Called when network requests starts\n *   start: (subscription) => {},\n *\n *   // Called after a payload is received and written to the local store\n *   next: (payload) => {},\n *\n *   // Called when network requests errors\n *   error: (error) => {},\n *\n *   // Called when network requests fully completes\n *   complete: () => {},\n *\n *   // Called when network request is unsubscribed\n *   unsubscribe: (subscription) => {},\n * });\n * ```\n *\n * In-flight request de-duping:\n * ============================\n * By default, calling fetchQuery multiple times with the same\n * environment, query and variables will not initiate a new request if a request\n * for those same parameters is already in flight.\n *\n * A request is marked in-flight from the moment it starts until the moment it\n * fully completes, regardless of error or successful completion.\n *\n * NOTE: If the request completes _synchronously_, calling fetchQuery\n * a second time with the same arguments in the same tick will _NOT_ de-dupe\n * the request given that it will no longer be in-flight.\n *\n *\n * Data Retention:\n * ===============\n * This function will not retain any query data outside the scope of the\n * request, which means it is not guaranteed that it won't be garbage\n * collected after the request completes.\n * If you need to retain data, you can do so manually with environment.retain().\n *\n * Cancelling requests:\n * ====================\n * If the subscription returned by subscribe is called while the\n * request is in-flight, the request will be cancelled.\n *\n * ```\n * const subscription = fetchQuery(...).subscribe(...);\n *\n * // This will cancel the request if it is in-flight.\n * subscription.unsubscribe();\n * ```\n */\n\nfunction fetchQuery(environment, operation) {\n  return fetchQueryDeduped(environment, operation.request.identifier, function () {\n    return environment.execute({\n      operation: operation\n    });\n  });\n}\n/**\n * Low-level implementation details of `fetchQuery`.\n *\n * `fetchQueryDeduped` can also be used to share a single cache for\n * requests that aren't using `fetchQuery` directly (e.g. because they don't\n * have an `OperationDescriptor` when they are called).\n */\n\n\nfunction fetchQueryDeduped(environment, identifier, fetchFn) {\n  return Observable.create(function (sink) {\n    var requestCache = getRequestCache(environment);\n    var cachedRequest = requestCache.get(identifier);\n\n    if (!cachedRequest) {\n      fetchFn()[\"finally\"](function () {\n        return requestCache[\"delete\"](identifier);\n      }).subscribe({\n        start: function start(subscription) {\n          cachedRequest = {\n            identifier: identifier,\n            subject: new RelayReplaySubject(),\n            subjectForInFlightStatus: new RelayReplaySubject(),\n            subscription: subscription\n          };\n          requestCache.set(identifier, cachedRequest);\n        },\n        next: function next(response) {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.next(response);\n          cachedReq.subjectForInFlightStatus.next(response);\n        },\n        error: function error(_error) {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.error(_error);\n          cachedReq.subjectForInFlightStatus.error(_error);\n        },\n        complete: function complete() {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.complete();\n          cachedReq.subjectForInFlightStatus.complete();\n        },\n        unsubscribe: function unsubscribe(subscription) {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.unsubscribe();\n          cachedReq.subjectForInFlightStatus.unsubscribe();\n        }\n      });\n    }\n\n    !(cachedRequest != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, '[fetchQueryInternal] fetchQueryDeduped: Expected `start` to be ' + 'called synchronously') : invariant(false) : void 0;\n    return getObservableForCachedRequest(requestCache, cachedRequest).subscribe(sink);\n  });\n}\n/**\n * @private\n */\n\n\nfunction getObservableForCachedRequest(requestCache, cachedRequest) {\n  return Observable.create(function (sink) {\n    var subscription = cachedRequest.subject.subscribe(sink);\n    return function () {\n      subscription.unsubscribe();\n      var cachedRequestInstance = requestCache.get(cachedRequest.identifier);\n\n      if (cachedRequestInstance) {\n        var requestSubscription = cachedRequestInstance.subscription;\n\n        if (requestSubscription != null && cachedRequestInstance.subject.getObserverCount() === 0) {\n          requestSubscription.unsubscribe();\n          requestCache[\"delete\"](cachedRequest.identifier);\n        }\n      }\n    };\n  });\n}\n/**\n * @private\n */\n\n\nfunction getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest) {\n  return Observable.create(function (sink) {\n    var subscription = cachedRequest.subjectForInFlightStatus.subscribe({\n      error: sink.error,\n      next: function next(response) {\n        if (!environment.isRequestActive(cachedRequest.identifier)) {\n          sink.complete();\n          return;\n        }\n\n        sink.next();\n      },\n      complete: sink.complete,\n      unsubscribe: sink.complete\n    });\n    return function () {\n      subscription.unsubscribe();\n    };\n  });\n}\n/**\n * If a request is active for the given query, variables and environment,\n * this function will return a Promise that will resolve when that request\n * stops being active (receives a final payload), and the data has been saved\n * to the store.\n * If no request is active, null will be returned\n */\n\n\nfunction getPromiseForActiveRequest(environment, request) {\n  var requestCache = getRequestCache(environment);\n  var cachedRequest = requestCache.get(request.identifier);\n\n  if (!cachedRequest) {\n    return null;\n  }\n\n  if (!environment.isRequestActive(cachedRequest.identifier)) {\n    return null;\n  }\n\n  return new Promise(function (resolve, reject) {\n    var resolveOnNext = false;\n    getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest).subscribe({\n      complete: resolve,\n      error: reject,\n      next: function next(response) {\n        /*\n         * The underlying `RelayReplaySubject` will synchronously replay events\n         * as soon as we subscribe, but since we want the *next* asynchronous\n         * one, we'll ignore them until the replay finishes.\n         */\n        if (resolveOnNext) {\n          resolve(response);\n        }\n      }\n    });\n    resolveOnNext = true;\n  });\n}\n/**\n * If there is a pending request for the given query, returns an Observable of\n * *all* its responses. Existing responses are published synchronously and\n * subsequent responses are published asynchronously. Returns null if there is\n * no pending request. This is similar to fetchQuery() except that it will not\n * issue a fetch if there isn't already one pending.\n */\n\n\nfunction getObservableForActiveRequest(environment, request) {\n  var requestCache = getRequestCache(environment);\n  var cachedRequest = requestCache.get(request.identifier);\n\n  if (!cachedRequest) {\n    return null;\n  }\n\n  if (!environment.isRequestActive(cachedRequest.identifier)) {\n    return null;\n  }\n\n  return getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest);\n}\n/**\n * @private\n */\n\n\nfunction getRequestCache(environment) {\n  var cached = requestCachesByEnvironment.get(environment);\n\n  if (cached != null) {\n    return cached;\n  }\n\n  var requestCache = new Map();\n  requestCachesByEnvironment.set(environment, requestCache);\n  return requestCache;\n}\n/**\n * @private\n */\n\n\nfunction getCachedRequest(requestCache, identifier) {\n  var cached = requestCache.get(identifier);\n  !(cached != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, '[fetchQueryInternal] getCachedRequest: Expected request to be cached') : invariant(false) : void 0;\n  return cached;\n}\n\nmodule.exports = {\n  fetchQuery: fetchQuery,\n  fetchQueryDeduped: fetchQueryDeduped,\n  getPromiseForActiveRequest: getPromiseForActiveRequest,\n  getObservableForActiveRequest: getObservableForActiveRequest\n};","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/query/fetchQueryInternal.js"],"names":["Observable","require","RelayReplaySubject","invariant","WEAKMAP_SUPPORTED","WeakMap","requestCachesByEnvironment","Map","fetchQuery","environment","operation","fetchQueryDeduped","request","identifier","execute","fetchFn","create","sink","requestCache","getRequestCache","cachedRequest","get","subscribe","start","subscription","subject","subjectForInFlightStatus","set","next","response","cachedReq","getCachedRequest","error","_error","complete","unsubscribe","process","env","NODE_ENV","getObservableForCachedRequest","cachedRequestInstance","requestSubscription","getObserverCount","getActiveStatusObservableForCachedRequest","isRequestActive","getPromiseForActiveRequest","Promise","resolve","reject","resolveOnNext","getObservableForActiveRequest","cached","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar Observable = require('../network/RelayObservable');\n\nvar RelayReplaySubject = require('../util/RelayReplaySubject');\n\nvar invariant = require('invariant');\n\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\nvar requestCachesByEnvironment = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n/**\n * Fetches the given query and variables on the provided environment,\n * and de-dupes identical in-flight requests.\n *\n * Observing a request:\n * ====================\n * fetchQuery returns an Observable which you can call .subscribe()\n * on. subscribe() takes an Observer, which you can provide to\n * observe network events:\n *\n * ```\n * fetchQuery(environment, query, variables).subscribe({\n *   // Called when network requests starts\n *   start: (subscription) => {},\n *\n *   // Called after a payload is received and written to the local store\n *   next: (payload) => {},\n *\n *   // Called when network requests errors\n *   error: (error) => {},\n *\n *   // Called when network requests fully completes\n *   complete: () => {},\n *\n *   // Called when network request is unsubscribed\n *   unsubscribe: (subscription) => {},\n * });\n * ```\n *\n * In-flight request de-duping:\n * ============================\n * By default, calling fetchQuery multiple times with the same\n * environment, query and variables will not initiate a new request if a request\n * for those same parameters is already in flight.\n *\n * A request is marked in-flight from the moment it starts until the moment it\n * fully completes, regardless of error or successful completion.\n *\n * NOTE: If the request completes _synchronously_, calling fetchQuery\n * a second time with the same arguments in the same tick will _NOT_ de-dupe\n * the request given that it will no longer be in-flight.\n *\n *\n * Data Retention:\n * ===============\n * This function will not retain any query data outside the scope of the\n * request, which means it is not guaranteed that it won't be garbage\n * collected after the request completes.\n * If you need to retain data, you can do so manually with environment.retain().\n *\n * Cancelling requests:\n * ====================\n * If the subscription returned by subscribe is called while the\n * request is in-flight, the request will be cancelled.\n *\n * ```\n * const subscription = fetchQuery(...).subscribe(...);\n *\n * // This will cancel the request if it is in-flight.\n * subscription.unsubscribe();\n * ```\n */\n\nfunction fetchQuery(environment, operation) {\n  return fetchQueryDeduped(environment, operation.request.identifier, function () {\n    return environment.execute({\n      operation: operation\n    });\n  });\n}\n/**\n * Low-level implementation details of `fetchQuery`.\n *\n * `fetchQueryDeduped` can also be used to share a single cache for\n * requests that aren't using `fetchQuery` directly (e.g. because they don't\n * have an `OperationDescriptor` when they are called).\n */\n\n\nfunction fetchQueryDeduped(environment, identifier, fetchFn) {\n  return Observable.create(function (sink) {\n    var requestCache = getRequestCache(environment);\n    var cachedRequest = requestCache.get(identifier);\n\n    if (!cachedRequest) {\n      fetchFn()[\"finally\"](function () {\n        return requestCache[\"delete\"](identifier);\n      }).subscribe({\n        start: function start(subscription) {\n          cachedRequest = {\n            identifier: identifier,\n            subject: new RelayReplaySubject(),\n            subjectForInFlightStatus: new RelayReplaySubject(),\n            subscription: subscription\n          };\n          requestCache.set(identifier, cachedRequest);\n        },\n        next: function next(response) {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.next(response);\n          cachedReq.subjectForInFlightStatus.next(response);\n        },\n        error: function error(_error) {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.error(_error);\n          cachedReq.subjectForInFlightStatus.error(_error);\n        },\n        complete: function complete() {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.complete();\n          cachedReq.subjectForInFlightStatus.complete();\n        },\n        unsubscribe: function unsubscribe(subscription) {\n          var cachedReq = getCachedRequest(requestCache, identifier);\n          cachedReq.subject.unsubscribe();\n          cachedReq.subjectForInFlightStatus.unsubscribe();\n        }\n      });\n    }\n\n    !(cachedRequest != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, '[fetchQueryInternal] fetchQueryDeduped: Expected `start` to be ' + 'called synchronously') : invariant(false) : void 0;\n    return getObservableForCachedRequest(requestCache, cachedRequest).subscribe(sink);\n  });\n}\n/**\n * @private\n */\n\n\nfunction getObservableForCachedRequest(requestCache, cachedRequest) {\n  return Observable.create(function (sink) {\n    var subscription = cachedRequest.subject.subscribe(sink);\n    return function () {\n      subscription.unsubscribe();\n      var cachedRequestInstance = requestCache.get(cachedRequest.identifier);\n\n      if (cachedRequestInstance) {\n        var requestSubscription = cachedRequestInstance.subscription;\n\n        if (requestSubscription != null && cachedRequestInstance.subject.getObserverCount() === 0) {\n          requestSubscription.unsubscribe();\n          requestCache[\"delete\"](cachedRequest.identifier);\n        }\n      }\n    };\n  });\n}\n/**\n * @private\n */\n\n\nfunction getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest) {\n  return Observable.create(function (sink) {\n    var subscription = cachedRequest.subjectForInFlightStatus.subscribe({\n      error: sink.error,\n      next: function next(response) {\n        if (!environment.isRequestActive(cachedRequest.identifier)) {\n          sink.complete();\n          return;\n        }\n\n        sink.next();\n      },\n      complete: sink.complete,\n      unsubscribe: sink.complete\n    });\n    return function () {\n      subscription.unsubscribe();\n    };\n  });\n}\n/**\n * If a request is active for the given query, variables and environment,\n * this function will return a Promise that will resolve when that request\n * stops being active (receives a final payload), and the data has been saved\n * to the store.\n * If no request is active, null will be returned\n */\n\n\nfunction getPromiseForActiveRequest(environment, request) {\n  var requestCache = getRequestCache(environment);\n  var cachedRequest = requestCache.get(request.identifier);\n\n  if (!cachedRequest) {\n    return null;\n  }\n\n  if (!environment.isRequestActive(cachedRequest.identifier)) {\n    return null;\n  }\n\n  return new Promise(function (resolve, reject) {\n    var resolveOnNext = false;\n    getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest).subscribe({\n      complete: resolve,\n      error: reject,\n      next: function next(response) {\n        /*\n         * The underlying `RelayReplaySubject` will synchronously replay events\n         * as soon as we subscribe, but since we want the *next* asynchronous\n         * one, we'll ignore them until the replay finishes.\n         */\n        if (resolveOnNext) {\n          resolve(response);\n        }\n      }\n    });\n    resolveOnNext = true;\n  });\n}\n/**\n * If there is a pending request for the given query, returns an Observable of\n * *all* its responses. Existing responses are published synchronously and\n * subsequent responses are published asynchronously. Returns null if there is\n * no pending request. This is similar to fetchQuery() except that it will not\n * issue a fetch if there isn't already one pending.\n */\n\n\nfunction getObservableForActiveRequest(environment, request) {\n  var requestCache = getRequestCache(environment);\n  var cachedRequest = requestCache.get(request.identifier);\n\n  if (!cachedRequest) {\n    return null;\n  }\n\n  if (!environment.isRequestActive(cachedRequest.identifier)) {\n    return null;\n  }\n\n  return getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest);\n}\n/**\n * @private\n */\n\n\nfunction getRequestCache(environment) {\n  var cached = requestCachesByEnvironment.get(environment);\n\n  if (cached != null) {\n    return cached;\n  }\n\n  var requestCache = new Map();\n  requestCachesByEnvironment.set(environment, requestCache);\n  return requestCache;\n}\n/**\n * @private\n */\n\n\nfunction getCachedRequest(requestCache, identifier) {\n  var cached = requestCache.get(identifier);\n  !(cached != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, '[fetchQueryInternal] getCachedRequest: Expected request to be cached') : invariant(false) : void 0;\n  return cached;\n}\n\nmodule.exports = {\n  fetchQuery: fetchQuery,\n  fetchQueryDeduped: fetchQueryDeduped,\n  getPromiseForActiveRequest: getPromiseForActiveRequest,\n  getObservableForActiveRequest: getObservableForActiveRequest\n};"]},"metadata":{},"sourceType":"script"}