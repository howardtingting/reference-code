{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar _require = require('./ClientID'),\n    isClientID = _require.isClientID;\n\nvar _require2 = require('./RelayStoreUtils'),\n    ACTOR_IDENTIFIER_KEY = _require2.ACTOR_IDENTIFIER_KEY,\n    ID_KEY = _require2.ID_KEY,\n    INVALIDATED_AT_KEY = _require2.INVALIDATED_AT_KEY,\n    REF_KEY = _require2.REF_KEY,\n    REFS_KEY = _require2.REFS_KEY,\n    ROOT_ID = _require2.ROOT_ID,\n    TYPENAME_KEY = _require2.TYPENAME_KEY;\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n/**\n * @public\n *\n * Low-level record manipulation methods.\n *\n * A note about perf: we use long-hand property access rather than computed\n * properties in this file for speed ie.\n *\n *    const object = {};\n *    object[KEY] = value;\n *    record[storageKey] = object;\n *\n * instead of:\n *\n *    record[storageKey] = {\n *      [KEY]: value,\n *    };\n *\n * The latter gets transformed by Babel into something like:\n *\n *    function _defineProperty(obj, key, value) {\n *      if (key in obj) {\n *        Object.defineProperty(obj, key, {\n *          value: value,\n *          enumerable: true,\n *          configurable: true,\n *          writable: true,\n *        });\n *      } else {\n *        obj[key] = value;\n *      }\n *      return obj;\n *    }\n *\n *    record[storageKey] = _defineProperty({}, KEY, value);\n *\n * A quick benchmark shows that computed property access is an order of\n * magnitude slower (times in seconds for 100,000 iterations):\n *\n *               best     avg     sd\n *    computed 0.02175 0.02292 0.00113\n *      manual 0.00110 0.00123 0.00008\n */\n\n/**\n * @public\n *\n * Clone a record.\n */\n\n\nfunction clone(record) {\n  return (0, _objectSpread2[\"default\"])({}, record);\n}\n/**\n * @public\n *\n * Copies all fields from `source` to `sink`, excluding `__id` and `__typename`.\n *\n * NOTE: This function does not treat `id` specially. To preserve the id,\n * manually reset it after calling this function. Also note that values are\n * copied by reference and not value; callers should ensure that values are\n * copied on write.\n */\n\n\nfunction copyFields(source, sink) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      if (key !== ID_KEY && key !== TYPENAME_KEY) {\n        sink[key] = source[key];\n      }\n    }\n  }\n}\n/**\n * @public\n *\n * Create a new record.\n */\n\n\nfunction create(dataID, typeName) {\n  // See perf note above for why we aren't using computed property access.\n  var record = {};\n  record[ID_KEY] = dataID;\n  record[TYPENAME_KEY] = typeName;\n  return record;\n}\n/**\n * @public\n *\n * Get the record's `id` if available or the client-generated identifier.\n */\n\n\nfunction getDataID(record) {\n  return record[ID_KEY];\n}\n/**\n * @public\n *\n * Get the concrete type of the record.\n */\n\n\nfunction getType(record) {\n  return record[TYPENAME_KEY];\n}\n/**\n * @public\n *\n * Get a scalar (non-link) field value.\n */\n\n\nfunction getValue(record, storageKey) {\n  var value = record[storageKey];\n\n  if (value && typeof value === 'object') {\n    !(!value.hasOwnProperty(REF_KEY) && !value.hasOwnProperty(REFS_KEY)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getValue(): Expected a scalar (non-link) value for `%s.%s` ' + 'but found %s.', record[ID_KEY], storageKey, value.hasOwnProperty(REF_KEY) ? 'a linked record' : 'plural linked records') : invariant(false) : void 0;\n  }\n\n  return value;\n}\n/**\n * @public\n *\n * Get the value of a field as a reference to another record. Throws if the\n * field has a different type.\n */\n\n\nfunction getLinkedRecordID(record, storageKey) {\n  var link = record[storageKey];\n\n  if (link == null) {\n    return link;\n  }\n\n  !(typeof link === 'object' && link && typeof link[REF_KEY] === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getLinkedRecordID(): Expected `%s.%s` to be a linked ID, ' + 'was `%s`.%s', record[ID_KEY], storageKey, JSON.stringify(link), typeof link === 'object' && link[REFS_KEY] !== undefined ? ' It appears to be a plural linked record: did you mean to call ' + 'getLinkedRecords() instead of getLinkedRecord()?' : '') : invariant(false) : void 0;\n  return link[REF_KEY];\n}\n/**\n * @public\n *\n * Get the value of a field as a list of references to other records. Throws if\n * the field has a different type.\n */\n\n\nfunction getLinkedRecordIDs(record, storageKey) {\n  var links = record[storageKey];\n\n  if (links == null) {\n    return links;\n  }\n\n  !(typeof links === 'object' && Array.isArray(links[REFS_KEY])) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getLinkedRecordIDs(): Expected `%s.%s` to contain an array ' + 'of linked IDs, got `%s`.%s', record[ID_KEY], storageKey, JSON.stringify(links), typeof links === 'object' && links[REF_KEY] !== undefined ? ' It appears to be a singular linked record: did you mean to call ' + 'getLinkedRecord() instead of getLinkedRecords()?' : '') : invariant(false) : void 0; // assume items of the array are ids\n\n  return links[REFS_KEY];\n}\n/**\n * @public\n *\n * Returns the epoch at which the record was invalidated, if it\n * ever was; otherwise returns null;\n */\n\n\nfunction getInvalidationEpoch(record) {\n  if (record == null) {\n    return null;\n  }\n\n  var invalidatedAt = record[INVALIDATED_AT_KEY];\n\n  if (typeof invalidatedAt !== 'number') {\n    // If the record has never been invalidated, it isn't stale.\n    return null;\n  }\n\n  return invalidatedAt;\n}\n/**\n * @public\n *\n * Compares the fields of a previous and new record, returning either the\n * previous record if all fields are equal or a new record (with merged fields)\n * if any fields have changed.\n */\n\n\nfunction update(prevRecord, nextRecord) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _getType, _getType2;\n\n    var prevID = getDataID(prevRecord);\n    var nextID = getDataID(nextRecord);\n    process.env.NODE_ENV !== \"production\" ? warning(prevID === nextID, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : void 0; // note: coalesce null/undefined to null\n\n    var prevType = (_getType = getType(prevRecord)) !== null && _getType !== void 0 ? _getType : null;\n    var nextType = (_getType2 = getType(nextRecord)) !== null && _getType2 !== void 0 ? _getType2 : null;\n    process.env.NODE_ENV !== \"production\" ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n  }\n\n  var updated = null;\n  var keys = Object.keys(nextRecord);\n\n  for (var ii = 0; ii < keys.length; ii++) {\n    var key = keys[ii];\n\n    if (updated || !areEqual(prevRecord[key], nextRecord[key])) {\n      updated = updated !== null ? updated : (0, _objectSpread2[\"default\"])({}, prevRecord);\n      updated[key] = nextRecord[key];\n    }\n  }\n\n  return updated !== null ? updated : prevRecord;\n}\n/**\n * @public\n *\n * Returns a new record with the contents of the given records. Fields in the\n * second record will overwrite identical fields in the first record.\n */\n\n\nfunction merge(record1, record2) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _getType3, _getType4;\n\n    var prevID = getDataID(record1);\n    var nextID = getDataID(record2);\n    process.env.NODE_ENV !== \"production\" ? warning(prevID === nextID, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : void 0; // note: coalesce null/undefined to null\n\n    var prevType = (_getType3 = getType(record1)) !== null && _getType3 !== void 0 ? _getType3 : null;\n    var nextType = (_getType4 = getType(record2)) !== null && _getType4 !== void 0 ? _getType4 : null;\n    process.env.NODE_ENV !== \"production\" ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n  }\n\n  return Object.assign({}, record1, record2);\n}\n/**\n * @public\n *\n * Prevent modifications to the record. Attempts to call `set*` functions on a\n * frozen record will fatal at runtime.\n */\n\n\nfunction freeze(record) {\n  deepFreeze(record);\n}\n/**\n * @public\n *\n * Set the value of a storageKey to a scalar.\n */\n\n\nfunction setValue(record, storageKey, value) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var prevID = getDataID(record);\n\n    if (storageKey === ID_KEY) {\n      process.env.NODE_ENV !== \"production\" ? warning(prevID === value, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, value) : void 0;\n    } else if (storageKey === TYPENAME_KEY) {\n      var _getType5; // note: coalesce null/undefined to null\n\n\n      var prevType = (_getType5 = getType(record)) !== null && _getType5 !== void 0 ? _getType5 : null;\n      var nextType = value !== null && value !== void 0 ? value : null;\n      process.env.NODE_ENV !== \"production\" ? warning(isClientID(getDataID(record)) && getDataID(record) !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n    }\n  }\n\n  record[storageKey] = value;\n}\n/**\n * @public\n *\n * Set the value of a field to a reference to another record.\n */\n\n\nfunction setLinkedRecordID(record, storageKey, linkedID) {\n  // See perf note above for why we aren't using computed property access.\n  var link = {};\n  link[REF_KEY] = linkedID;\n  record[storageKey] = link;\n}\n/**\n * @public\n *\n * Set the value of a field to a list of references other records.\n */\n\n\nfunction setLinkedRecordIDs(record, storageKey, linkedIDs) {\n  // See perf note above for why we aren't using computed property access.\n  var links = {};\n  links[REFS_KEY] = linkedIDs;\n  record[storageKey] = links;\n}\n/**\n * @public\n *\n * Set the value of a field to a reference to another record in the actor specific store.\n */\n\n\nfunction setActorLinkedRecordID(record, storageKey, actorIdentifier, linkedID) {\n  // See perf note above for why we aren't using computed property access.\n  var link = {};\n  link[REF_KEY] = linkedID;\n  link[ACTOR_IDENTIFIER_KEY] = actorIdentifier;\n  record[storageKey] = link;\n}\n/**\n * @public\n *\n * Get link to a record and the actor identifier for the store.\n */\n\n\nfunction getActorLinkedRecordID(record, storageKey) {\n  var link = record[storageKey];\n\n  if (link == null) {\n    return link;\n  }\n\n  !(typeof link === 'object' && typeof link[REF_KEY] === 'string' && link[ACTOR_IDENTIFIER_KEY] != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getActorLinkedRecordID(): Expected `%s.%s` to be an actor specific linked ID, ' + 'was `%s`.', record[ID_KEY], storageKey, JSON.stringify(link)) : invariant(false) : void 0;\n  return [link[ACTOR_IDENTIFIER_KEY], link[REF_KEY]];\n}\n\nmodule.exports = {\n  clone: clone,\n  copyFields: copyFields,\n  create: create,\n  freeze: freeze,\n  getDataID: getDataID,\n  getInvalidationEpoch: getInvalidationEpoch,\n  getLinkedRecordID: getLinkedRecordID,\n  getLinkedRecordIDs: getLinkedRecordIDs,\n  getType: getType,\n  getValue: getValue,\n  merge: merge,\n  setValue: setValue,\n  setLinkedRecordID: setLinkedRecordID,\n  setLinkedRecordIDs: setLinkedRecordIDs,\n  update: update,\n  getActorLinkedRecordID: getActorLinkedRecordID,\n  setActorLinkedRecordID: setActorLinkedRecordID\n};","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/store/RelayModernRecord.js"],"names":["_interopRequireDefault","require","_objectSpread2","deepFreeze","_require","isClientID","_require2","ACTOR_IDENTIFIER_KEY","ID_KEY","INVALIDATED_AT_KEY","REF_KEY","REFS_KEY","ROOT_ID","TYPENAME_KEY","areEqual","invariant","warning","clone","record","copyFields","source","sink","key","hasOwnProperty","create","dataID","typeName","getDataID","getType","getValue","storageKey","value","process","env","NODE_ENV","getLinkedRecordID","link","JSON","stringify","undefined","getLinkedRecordIDs","links","Array","isArray","getInvalidationEpoch","invalidatedAt","update","prevRecord","nextRecord","_getType","_getType2","prevID","nextID","prevType","nextType","updated","keys","Object","ii","length","merge","record1","record2","_getType3","_getType4","assign","freeze","setValue","_getType5","setLinkedRecordID","linkedID","setLinkedRecordIDs","linkedIDs","setActorLinkedRecordID","actorIdentifier","getActorLinkedRecordID","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar _require = require('./ClientID'),\n    isClientID = _require.isClientID;\n\nvar _require2 = require('./RelayStoreUtils'),\n    ACTOR_IDENTIFIER_KEY = _require2.ACTOR_IDENTIFIER_KEY,\n    ID_KEY = _require2.ID_KEY,\n    INVALIDATED_AT_KEY = _require2.INVALIDATED_AT_KEY,\n    REF_KEY = _require2.REF_KEY,\n    REFS_KEY = _require2.REFS_KEY,\n    ROOT_ID = _require2.ROOT_ID,\n    TYPENAME_KEY = _require2.TYPENAME_KEY;\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n/**\n * @public\n *\n * Low-level record manipulation methods.\n *\n * A note about perf: we use long-hand property access rather than computed\n * properties in this file for speed ie.\n *\n *    const object = {};\n *    object[KEY] = value;\n *    record[storageKey] = object;\n *\n * instead of:\n *\n *    record[storageKey] = {\n *      [KEY]: value,\n *    };\n *\n * The latter gets transformed by Babel into something like:\n *\n *    function _defineProperty(obj, key, value) {\n *      if (key in obj) {\n *        Object.defineProperty(obj, key, {\n *          value: value,\n *          enumerable: true,\n *          configurable: true,\n *          writable: true,\n *        });\n *      } else {\n *        obj[key] = value;\n *      }\n *      return obj;\n *    }\n *\n *    record[storageKey] = _defineProperty({}, KEY, value);\n *\n * A quick benchmark shows that computed property access is an order of\n * magnitude slower (times in seconds for 100,000 iterations):\n *\n *               best     avg     sd\n *    computed 0.02175 0.02292 0.00113\n *      manual 0.00110 0.00123 0.00008\n */\n\n/**\n * @public\n *\n * Clone a record.\n */\n\n\nfunction clone(record) {\n  return (0, _objectSpread2[\"default\"])({}, record);\n}\n/**\n * @public\n *\n * Copies all fields from `source` to `sink`, excluding `__id` and `__typename`.\n *\n * NOTE: This function does not treat `id` specially. To preserve the id,\n * manually reset it after calling this function. Also note that values are\n * copied by reference and not value; callers should ensure that values are\n * copied on write.\n */\n\n\nfunction copyFields(source, sink) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      if (key !== ID_KEY && key !== TYPENAME_KEY) {\n        sink[key] = source[key];\n      }\n    }\n  }\n}\n/**\n * @public\n *\n * Create a new record.\n */\n\n\nfunction create(dataID, typeName) {\n  // See perf note above for why we aren't using computed property access.\n  var record = {};\n  record[ID_KEY] = dataID;\n  record[TYPENAME_KEY] = typeName;\n  return record;\n}\n/**\n * @public\n *\n * Get the record's `id` if available or the client-generated identifier.\n */\n\n\nfunction getDataID(record) {\n  return record[ID_KEY];\n}\n/**\n * @public\n *\n * Get the concrete type of the record.\n */\n\n\nfunction getType(record) {\n  return record[TYPENAME_KEY];\n}\n/**\n * @public\n *\n * Get a scalar (non-link) field value.\n */\n\n\nfunction getValue(record, storageKey) {\n  var value = record[storageKey];\n\n  if (value && typeof value === 'object') {\n    !(!value.hasOwnProperty(REF_KEY) && !value.hasOwnProperty(REFS_KEY)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getValue(): Expected a scalar (non-link) value for `%s.%s` ' + 'but found %s.', record[ID_KEY], storageKey, value.hasOwnProperty(REF_KEY) ? 'a linked record' : 'plural linked records') : invariant(false) : void 0;\n  }\n\n  return value;\n}\n/**\n * @public\n *\n * Get the value of a field as a reference to another record. Throws if the\n * field has a different type.\n */\n\n\nfunction getLinkedRecordID(record, storageKey) {\n  var link = record[storageKey];\n\n  if (link == null) {\n    return link;\n  }\n\n  !(typeof link === 'object' && link && typeof link[REF_KEY] === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getLinkedRecordID(): Expected `%s.%s` to be a linked ID, ' + 'was `%s`.%s', record[ID_KEY], storageKey, JSON.stringify(link), typeof link === 'object' && link[REFS_KEY] !== undefined ? ' It appears to be a plural linked record: did you mean to call ' + 'getLinkedRecords() instead of getLinkedRecord()?' : '') : invariant(false) : void 0;\n  return link[REF_KEY];\n}\n/**\n * @public\n *\n * Get the value of a field as a list of references to other records. Throws if\n * the field has a different type.\n */\n\n\nfunction getLinkedRecordIDs(record, storageKey) {\n  var links = record[storageKey];\n\n  if (links == null) {\n    return links;\n  }\n\n  !(typeof links === 'object' && Array.isArray(links[REFS_KEY])) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getLinkedRecordIDs(): Expected `%s.%s` to contain an array ' + 'of linked IDs, got `%s`.%s', record[ID_KEY], storageKey, JSON.stringify(links), typeof links === 'object' && links[REF_KEY] !== undefined ? ' It appears to be a singular linked record: did you mean to call ' + 'getLinkedRecord() instead of getLinkedRecords()?' : '') : invariant(false) : void 0; // assume items of the array are ids\n\n  return links[REFS_KEY];\n}\n/**\n * @public\n *\n * Returns the epoch at which the record was invalidated, if it\n * ever was; otherwise returns null;\n */\n\n\nfunction getInvalidationEpoch(record) {\n  if (record == null) {\n    return null;\n  }\n\n  var invalidatedAt = record[INVALIDATED_AT_KEY];\n\n  if (typeof invalidatedAt !== 'number') {\n    // If the record has never been invalidated, it isn't stale.\n    return null;\n  }\n\n  return invalidatedAt;\n}\n/**\n * @public\n *\n * Compares the fields of a previous and new record, returning either the\n * previous record if all fields are equal or a new record (with merged fields)\n * if any fields have changed.\n */\n\n\nfunction update(prevRecord, nextRecord) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _getType, _getType2;\n\n    var prevID = getDataID(prevRecord);\n    var nextID = getDataID(nextRecord);\n    process.env.NODE_ENV !== \"production\" ? warning(prevID === nextID, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : void 0; // note: coalesce null/undefined to null\n\n    var prevType = (_getType = getType(prevRecord)) !== null && _getType !== void 0 ? _getType : null;\n    var nextType = (_getType2 = getType(nextRecord)) !== null && _getType2 !== void 0 ? _getType2 : null;\n    process.env.NODE_ENV !== \"production\" ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n  }\n\n  var updated = null;\n  var keys = Object.keys(nextRecord);\n\n  for (var ii = 0; ii < keys.length; ii++) {\n    var key = keys[ii];\n\n    if (updated || !areEqual(prevRecord[key], nextRecord[key])) {\n      updated = updated !== null ? updated : (0, _objectSpread2[\"default\"])({}, prevRecord);\n      updated[key] = nextRecord[key];\n    }\n  }\n\n  return updated !== null ? updated : prevRecord;\n}\n/**\n * @public\n *\n * Returns a new record with the contents of the given records. Fields in the\n * second record will overwrite identical fields in the first record.\n */\n\n\nfunction merge(record1, record2) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _getType3, _getType4;\n\n    var prevID = getDataID(record1);\n    var nextID = getDataID(record2);\n    process.env.NODE_ENV !== \"production\" ? warning(prevID === nextID, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : void 0; // note: coalesce null/undefined to null\n\n    var prevType = (_getType3 = getType(record1)) !== null && _getType3 !== void 0 ? _getType3 : null;\n    var nextType = (_getType4 = getType(record2)) !== null && _getType4 !== void 0 ? _getType4 : null;\n    process.env.NODE_ENV !== \"production\" ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n  }\n\n  return Object.assign({}, record1, record2);\n}\n/**\n * @public\n *\n * Prevent modifications to the record. Attempts to call `set*` functions on a\n * frozen record will fatal at runtime.\n */\n\n\nfunction freeze(record) {\n  deepFreeze(record);\n}\n/**\n * @public\n *\n * Set the value of a storageKey to a scalar.\n */\n\n\nfunction setValue(record, storageKey, value) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var prevID = getDataID(record);\n\n    if (storageKey === ID_KEY) {\n      process.env.NODE_ENV !== \"production\" ? warning(prevID === value, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, value) : void 0;\n    } else if (storageKey === TYPENAME_KEY) {\n      var _getType5;\n\n      // note: coalesce null/undefined to null\n      var prevType = (_getType5 = getType(record)) !== null && _getType5 !== void 0 ? _getType5 : null;\n      var nextType = value !== null && value !== void 0 ? value : null;\n      process.env.NODE_ENV !== \"production\" ? warning(isClientID(getDataID(record)) && getDataID(record) !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n    }\n  }\n\n  record[storageKey] = value;\n}\n/**\n * @public\n *\n * Set the value of a field to a reference to another record.\n */\n\n\nfunction setLinkedRecordID(record, storageKey, linkedID) {\n  // See perf note above for why we aren't using computed property access.\n  var link = {};\n  link[REF_KEY] = linkedID;\n  record[storageKey] = link;\n}\n/**\n * @public\n *\n * Set the value of a field to a list of references other records.\n */\n\n\nfunction setLinkedRecordIDs(record, storageKey, linkedIDs) {\n  // See perf note above for why we aren't using computed property access.\n  var links = {};\n  links[REFS_KEY] = linkedIDs;\n  record[storageKey] = links;\n}\n/**\n * @public\n *\n * Set the value of a field to a reference to another record in the actor specific store.\n */\n\n\nfunction setActorLinkedRecordID(record, storageKey, actorIdentifier, linkedID) {\n  // See perf note above for why we aren't using computed property access.\n  var link = {};\n  link[REF_KEY] = linkedID;\n  link[ACTOR_IDENTIFIER_KEY] = actorIdentifier;\n  record[storageKey] = link;\n}\n/**\n * @public\n *\n * Get link to a record and the actor identifier for the store.\n */\n\n\nfunction getActorLinkedRecordID(record, storageKey) {\n  var link = record[storageKey];\n\n  if (link == null) {\n    return link;\n  }\n\n  !(typeof link === 'object' && typeof link[REF_KEY] === 'string' && link[ACTOR_IDENTIFIER_KEY] != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getActorLinkedRecordID(): Expected `%s.%s` to be an actor specific linked ID, ' + 'was `%s`.', record[ID_KEY], storageKey, JSON.stringify(link)) : invariant(false) : void 0;\n  return [link[ACTOR_IDENTIFIER_KEY], link[REF_KEY]];\n}\n\nmodule.exports = {\n  clone: clone,\n  copyFields: copyFields,\n  create: create,\n  freeze: freeze,\n  getDataID: getDataID,\n  getInvalidationEpoch: getInvalidationEpoch,\n  getLinkedRecordID: getLinkedRecordID,\n  getLinkedRecordIDs: getLinkedRecordIDs,\n  getType: getType,\n  getValue: getValue,\n  merge: merge,\n  setValue: setValue,\n  setLinkedRecordID: setLinkedRecordID,\n  setLinkedRecordIDs: setLinkedRecordIDs,\n  update: update,\n  getActorLinkedRecordID: getActorLinkedRecordID,\n  setActorLinkedRecordID: setActorLinkedRecordID\n};"]},"metadata":{},"sourceType":"script"}