{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar hasOverlappingIDs = require('./hasOverlappingIDs');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayStoreSubscriptions = /*#__PURE__*/function () {\n  function RelayStoreSubscriptions(log, resolverCache) {\n    this._subscriptions = new Set();\n    this.__log = log;\n    this._resolverCache = resolverCache;\n  }\n\n  var _proto = RelayStoreSubscriptions.prototype;\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    var _this = this;\n\n    var subscription = {\n      backup: null,\n      callback: callback,\n      snapshot: snapshot,\n      stale: false\n    };\n\n    var dispose = function dispose() {\n      _this._subscriptions[\"delete\"](subscription);\n    };\n\n    this._subscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.snapshotSubscriptions = function snapshotSubscriptions(source) {\n    var _this2 = this;\n\n    this._subscriptions.forEach(function (subscription) {\n      // Backup occurs after writing a new \"final\" payload(s) and before (re)applying\n      // optimistic changes. Each subscription's `snapshot` represents what was *last\n      // published to the subscriber*, which notably may include previous optimistic\n      // updates. Therefore a subscription can be in any of the following states:\n      // - stale=true: This subscription was restored to a different value than\n      //   `snapshot`. That means this subscription has changes relative to its base,\n      //   but its base has changed (we just applied a final payload): recompute\n      //   a backup so that we can later restore to the state the subscription\n      //   should be in.\n      // - stale=false: This subscription was restored to the same value as\n      //   `snapshot`. That means this subscription does *not* have changes relative\n      //   to its base, so the current `snapshot` is valid to use as a backup.\n      if (!subscription.stale) {\n        subscription.backup = subscription.snapshot;\n        return;\n      }\n\n      var snapshot = subscription.snapshot;\n      var backup = RelayReader.read(source, snapshot.selector, _this2._resolverCache);\n      var nextData = recycleNodesInto(snapshot.data, backup.data);\n      backup.data = nextData; // backup owns the snapshot and can safely mutate\n\n      subscription.backup = backup;\n    });\n  };\n\n  _proto.restoreSubscriptions = function restoreSubscriptions() {\n    this._subscriptions.forEach(function (subscription) {\n      var backup = subscription.backup;\n      subscription.backup = null;\n\n      if (backup) {\n        if (backup.data !== subscription.snapshot.data) {\n          subscription.stale = true;\n        }\n\n        subscription.snapshot = {\n          data: subscription.snapshot.data,\n          isMissingData: backup.isMissingData,\n          missingClientEdges: backup.missingClientEdges,\n          seenRecords: backup.seenRecords,\n          selector: backup.selector,\n          missingRequiredFields: backup.missingRequiredFields\n        };\n      } else {\n        subscription.stale = true;\n      }\n    });\n  };\n\n  _proto.updateSubscriptions = function updateSubscriptions(source, updatedRecordIDs, updatedOwners, sourceOperation) {\n    var _this3 = this;\n\n    var hasUpdatedRecords = updatedRecordIDs.size !== 0;\n\n    this._subscriptions.forEach(function (subscription) {\n      var owner = _this3._updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation);\n\n      if (owner != null) {\n        updatedOwners.push(owner);\n      }\n    });\n  }\n  /**\n   * Notifies the callback for the subscription if the data for the associated\n   * snapshot has changed.\n   * Additionally, updates the subscription snapshot with the latest snapshot,\n   * and marks it as not stale.\n   * Returns the owner (RequestDescriptor) if the subscription was affected by the\n   * latest update, or null if it was not affected.\n   */\n  ;\n\n  _proto._updateSubscription = function _updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation) {\n    var backup = subscription.backup,\n        callback = subscription.callback,\n        snapshot = subscription.snapshot,\n        stale = subscription.stale;\n    var hasOverlappingUpdates = hasUpdatedRecords && hasOverlappingIDs(snapshot.seenRecords, updatedRecordIDs);\n\n    if (!stale && !hasOverlappingUpdates) {\n      return;\n    }\n\n    var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector, this._resolverCache) : backup;\n    var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);\n    nextSnapshot = {\n      data: nextData,\n      isMissingData: nextSnapshot.isMissingData,\n      missingClientEdges: nextSnapshot.missingClientEdges,\n      seenRecords: nextSnapshot.seenRecords,\n      selector: nextSnapshot.selector,\n      missingRequiredFields: nextSnapshot.missingRequiredFields\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    subscription.snapshot = nextSnapshot;\n    subscription.stale = false;\n\n    if (nextSnapshot.data !== snapshot.data) {\n      if (this.__log && RelayFeatureFlags.ENABLE_NOTIFY_SUBSCRIPTION) {\n        this.__log({\n          name: 'store.notify.subscription',\n          sourceOperation: sourceOperation,\n          snapshot: snapshot,\n          nextSnapshot: nextSnapshot\n        });\n      }\n\n      callback(nextSnapshot);\n      return snapshot.selector.owner;\n    }\n  };\n\n  return RelayStoreSubscriptions;\n}();\n\nmodule.exports = RelayStoreSubscriptions;","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/store/RelayStoreSubscriptions.js"],"names":["deepFreeze","require","recycleNodesInto","RelayFeatureFlags","hasOverlappingIDs","RelayReader","RelayStoreSubscriptions","log","resolverCache","_subscriptions","Set","__log","_resolverCache","_proto","prototype","subscribe","snapshot","callback","_this","subscription","backup","stale","dispose","add","snapshotSubscriptions","source","_this2","forEach","read","selector","nextData","data","restoreSubscriptions","isMissingData","missingClientEdges","seenRecords","missingRequiredFields","updateSubscriptions","updatedRecordIDs","updatedOwners","sourceOperation","_this3","hasUpdatedRecords","size","owner","_updateSubscription","push","hasOverlappingUpdates","nextSnapshot","process","env","NODE_ENV","ENABLE_NOTIFY_SUBSCRIPTION","name","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar hasOverlappingIDs = require('./hasOverlappingIDs');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayStoreSubscriptions = /*#__PURE__*/function () {\n  function RelayStoreSubscriptions(log, resolverCache) {\n    this._subscriptions = new Set();\n    this.__log = log;\n    this._resolverCache = resolverCache;\n  }\n\n  var _proto = RelayStoreSubscriptions.prototype;\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    var _this = this;\n\n    var subscription = {\n      backup: null,\n      callback: callback,\n      snapshot: snapshot,\n      stale: false\n    };\n\n    var dispose = function dispose() {\n      _this._subscriptions[\"delete\"](subscription);\n    };\n\n    this._subscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.snapshotSubscriptions = function snapshotSubscriptions(source) {\n    var _this2 = this;\n\n    this._subscriptions.forEach(function (subscription) {\n      // Backup occurs after writing a new \"final\" payload(s) and before (re)applying\n      // optimistic changes. Each subscription's `snapshot` represents what was *last\n      // published to the subscriber*, which notably may include previous optimistic\n      // updates. Therefore a subscription can be in any of the following states:\n      // - stale=true: This subscription was restored to a different value than\n      //   `snapshot`. That means this subscription has changes relative to its base,\n      //   but its base has changed (we just applied a final payload): recompute\n      //   a backup so that we can later restore to the state the subscription\n      //   should be in.\n      // - stale=false: This subscription was restored to the same value as\n      //   `snapshot`. That means this subscription does *not* have changes relative\n      //   to its base, so the current `snapshot` is valid to use as a backup.\n      if (!subscription.stale) {\n        subscription.backup = subscription.snapshot;\n        return;\n      }\n\n      var snapshot = subscription.snapshot;\n      var backup = RelayReader.read(source, snapshot.selector, _this2._resolverCache);\n      var nextData = recycleNodesInto(snapshot.data, backup.data);\n      backup.data = nextData; // backup owns the snapshot and can safely mutate\n\n      subscription.backup = backup;\n    });\n  };\n\n  _proto.restoreSubscriptions = function restoreSubscriptions() {\n    this._subscriptions.forEach(function (subscription) {\n      var backup = subscription.backup;\n      subscription.backup = null;\n\n      if (backup) {\n        if (backup.data !== subscription.snapshot.data) {\n          subscription.stale = true;\n        }\n\n        subscription.snapshot = {\n          data: subscription.snapshot.data,\n          isMissingData: backup.isMissingData,\n          missingClientEdges: backup.missingClientEdges,\n          seenRecords: backup.seenRecords,\n          selector: backup.selector,\n          missingRequiredFields: backup.missingRequiredFields\n        };\n      } else {\n        subscription.stale = true;\n      }\n    });\n  };\n\n  _proto.updateSubscriptions = function updateSubscriptions(source, updatedRecordIDs, updatedOwners, sourceOperation) {\n    var _this3 = this;\n\n    var hasUpdatedRecords = updatedRecordIDs.size !== 0;\n\n    this._subscriptions.forEach(function (subscription) {\n      var owner = _this3._updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation);\n\n      if (owner != null) {\n        updatedOwners.push(owner);\n      }\n    });\n  }\n  /**\n   * Notifies the callback for the subscription if the data for the associated\n   * snapshot has changed.\n   * Additionally, updates the subscription snapshot with the latest snapshot,\n   * and marks it as not stale.\n   * Returns the owner (RequestDescriptor) if the subscription was affected by the\n   * latest update, or null if it was not affected.\n   */\n  ;\n\n  _proto._updateSubscription = function _updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation) {\n    var backup = subscription.backup,\n        callback = subscription.callback,\n        snapshot = subscription.snapshot,\n        stale = subscription.stale;\n    var hasOverlappingUpdates = hasUpdatedRecords && hasOverlappingIDs(snapshot.seenRecords, updatedRecordIDs);\n\n    if (!stale && !hasOverlappingUpdates) {\n      return;\n    }\n\n    var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector, this._resolverCache) : backup;\n    var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);\n    nextSnapshot = {\n      data: nextData,\n      isMissingData: nextSnapshot.isMissingData,\n      missingClientEdges: nextSnapshot.missingClientEdges,\n      seenRecords: nextSnapshot.seenRecords,\n      selector: nextSnapshot.selector,\n      missingRequiredFields: nextSnapshot.missingRequiredFields\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    subscription.snapshot = nextSnapshot;\n    subscription.stale = false;\n\n    if (nextSnapshot.data !== snapshot.data) {\n      if (this.__log && RelayFeatureFlags.ENABLE_NOTIFY_SUBSCRIPTION) {\n        this.__log({\n          name: 'store.notify.subscription',\n          sourceOperation: sourceOperation,\n          snapshot: snapshot,\n          nextSnapshot: nextSnapshot\n        });\n      }\n\n      callback(nextSnapshot);\n      return snapshot.selector.owner;\n    }\n  };\n\n  return RelayStoreSubscriptions;\n}();\n\nmodule.exports = RelayStoreSubscriptions;"]},"metadata":{},"sourceType":"script"}