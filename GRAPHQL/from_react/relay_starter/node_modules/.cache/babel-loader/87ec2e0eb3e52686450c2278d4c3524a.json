{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar _require = require('./QueryResource'),\n    getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;\n\nvar SuspenseResource = require('./SuspenseResource');\n\nvar invariant = require('invariant');\n\nvar _require2 = require('relay-runtime'),\n    RelayFeatureFlags = _require2.RelayFeatureFlags,\n    _require2$__internal = _require2.__internal,\n    fetchQuery = _require2$__internal.fetchQuery,\n    getPromiseForActiveRequest = _require2$__internal.getPromiseForActiveRequest,\n    createOperationDescriptor = _require2.createOperationDescriptor,\n    getFragmentIdentifier = _require2.getFragmentIdentifier,\n    getPendingOperationsForFragment = _require2.getPendingOperationsForFragment,\n    getSelector = _require2.getSelector,\n    getVariablesFromFragment = _require2.getVariablesFromFragment,\n    isPromise = _require2.isPromise,\n    recycleNodesInto = _require2.recycleNodesInto,\n    reportMissingRequiredFields = _require2.reportMissingRequiredFields;\n\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function'; // TODO: Fix to not rely on LRU. If the number of active fragments exceeds this\n// capacity, readSpec() will fail to find cached entries and break object\n// identity even if data hasn't changed.\n\nvar CACHE_CAPACITY = 1000000; // this is frozen so that users don't accidentally push data into the array\n\nvar CONSTANT_READONLY_EMPTY_ARRAY = Object.freeze([]);\n\nfunction isMissingData(snapshot) {\n  if (Array.isArray(snapshot)) {\n    return snapshot.some(function (s) {\n      return s.isMissingData;\n    });\n  }\n\n  return snapshot.isMissingData;\n}\n\nfunction hasMissingClientEdges(snapshot) {\n  var _snapshot$missingClie, _snapshot$missingClie2;\n\n  if (Array.isArray(snapshot)) {\n    return snapshot.some(function (s) {\n      var _s$missingClientEdges, _s$missingClientEdges2;\n\n      return ((_s$missingClientEdges = (_s$missingClientEdges2 = s.missingClientEdges) === null || _s$missingClientEdges2 === void 0 ? void 0 : _s$missingClientEdges2.length) !== null && _s$missingClientEdges !== void 0 ? _s$missingClientEdges : 0) > 0;\n    });\n  }\n\n  return ((_snapshot$missingClie = (_snapshot$missingClie2 = snapshot.missingClientEdges) === null || _snapshot$missingClie2 === void 0 ? void 0 : _snapshot$missingClie2.length) !== null && _snapshot$missingClie !== void 0 ? _snapshot$missingClie : 0) > 0;\n}\n\nfunction singularOrPluralForEach(snapshot, f) {\n  if (Array.isArray(snapshot)) {\n    snapshot.forEach(f);\n  } else {\n    f(snapshot);\n  }\n}\n\nfunction getFragmentResult(cacheKey, snapshot, storeEpoch) {\n  if (Array.isArray(snapshot)) {\n    return {\n      cacheKey: cacheKey,\n      snapshot: snapshot,\n      data: snapshot.map(function (s) {\n        return s.data;\n      }),\n      isMissingData: isMissingData(snapshot),\n      storeEpoch: storeEpoch\n    };\n  }\n\n  return {\n    cacheKey: cacheKey,\n    snapshot: snapshot,\n    data: snapshot.data,\n    isMissingData: isMissingData(snapshot),\n    storeEpoch: storeEpoch\n  };\n}\n/**\n * The purpose of this cache is to allow information to be passed from an\n * initial read which suspends through to the commit that follows a subsequent\n * successful read. Specifically, the QueryResource result for the data fetch\n * is passed through so that that query can be retained on commit.\n */\n\n\nvar ClientEdgeQueryResultsCache = /*#__PURE__*/function () {\n  function ClientEdgeQueryResultsCache(environment) {\n    (0, _defineProperty2[\"default\"])(this, \"_cache\", new Map());\n    (0, _defineProperty2[\"default\"])(this, \"_retainCounts\", new Map());\n    this._environment = environment;\n  }\n\n  var _proto = ClientEdgeQueryResultsCache.prototype;\n\n  _proto.get = function get(fragmentIdentifier) {\n    var _this$_cache$get$, _this$_cache$get;\n\n    return (_this$_cache$get$ = (_this$_cache$get = this._cache.get(fragmentIdentifier)) === null || _this$_cache$get === void 0 ? void 0 : _this$_cache$get[0]) !== null && _this$_cache$get$ !== void 0 ? _this$_cache$get$ : undefined;\n  };\n\n  _proto.recordQueryResults = function recordQueryResults(fragmentIdentifier, value) {\n    var _this = this;\n\n    var existing = this._cache.get(fragmentIdentifier);\n\n    if (!existing) {\n      var suspenseResource = new SuspenseResource(function () {\n        return _this._retain(fragmentIdentifier);\n      });\n\n      this._cache.set(fragmentIdentifier, [value, suspenseResource]);\n\n      suspenseResource.temporaryRetain(this._environment);\n    } else {\n      var existingResults = existing[0],\n          _suspenseResource = existing[1];\n      value.forEach(function (queryResult) {\n        existingResults.push(queryResult);\n      });\n\n      _suspenseResource.temporaryRetain(this._environment);\n    }\n  };\n\n  _proto._retain = function _retain(id) {\n    var _this2 = this;\n\n    var _this$_retainCounts$g;\n\n    var retainCount = ((_this$_retainCounts$g = this._retainCounts.get(id)) !== null && _this$_retainCounts$g !== void 0 ? _this$_retainCounts$g : 0) + 1;\n\n    this._retainCounts.set(id, retainCount);\n\n    return {\n      dispose: function dispose() {\n        var _this$_retainCounts$g2;\n\n        var newRetainCount = ((_this$_retainCounts$g2 = _this2._retainCounts.get(id)) !== null && _this$_retainCounts$g2 !== void 0 ? _this$_retainCounts$g2 : 0) - 1;\n\n        if (newRetainCount > 0) {\n          _this2._retainCounts.set(id, newRetainCount);\n        } else {\n          _this2._retainCounts[\"delete\"](id);\n\n          _this2._cache[\"delete\"](id);\n        }\n      }\n    };\n  };\n\n  return ClientEdgeQueryResultsCache;\n}();\n\nvar FragmentResourceImpl = /*#__PURE__*/function () {\n  function FragmentResourceImpl(environment) {\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n      this._clientEdgeQueryResultsCache = new ClientEdgeQueryResultsCache(environment);\n    }\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to read the data for a fragment, or suspend if the fragment is being\n   * fetched.\n   */\n\n\n  var _proto2 = FragmentResourceImpl.prototype;\n\n  _proto2.read = function read(fragmentNode, fragmentRef, componentDisplayName, fragmentKey) {\n    return this.readWithIdentifier(fragmentNode, fragmentRef, getFragmentIdentifier(fragmentNode, fragmentRef), componentDisplayName, fragmentKey);\n  }\n  /**\n   * Like `read`, but with a pre-computed fragmentIdentifier that should be\n   * equal to `getFragmentIdentifier(fragmentNode, fragmentRef)` from the\n   * arguments.\n   */\n  ;\n\n  _proto2.readWithIdentifier = function readWithIdentifier(fragmentNode, fragmentRef, fragmentIdentifier, componentDisplayName, fragmentKey) {\n    var _this3 = this;\n\n    var _fragmentNode$metadat, _clientEdgePromises;\n\n    var environment = this._environment; // If fragmentRef is null or undefined, pass it directly through.\n    // This is a convenience when consuming fragments via a HOC API, when the\n    // prop corresponding to the fragment ref might be passed as null.\n\n    if (fragmentRef == null) {\n      return {\n        cacheKey: fragmentIdentifier,\n        data: null,\n        isMissingData: false,\n        snapshot: null,\n        storeEpoch: 0\n      };\n    }\n\n    var storeEpoch = environment.getStore().getEpoch(); // If fragmentRef is plural, ensure that it is an array.\n    // If it's empty, return the empty array directly before doing any more work.\n\n    if ((fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true) {\n      !Array.isArray(fragmentRef) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentKey != null ? \" for key `\".concat(fragmentKey, \"`\") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : invariant(false) : void 0;\n\n      if (fragmentRef.length === 0) {\n        return {\n          cacheKey: fragmentIdentifier,\n          data: CONSTANT_READONLY_EMPTY_ARRAY,\n          isMissingData: false,\n          snapshot: CONSTANT_READONLY_EMPTY_ARRAY,\n          storeEpoch: storeEpoch\n        };\n      }\n    } // Now we actually attempt to read the fragment:\n    // 1. Check if there's a cached value for this fragment\n\n\n    var cachedValue = this._cache.get(fragmentIdentifier);\n\n    if (cachedValue != null) {\n      if (cachedValue.kind === 'pending' && isPromise(cachedValue.promise)) {\n        environment.__log({\n          name: 'suspense.fragment',\n          data: cachedValue.result.data,\n          fragment: fragmentNode,\n          isRelayHooks: true,\n          isMissingData: cachedValue.result.isMissingData,\n          isPromiseCached: true,\n          pendingOperations: cachedValue.pendingOperations\n        });\n\n        throw cachedValue.promise;\n      }\n\n      if (cachedValue.kind === 'done' && cachedValue.result.snapshot) {\n        this._reportMissingRequiredFieldsInSnapshot(cachedValue.result.snapshot);\n\n        return cachedValue.result;\n      }\n    } // 2. If not, try reading the fragment from the Relay store.\n    // If the snapshot has data, return it and save it in cache\n\n\n    var fragmentSelector = getSelector(fragmentNode, fragmentRef);\n    !(fragmentSelector != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\\n' + \"- Forgetting to spread `%s` in `%s`'s parent's fragment.\\n\" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'In this case, pass `null` if the conditions for evaluating the ' + 'fragment are not met (e.g. if the `@include(if)` value is false.)', fragmentNode.name, fragmentNode.name, componentDisplayName, fragmentNode.name, fragmentKey == null ? 'a fragment reference' : \"the `\".concat(fragmentKey, \"`\"), componentDisplayName) : invariant(false) : void 0;\n    var snapshot = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors.map(function (s) {\n      return environment.lookup(s);\n    }) : environment.lookup(fragmentSelector);\n    var fragmentResult = getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);\n\n    if (!fragmentResult.isMissingData) {\n      this._reportMissingRequiredFieldsInSnapshot(snapshot);\n\n      this._cache.set(fragmentIdentifier, {\n        kind: 'done',\n        result: fragmentResult\n      });\n\n      return fragmentResult;\n    } // 3. If we don't have data in the store, there's two cases where we should\n    // suspend to await the data: First if any client edges were traversed where\n    // the destination record was missing data; in that case we initiate a query\n    // here to fetch the missing data. Second, there may already be a request\n    // in flight for the fragment's parent query, or for another operation that\n    //  may affect the parent's query data, such as a mutation or subscription.\n    // For any of these cases we can get a promise, which we will cache and\n    // suspend on.\n    // First, initiate a query for any client edges that were missing data:\n\n\n    var clientEdgeRequests = null;\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && hasMissingClientEdges(snapshot)) {\n      clientEdgeRequests = [];\n      var queryResource = getQueryResourceForEnvironment(this._environment);\n      var queryResults = [];\n      singularOrPluralForEach(snapshot, function (snap) {\n        var _snap$missingClientEd;\n\n        (_snap$missingClientEd = snap.missingClientEdges) === null || _snap$missingClientEd === void 0 ? void 0 : _snap$missingClientEd.forEach(function (_ref) {\n          var _clientEdgeRequests;\n\n          var request = _ref.request,\n              clientEdgeDestinationID = _ref.clientEdgeDestinationID;\n\n          var _this3$_performClient = _this3._performClientEdgeQuery(queryResource, fragmentNode, fragmentRef, request, clientEdgeDestinationID),\n              queryResult = _this3$_performClient.queryResult,\n              requestDescriptor = _this3$_performClient.requestDescriptor;\n\n          queryResults.push(queryResult);\n          (_clientEdgeRequests = clientEdgeRequests) === null || _clientEdgeRequests === void 0 ? void 0 : _clientEdgeRequests.push(requestDescriptor);\n        });\n      }); // Store the query so that it can be retained when our own fragment is\n      // subscribed to. This merges with any existing query results:\n\n      !(this._clientEdgeQueryResultsCache != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Client edge query result cache should exist when ENABLE_CLIENT_EDGES is on.') : invariant(false) : void 0;\n\n      this._clientEdgeQueryResultsCache.recordQueryResults(fragmentIdentifier, queryResults);\n    }\n\n    var clientEdgePromises = null;\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && clientEdgeRequests) {\n      clientEdgePromises = clientEdgeRequests.map(function (request) {\n        return getPromiseForActiveRequest(_this3._environment, request);\n      }).filter(function (p) {\n        return p != null;\n      });\n    } // Finally look for operations in flight for our parent query:\n\n\n    var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;\n\n    var parentQueryPromiseResult = this._getAndSavePromiseForFragmentRequestInFlight(fragmentIdentifier, fragmentNode, fragmentOwner, fragmentResult);\n\n    var parentQueryPromiseResultPromise = parentQueryPromiseResult === null || parentQueryPromiseResult === void 0 ? void 0 : parentQueryPromiseResult.promise; // for refinement\n\n    if (((_clientEdgePromises = clientEdgePromises) === null || _clientEdgePromises === void 0 ? void 0 : _clientEdgePromises.length) || isPromise(parentQueryPromiseResultPromise)) {\n      var _parentQueryPromiseRe, _clientEdgeRequests2, _clientEdgePromises2;\n\n      environment.__log({\n        name: 'suspense.fragment',\n        data: fragmentResult.data,\n        fragment: fragmentNode,\n        isRelayHooks: true,\n        isPromiseCached: false,\n        isMissingData: fragmentResult.isMissingData,\n        pendingOperations: [].concat((0, _toConsumableArray2[\"default\"])((_parentQueryPromiseRe = parentQueryPromiseResult === null || parentQueryPromiseResult === void 0 ? void 0 : parentQueryPromiseResult.pendingOperations) !== null && _parentQueryPromiseRe !== void 0 ? _parentQueryPromiseRe : []), (0, _toConsumableArray2[\"default\"])((_clientEdgeRequests2 = clientEdgeRequests) !== null && _clientEdgeRequests2 !== void 0 ? _clientEdgeRequests2 : []))\n      });\n\n      throw ((_clientEdgePromises2 = clientEdgePromises) === null || _clientEdgePromises2 === void 0 ? void 0 : _clientEdgePromises2.length) ? Promise.all([parentQueryPromiseResultPromise].concat((0, _toConsumableArray2[\"default\"])(clientEdgePromises))) : parentQueryPromiseResultPromise;\n    }\n\n    this._reportMissingRequiredFieldsInSnapshot(snapshot);\n\n    return getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);\n  };\n\n  _proto2._performClientEdgeQuery = function _performClientEdgeQuery(queryResource, fragmentNode, fragmentRef, request, clientEdgeDestinationID) {\n    var originalVariables = getVariablesFromFragment(fragmentNode, fragmentRef);\n    var variables = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, originalVariables), {}, {\n      id: clientEdgeDestinationID // TODO should be a reserved name\n\n    });\n    var operation = createOperationDescriptor(request, variables, {} //  TODO cacheConfig should probably inherent from parent operation\n    );\n    var fetchObservable = fetchQuery(this._environment, operation);\n    var queryResult = queryResource.prepare(operation, fetchObservable // TODO should inherent render policy etc. from parent operation\n    );\n    return {\n      requestDescriptor: operation.request,\n      queryResult: queryResult\n    };\n  };\n\n  _proto2._reportMissingRequiredFieldsInSnapshot = function _reportMissingRequiredFieldsInSnapshot(snapshot) {\n    var _this4 = this;\n\n    if (Array.isArray(snapshot)) {\n      snapshot.forEach(function (s) {\n        if (s.missingRequiredFields != null) {\n          reportMissingRequiredFields(_this4._environment, s.missingRequiredFields);\n        }\n      });\n    } else {\n      if (snapshot.missingRequiredFields != null) {\n        reportMissingRequiredFields(this._environment, snapshot.missingRequiredFields);\n      }\n    }\n  };\n\n  _proto2.readSpec = function readSpec(fragmentNodes, fragmentRefs, componentDisplayName) {\n    var result = {};\n\n    for (var _key in fragmentNodes) {\n      result[_key] = this.read(fragmentNodes[_key], fragmentRefs[_key], componentDisplayName, _key);\n    }\n\n    return result;\n  };\n\n  _proto2.subscribe = function subscribe(fragmentResult, callback) {\n    var _this5 = this;\n\n    var environment = this._environment;\n    var cacheKey = fragmentResult.cacheKey;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return {\n        dispose: function dispose() {}\n      };\n    } // 1. Check for any updates missed during render phase\n    // TODO(T44066760): More efficiently detect if we missed an update\n\n\n    var _this$checkMissedUpda = this.checkMissedUpdates(fragmentResult),\n        didMissUpdates = _this$checkMissedUpda[0],\n        currentSnapshot = _this$checkMissedUpda[1]; // 2. If an update was missed, notify the component so it updates with\n    // the latest data.\n\n\n    if (didMissUpdates) {\n      callback();\n    } // 3. Establish subscriptions on the snapshot(s)\n\n\n    var disposables = [];\n\n    if (Array.isArray(renderedSnapshot)) {\n      !Array.isArray(currentSnapshot) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshots to be plural. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      currentSnapshot.forEach(function (snapshot, idx) {\n        disposables.push(environment.subscribe(snapshot, function (latestSnapshot) {\n          var storeEpoch = environment.getStore().getEpoch();\n\n          _this5._updatePluralSnapshot(cacheKey, currentSnapshot, latestSnapshot, idx, storeEpoch);\n\n          callback();\n        }));\n      });\n    } else {\n      !(currentSnapshot != null && !Array.isArray(currentSnapshot)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshot to be singular. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      disposables.push(environment.subscribe(currentSnapshot, function (latestSnapshot) {\n        var storeEpoch = environment.getStore().getEpoch();\n\n        _this5._cache.set(cacheKey, {\n          kind: 'done',\n          result: getFragmentResult(cacheKey, latestSnapshot, storeEpoch)\n        });\n\n        callback();\n      }));\n    }\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n      var _this$_clientEdgeQuer, _this$_clientEdgeQuer2;\n\n      var clientEdgeQueryResults = (_this$_clientEdgeQuer = (_this$_clientEdgeQuer2 = this._clientEdgeQueryResultsCache) === null || _this$_clientEdgeQuer2 === void 0 ? void 0 : _this$_clientEdgeQuer2.get(cacheKey)) !== null && _this$_clientEdgeQuer !== void 0 ? _this$_clientEdgeQuer : undefined;\n\n      if (clientEdgeQueryResults === null || clientEdgeQueryResults === void 0 ? void 0 : clientEdgeQueryResults.length) {\n        var queryResource = getQueryResourceForEnvironment(this._environment);\n        clientEdgeQueryResults.forEach(function (queryResult) {\n          disposables.push(queryResource.retain(queryResult));\n        });\n      }\n    }\n\n    return {\n      dispose: function dispose() {\n        disposables.forEach(function (s) {\n          return s.dispose();\n        });\n\n        _this5._cache[\"delete\"](cacheKey);\n      }\n    };\n  };\n\n  _proto2.subscribeSpec = function subscribeSpec(fragmentResults, callback) {\n    var _this6 = this;\n\n    var disposables = Object.keys(fragmentResults).map(function (key) {\n      return _this6.subscribe(fragmentResults[key], callback);\n    });\n    return {\n      dispose: function dispose() {\n        disposables.forEach(function (disposable) {\n          disposable.dispose();\n        });\n      }\n    };\n  };\n\n  _proto2.checkMissedUpdates = function checkMissedUpdates(fragmentResult) {\n    var environment = this._environment;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return [false, null];\n    }\n\n    var storeEpoch = null; // Bail out if the store hasn't been written since last read\n\n    storeEpoch = environment.getStore().getEpoch();\n\n    if (fragmentResult.storeEpoch === storeEpoch) {\n      return [false, fragmentResult.snapshot];\n    }\n\n    var cacheKey = fragmentResult.cacheKey;\n\n    if (Array.isArray(renderedSnapshot)) {\n      var didMissUpdates = false;\n      var currentSnapshots = [];\n      renderedSnapshot.forEach(function (snapshot, idx) {\n        var currentSnapshot = environment.lookup(snapshot.selector);\n        var renderData = snapshot.data;\n        var currentData = currentSnapshot.data;\n        var updatedData = recycleNodesInto(renderData, currentData);\n\n        if (updatedData !== renderData) {\n          currentSnapshot = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, currentSnapshot), {}, {\n            data: updatedData\n          });\n          didMissUpdates = true;\n        }\n\n        currentSnapshots[idx] = currentSnapshot;\n      }); // Only update the cache when the data is changed to avoid\n      // returning different `data` instances\n\n      if (didMissUpdates) {\n        this._cache.set(cacheKey, {\n          kind: 'done',\n          result: getFragmentResult(cacheKey, currentSnapshots, storeEpoch)\n        });\n      }\n\n      return [didMissUpdates, currentSnapshots];\n    }\n\n    var currentSnapshot = environment.lookup(renderedSnapshot.selector);\n    var renderData = renderedSnapshot.data;\n    var currentData = currentSnapshot.data;\n    var updatedData = recycleNodesInto(renderData, currentData);\n    var updatedCurrentSnapshot = {\n      data: updatedData,\n      isMissingData: currentSnapshot.isMissingData,\n      missingClientEdges: currentSnapshot.missingClientEdges,\n      seenRecords: currentSnapshot.seenRecords,\n      selector: currentSnapshot.selector,\n      missingRequiredFields: currentSnapshot.missingRequiredFields\n    };\n\n    if (updatedData !== renderData) {\n      this._cache.set(cacheKey, {\n        kind: 'done',\n        result: getFragmentResult(cacheKey, updatedCurrentSnapshot, storeEpoch)\n      });\n    }\n\n    return [updatedData !== renderData, updatedCurrentSnapshot];\n  };\n\n  _proto2.checkMissedUpdatesSpec = function checkMissedUpdatesSpec(fragmentResults) {\n    var _this7 = this;\n\n    return Object.keys(fragmentResults).some(function (key) {\n      return _this7.checkMissedUpdates(fragmentResults[key])[0];\n    });\n  };\n\n  _proto2._getAndSavePromiseForFragmentRequestInFlight = function _getAndSavePromiseForFragmentRequestInFlight(cacheKey, fragmentNode, fragmentOwner, fragmentResult) {\n    var _this8 = this;\n\n    var pendingOperationsResult = getPendingOperationsForFragment(this._environment, fragmentNode, fragmentOwner);\n\n    if (pendingOperationsResult == null) {\n      return null;\n    } // When the Promise for the request resolves, we need to make sure to\n    // update the cache with the latest data available in the store before\n    // resolving the Promise\n\n\n    var networkPromise = pendingOperationsResult.promise;\n    var pendingOperations = pendingOperationsResult.pendingOperations;\n    var promise = networkPromise.then(function () {\n      _this8._cache[\"delete\"](cacheKey);\n    })[\"catch\"](function (error) {\n      _this8._cache[\"delete\"](cacheKey);\n    }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n    promise.displayName = networkPromise.displayName;\n\n    this._cache.set(cacheKey, {\n      kind: 'pending',\n      pendingOperations: pendingOperations,\n      promise: promise,\n      result: fragmentResult\n    });\n\n    return {\n      promise: promise,\n      pendingOperations: pendingOperations\n    };\n  };\n\n  _proto2._updatePluralSnapshot = function _updatePluralSnapshot(cacheKey, baseSnapshots, latestSnapshot, idx, storeEpoch) {\n    var _currentFragmentResul;\n\n    var currentFragmentResult = this._cache.get(cacheKey);\n\n    if (isPromise(currentFragmentResult)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var currentSnapshot = currentFragmentResult === null || currentFragmentResult === void 0 ? void 0 : (_currentFragmentResul = currentFragmentResult.result) === null || _currentFragmentResul === void 0 ? void 0 : _currentFragmentResul.snapshot;\n\n    if (currentSnapshot && !Array.isArray(currentSnapshot)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var nextSnapshots = currentSnapshot ? (0, _toConsumableArray2[\"default\"])(currentSnapshot) : (0, _toConsumableArray2[\"default\"])(baseSnapshots);\n    nextSnapshots[idx] = latestSnapshot;\n\n    this._cache.set(cacheKey, {\n      kind: 'done',\n      result: getFragmentResult(cacheKey, nextSnapshots, storeEpoch)\n    });\n  };\n\n  return FragmentResourceImpl;\n}();\n\nfunction reportInvalidCachedData(nodeName) {\n  !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to find cached data for plural fragment `%s` when ' + 'receiving a subscription. ' + \"If you're seeing this, this is likely a bug in Relay.\", nodeName) : invariant(false) : void 0;\n}\n\nfunction createFragmentResource(environment) {\n  return new FragmentResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getFragmentResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createFragmentResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createFragmentResource: createFragmentResource,\n  getFragmentResourceForEnvironment: getFragmentResourceForEnvironment\n};","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/react-relay/lib/relay-hooks/FragmentResource.js"],"names":["_interopRequireDefault","require","_objectSpread2","_defineProperty2","_toConsumableArray2","LRUCache","_require","getQueryResourceForEnvironment","SuspenseResource","invariant","_require2","RelayFeatureFlags","_require2$__internal","__internal","fetchQuery","getPromiseForActiveRequest","createOperationDescriptor","getFragmentIdentifier","getPendingOperationsForFragment","getSelector","getVariablesFromFragment","isPromise","recycleNodesInto","reportMissingRequiredFields","WEAKMAP_SUPPORTED","WeakMap","CACHE_CAPACITY","CONSTANT_READONLY_EMPTY_ARRAY","Object","freeze","isMissingData","snapshot","Array","isArray","some","s","hasMissingClientEdges","_snapshot$missingClie","_snapshot$missingClie2","_s$missingClientEdges","_s$missingClientEdges2","missingClientEdges","length","singularOrPluralForEach","f","forEach","getFragmentResult","cacheKey","storeEpoch","data","map","ClientEdgeQueryResultsCache","environment","Map","_environment","_proto","prototype","get","fragmentIdentifier","_this$_cache$get$","_this$_cache$get","_cache","undefined","recordQueryResults","value","_this","existing","suspenseResource","_retain","set","temporaryRetain","existingResults","_suspenseResource","queryResult","push","id","_this2","_this$_retainCounts$g","retainCount","_retainCounts","dispose","_this$_retainCounts$g2","newRetainCount","FragmentResourceImpl","create","ENABLE_CLIENT_EDGES","_clientEdgeQueryResultsCache","_proto2","read","fragmentNode","fragmentRef","componentDisplayName","fragmentKey","readWithIdentifier","_this3","_fragmentNode$metadat","_clientEdgePromises","getStore","getEpoch","metadata","plural","process","env","NODE_ENV","concat","name","cachedValue","kind","promise","__log","result","fragment","isRelayHooks","isPromiseCached","pendingOperations","_reportMissingRequiredFieldsInSnapshot","fragmentSelector","selectors","lookup","fragmentResult","clientEdgeRequests","queryResource","queryResults","snap","_snap$missingClientEd","_ref","_clientEdgeRequests","request","clientEdgeDestinationID","_this3$_performClient","_performClientEdgeQuery","requestDescriptor","clientEdgePromises","filter","p","fragmentOwner","owner","parentQueryPromiseResult","_getAndSavePromiseForFragmentRequestInFlight","parentQueryPromiseResultPromise","_parentQueryPromiseRe","_clientEdgeRequests2","_clientEdgePromises2","Promise","all","originalVariables","variables","operation","fetchObservable","prepare","_this4","missingRequiredFields","readSpec","fragmentNodes","fragmentRefs","_key","subscribe","callback","_this5","renderedSnapshot","_this$checkMissedUpda","checkMissedUpdates","didMissUpdates","currentSnapshot","disposables","idx","latestSnapshot","_updatePluralSnapshot","_this$_clientEdgeQuer","_this$_clientEdgeQuer2","clientEdgeQueryResults","retain","subscribeSpec","fragmentResults","_this6","keys","key","disposable","currentSnapshots","selector","renderData","currentData","updatedData","updatedCurrentSnapshot","seenRecords","checkMissedUpdatesSpec","_this7","_this8","pendingOperationsResult","networkPromise","then","error","displayName","baseSnapshots","_currentFragmentResul","currentFragmentResult","reportInvalidCachedData","node","nextSnapshots","nodeName","createFragmentResource","dataResources","getFragmentResourceForEnvironment","cached","newDataResource","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar _require = require('./QueryResource'),\n    getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;\n\nvar SuspenseResource = require('./SuspenseResource');\n\nvar invariant = require('invariant');\n\nvar _require2 = require('relay-runtime'),\n    RelayFeatureFlags = _require2.RelayFeatureFlags,\n    _require2$__internal = _require2.__internal,\n    fetchQuery = _require2$__internal.fetchQuery,\n    getPromiseForActiveRequest = _require2$__internal.getPromiseForActiveRequest,\n    createOperationDescriptor = _require2.createOperationDescriptor,\n    getFragmentIdentifier = _require2.getFragmentIdentifier,\n    getPendingOperationsForFragment = _require2.getPendingOperationsForFragment,\n    getSelector = _require2.getSelector,\n    getVariablesFromFragment = _require2.getVariablesFromFragment,\n    isPromise = _require2.isPromise,\n    recycleNodesInto = _require2.recycleNodesInto,\n    reportMissingRequiredFields = _require2.reportMissingRequiredFields;\n\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\n// TODO: Fix to not rely on LRU. If the number of active fragments exceeds this\n// capacity, readSpec() will fail to find cached entries and break object\n// identity even if data hasn't changed.\nvar CACHE_CAPACITY = 1000000; // this is frozen so that users don't accidentally push data into the array\n\nvar CONSTANT_READONLY_EMPTY_ARRAY = Object.freeze([]);\n\nfunction isMissingData(snapshot) {\n  if (Array.isArray(snapshot)) {\n    return snapshot.some(function (s) {\n      return s.isMissingData;\n    });\n  }\n\n  return snapshot.isMissingData;\n}\n\nfunction hasMissingClientEdges(snapshot) {\n  var _snapshot$missingClie, _snapshot$missingClie2;\n\n  if (Array.isArray(snapshot)) {\n    return snapshot.some(function (s) {\n      var _s$missingClientEdges, _s$missingClientEdges2;\n\n      return ((_s$missingClientEdges = (_s$missingClientEdges2 = s.missingClientEdges) === null || _s$missingClientEdges2 === void 0 ? void 0 : _s$missingClientEdges2.length) !== null && _s$missingClientEdges !== void 0 ? _s$missingClientEdges : 0) > 0;\n    });\n  }\n\n  return ((_snapshot$missingClie = (_snapshot$missingClie2 = snapshot.missingClientEdges) === null || _snapshot$missingClie2 === void 0 ? void 0 : _snapshot$missingClie2.length) !== null && _snapshot$missingClie !== void 0 ? _snapshot$missingClie : 0) > 0;\n}\n\nfunction singularOrPluralForEach(snapshot, f) {\n  if (Array.isArray(snapshot)) {\n    snapshot.forEach(f);\n  } else {\n    f(snapshot);\n  }\n}\n\nfunction getFragmentResult(cacheKey, snapshot, storeEpoch) {\n  if (Array.isArray(snapshot)) {\n    return {\n      cacheKey: cacheKey,\n      snapshot: snapshot,\n      data: snapshot.map(function (s) {\n        return s.data;\n      }),\n      isMissingData: isMissingData(snapshot),\n      storeEpoch: storeEpoch\n    };\n  }\n\n  return {\n    cacheKey: cacheKey,\n    snapshot: snapshot,\n    data: snapshot.data,\n    isMissingData: isMissingData(snapshot),\n    storeEpoch: storeEpoch\n  };\n}\n/**\n * The purpose of this cache is to allow information to be passed from an\n * initial read which suspends through to the commit that follows a subsequent\n * successful read. Specifically, the QueryResource result for the data fetch\n * is passed through so that that query can be retained on commit.\n */\n\n\nvar ClientEdgeQueryResultsCache = /*#__PURE__*/function () {\n  function ClientEdgeQueryResultsCache(environment) {\n    (0, _defineProperty2[\"default\"])(this, \"_cache\", new Map());\n    (0, _defineProperty2[\"default\"])(this, \"_retainCounts\", new Map());\n    this._environment = environment;\n  }\n\n  var _proto = ClientEdgeQueryResultsCache.prototype;\n\n  _proto.get = function get(fragmentIdentifier) {\n    var _this$_cache$get$, _this$_cache$get;\n\n    return (_this$_cache$get$ = (_this$_cache$get = this._cache.get(fragmentIdentifier)) === null || _this$_cache$get === void 0 ? void 0 : _this$_cache$get[0]) !== null && _this$_cache$get$ !== void 0 ? _this$_cache$get$ : undefined;\n  };\n\n  _proto.recordQueryResults = function recordQueryResults(fragmentIdentifier, value) {\n    var _this = this;\n\n    var existing = this._cache.get(fragmentIdentifier);\n\n    if (!existing) {\n      var suspenseResource = new SuspenseResource(function () {\n        return _this._retain(fragmentIdentifier);\n      });\n\n      this._cache.set(fragmentIdentifier, [value, suspenseResource]);\n\n      suspenseResource.temporaryRetain(this._environment);\n    } else {\n      var existingResults = existing[0],\n          _suspenseResource = existing[1];\n      value.forEach(function (queryResult) {\n        existingResults.push(queryResult);\n      });\n\n      _suspenseResource.temporaryRetain(this._environment);\n    }\n  };\n\n  _proto._retain = function _retain(id) {\n    var _this2 = this;\n\n    var _this$_retainCounts$g;\n\n    var retainCount = ((_this$_retainCounts$g = this._retainCounts.get(id)) !== null && _this$_retainCounts$g !== void 0 ? _this$_retainCounts$g : 0) + 1;\n\n    this._retainCounts.set(id, retainCount);\n\n    return {\n      dispose: function dispose() {\n        var _this$_retainCounts$g2;\n\n        var newRetainCount = ((_this$_retainCounts$g2 = _this2._retainCounts.get(id)) !== null && _this$_retainCounts$g2 !== void 0 ? _this$_retainCounts$g2 : 0) - 1;\n\n        if (newRetainCount > 0) {\n          _this2._retainCounts.set(id, newRetainCount);\n        } else {\n          _this2._retainCounts[\"delete\"](id);\n\n          _this2._cache[\"delete\"](id);\n        }\n      }\n    };\n  };\n\n  return ClientEdgeQueryResultsCache;\n}();\n\nvar FragmentResourceImpl = /*#__PURE__*/function () {\n  function FragmentResourceImpl(environment) {\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n      this._clientEdgeQueryResultsCache = new ClientEdgeQueryResultsCache(environment);\n    }\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to read the data for a fragment, or suspend if the fragment is being\n   * fetched.\n   */\n\n\n  var _proto2 = FragmentResourceImpl.prototype;\n\n  _proto2.read = function read(fragmentNode, fragmentRef, componentDisplayName, fragmentKey) {\n    return this.readWithIdentifier(fragmentNode, fragmentRef, getFragmentIdentifier(fragmentNode, fragmentRef), componentDisplayName, fragmentKey);\n  }\n  /**\n   * Like `read`, but with a pre-computed fragmentIdentifier that should be\n   * equal to `getFragmentIdentifier(fragmentNode, fragmentRef)` from the\n   * arguments.\n   */\n  ;\n\n  _proto2.readWithIdentifier = function readWithIdentifier(fragmentNode, fragmentRef, fragmentIdentifier, componentDisplayName, fragmentKey) {\n    var _this3 = this;\n\n    var _fragmentNode$metadat, _clientEdgePromises;\n\n    var environment = this._environment; // If fragmentRef is null or undefined, pass it directly through.\n    // This is a convenience when consuming fragments via a HOC API, when the\n    // prop corresponding to the fragment ref might be passed as null.\n\n    if (fragmentRef == null) {\n      return {\n        cacheKey: fragmentIdentifier,\n        data: null,\n        isMissingData: false,\n        snapshot: null,\n        storeEpoch: 0\n      };\n    }\n\n    var storeEpoch = environment.getStore().getEpoch(); // If fragmentRef is plural, ensure that it is an array.\n    // If it's empty, return the empty array directly before doing any more work.\n\n    if ((fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true) {\n      !Array.isArray(fragmentRef) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentKey != null ? \" for key `\".concat(fragmentKey, \"`\") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : invariant(false) : void 0;\n\n      if (fragmentRef.length === 0) {\n        return {\n          cacheKey: fragmentIdentifier,\n          data: CONSTANT_READONLY_EMPTY_ARRAY,\n          isMissingData: false,\n          snapshot: CONSTANT_READONLY_EMPTY_ARRAY,\n          storeEpoch: storeEpoch\n        };\n      }\n    } // Now we actually attempt to read the fragment:\n    // 1. Check if there's a cached value for this fragment\n\n\n    var cachedValue = this._cache.get(fragmentIdentifier);\n\n    if (cachedValue != null) {\n      if (cachedValue.kind === 'pending' && isPromise(cachedValue.promise)) {\n        environment.__log({\n          name: 'suspense.fragment',\n          data: cachedValue.result.data,\n          fragment: fragmentNode,\n          isRelayHooks: true,\n          isMissingData: cachedValue.result.isMissingData,\n          isPromiseCached: true,\n          pendingOperations: cachedValue.pendingOperations\n        });\n\n        throw cachedValue.promise;\n      }\n\n      if (cachedValue.kind === 'done' && cachedValue.result.snapshot) {\n        this._reportMissingRequiredFieldsInSnapshot(cachedValue.result.snapshot);\n\n        return cachedValue.result;\n      }\n    } // 2. If not, try reading the fragment from the Relay store.\n    // If the snapshot has data, return it and save it in cache\n\n\n    var fragmentSelector = getSelector(fragmentNode, fragmentRef);\n    !(fragmentSelector != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\\n' + \"- Forgetting to spread `%s` in `%s`'s parent's fragment.\\n\" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'In this case, pass `null` if the conditions for evaluating the ' + 'fragment are not met (e.g. if the `@include(if)` value is false.)', fragmentNode.name, fragmentNode.name, componentDisplayName, fragmentNode.name, fragmentKey == null ? 'a fragment reference' : \"the `\".concat(fragmentKey, \"`\"), componentDisplayName) : invariant(false) : void 0;\n    var snapshot = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors.map(function (s) {\n      return environment.lookup(s);\n    }) : environment.lookup(fragmentSelector);\n    var fragmentResult = getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);\n\n    if (!fragmentResult.isMissingData) {\n      this._reportMissingRequiredFieldsInSnapshot(snapshot);\n\n      this._cache.set(fragmentIdentifier, {\n        kind: 'done',\n        result: fragmentResult\n      });\n\n      return fragmentResult;\n    } // 3. If we don't have data in the store, there's two cases where we should\n    // suspend to await the data: First if any client edges were traversed where\n    // the destination record was missing data; in that case we initiate a query\n    // here to fetch the missing data. Second, there may already be a request\n    // in flight for the fragment's parent query, or for another operation that\n    //  may affect the parent's query data, such as a mutation or subscription.\n    // For any of these cases we can get a promise, which we will cache and\n    // suspend on.\n    // First, initiate a query for any client edges that were missing data:\n\n\n    var clientEdgeRequests = null;\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && hasMissingClientEdges(snapshot)) {\n      clientEdgeRequests = [];\n      var queryResource = getQueryResourceForEnvironment(this._environment);\n      var queryResults = [];\n      singularOrPluralForEach(snapshot, function (snap) {\n        var _snap$missingClientEd;\n\n        (_snap$missingClientEd = snap.missingClientEdges) === null || _snap$missingClientEd === void 0 ? void 0 : _snap$missingClientEd.forEach(function (_ref) {\n          var _clientEdgeRequests;\n\n          var request = _ref.request,\n              clientEdgeDestinationID = _ref.clientEdgeDestinationID;\n\n          var _this3$_performClient = _this3._performClientEdgeQuery(queryResource, fragmentNode, fragmentRef, request, clientEdgeDestinationID),\n              queryResult = _this3$_performClient.queryResult,\n              requestDescriptor = _this3$_performClient.requestDescriptor;\n\n          queryResults.push(queryResult);\n          (_clientEdgeRequests = clientEdgeRequests) === null || _clientEdgeRequests === void 0 ? void 0 : _clientEdgeRequests.push(requestDescriptor);\n        });\n      }); // Store the query so that it can be retained when our own fragment is\n      // subscribed to. This merges with any existing query results:\n\n      !(this._clientEdgeQueryResultsCache != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Client edge query result cache should exist when ENABLE_CLIENT_EDGES is on.') : invariant(false) : void 0;\n\n      this._clientEdgeQueryResultsCache.recordQueryResults(fragmentIdentifier, queryResults);\n    }\n\n    var clientEdgePromises = null;\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES && clientEdgeRequests) {\n      clientEdgePromises = clientEdgeRequests.map(function (request) {\n        return getPromiseForActiveRequest(_this3._environment, request);\n      }).filter(function (p) {\n        return p != null;\n      });\n    } // Finally look for operations in flight for our parent query:\n\n\n    var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;\n\n    var parentQueryPromiseResult = this._getAndSavePromiseForFragmentRequestInFlight(fragmentIdentifier, fragmentNode, fragmentOwner, fragmentResult);\n\n    var parentQueryPromiseResultPromise = parentQueryPromiseResult === null || parentQueryPromiseResult === void 0 ? void 0 : parentQueryPromiseResult.promise; // for refinement\n\n    if (((_clientEdgePromises = clientEdgePromises) === null || _clientEdgePromises === void 0 ? void 0 : _clientEdgePromises.length) || isPromise(parentQueryPromiseResultPromise)) {\n      var _parentQueryPromiseRe, _clientEdgeRequests2, _clientEdgePromises2;\n\n      environment.__log({\n        name: 'suspense.fragment',\n        data: fragmentResult.data,\n        fragment: fragmentNode,\n        isRelayHooks: true,\n        isPromiseCached: false,\n        isMissingData: fragmentResult.isMissingData,\n        pendingOperations: [].concat((0, _toConsumableArray2[\"default\"])((_parentQueryPromiseRe = parentQueryPromiseResult === null || parentQueryPromiseResult === void 0 ? void 0 : parentQueryPromiseResult.pendingOperations) !== null && _parentQueryPromiseRe !== void 0 ? _parentQueryPromiseRe : []), (0, _toConsumableArray2[\"default\"])((_clientEdgeRequests2 = clientEdgeRequests) !== null && _clientEdgeRequests2 !== void 0 ? _clientEdgeRequests2 : []))\n      });\n\n      throw ((_clientEdgePromises2 = clientEdgePromises) === null || _clientEdgePromises2 === void 0 ? void 0 : _clientEdgePromises2.length) ? Promise.all([parentQueryPromiseResultPromise].concat((0, _toConsumableArray2[\"default\"])(clientEdgePromises))) : parentQueryPromiseResultPromise;\n    }\n\n    this._reportMissingRequiredFieldsInSnapshot(snapshot);\n\n    return getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);\n  };\n\n  _proto2._performClientEdgeQuery = function _performClientEdgeQuery(queryResource, fragmentNode, fragmentRef, request, clientEdgeDestinationID) {\n    var originalVariables = getVariablesFromFragment(fragmentNode, fragmentRef);\n    var variables = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, originalVariables), {}, {\n      id: clientEdgeDestinationID // TODO should be a reserved name\n\n    });\n    var operation = createOperationDescriptor(request, variables, {} //  TODO cacheConfig should probably inherent from parent operation\n    );\n    var fetchObservable = fetchQuery(this._environment, operation);\n    var queryResult = queryResource.prepare(operation, fetchObservable // TODO should inherent render policy etc. from parent operation\n    );\n    return {\n      requestDescriptor: operation.request,\n      queryResult: queryResult\n    };\n  };\n\n  _proto2._reportMissingRequiredFieldsInSnapshot = function _reportMissingRequiredFieldsInSnapshot(snapshot) {\n    var _this4 = this;\n\n    if (Array.isArray(snapshot)) {\n      snapshot.forEach(function (s) {\n        if (s.missingRequiredFields != null) {\n          reportMissingRequiredFields(_this4._environment, s.missingRequiredFields);\n        }\n      });\n    } else {\n      if (snapshot.missingRequiredFields != null) {\n        reportMissingRequiredFields(this._environment, snapshot.missingRequiredFields);\n      }\n    }\n  };\n\n  _proto2.readSpec = function readSpec(fragmentNodes, fragmentRefs, componentDisplayName) {\n    var result = {};\n\n    for (var _key in fragmentNodes) {\n      result[_key] = this.read(fragmentNodes[_key], fragmentRefs[_key], componentDisplayName, _key);\n    }\n\n    return result;\n  };\n\n  _proto2.subscribe = function subscribe(fragmentResult, callback) {\n    var _this5 = this;\n\n    var environment = this._environment;\n    var cacheKey = fragmentResult.cacheKey;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return {\n        dispose: function dispose() {}\n      };\n    } // 1. Check for any updates missed during render phase\n    // TODO(T44066760): More efficiently detect if we missed an update\n\n\n    var _this$checkMissedUpda = this.checkMissedUpdates(fragmentResult),\n        didMissUpdates = _this$checkMissedUpda[0],\n        currentSnapshot = _this$checkMissedUpda[1]; // 2. If an update was missed, notify the component so it updates with\n    // the latest data.\n\n\n    if (didMissUpdates) {\n      callback();\n    } // 3. Establish subscriptions on the snapshot(s)\n\n\n    var disposables = [];\n\n    if (Array.isArray(renderedSnapshot)) {\n      !Array.isArray(currentSnapshot) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshots to be plural. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      currentSnapshot.forEach(function (snapshot, idx) {\n        disposables.push(environment.subscribe(snapshot, function (latestSnapshot) {\n          var storeEpoch = environment.getStore().getEpoch();\n\n          _this5._updatePluralSnapshot(cacheKey, currentSnapshot, latestSnapshot, idx, storeEpoch);\n\n          callback();\n        }));\n      });\n    } else {\n      !(currentSnapshot != null && !Array.isArray(currentSnapshot)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshot to be singular. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      disposables.push(environment.subscribe(currentSnapshot, function (latestSnapshot) {\n        var storeEpoch = environment.getStore().getEpoch();\n\n        _this5._cache.set(cacheKey, {\n          kind: 'done',\n          result: getFragmentResult(cacheKey, latestSnapshot, storeEpoch)\n        });\n\n        callback();\n      }));\n    }\n\n    if (RelayFeatureFlags.ENABLE_CLIENT_EDGES) {\n      var _this$_clientEdgeQuer, _this$_clientEdgeQuer2;\n\n      var clientEdgeQueryResults = (_this$_clientEdgeQuer = (_this$_clientEdgeQuer2 = this._clientEdgeQueryResultsCache) === null || _this$_clientEdgeQuer2 === void 0 ? void 0 : _this$_clientEdgeQuer2.get(cacheKey)) !== null && _this$_clientEdgeQuer !== void 0 ? _this$_clientEdgeQuer : undefined;\n\n      if (clientEdgeQueryResults === null || clientEdgeQueryResults === void 0 ? void 0 : clientEdgeQueryResults.length) {\n        var queryResource = getQueryResourceForEnvironment(this._environment);\n        clientEdgeQueryResults.forEach(function (queryResult) {\n          disposables.push(queryResource.retain(queryResult));\n        });\n      }\n    }\n\n    return {\n      dispose: function dispose() {\n        disposables.forEach(function (s) {\n          return s.dispose();\n        });\n\n        _this5._cache[\"delete\"](cacheKey);\n      }\n    };\n  };\n\n  _proto2.subscribeSpec = function subscribeSpec(fragmentResults, callback) {\n    var _this6 = this;\n\n    var disposables = Object.keys(fragmentResults).map(function (key) {\n      return _this6.subscribe(fragmentResults[key], callback);\n    });\n    return {\n      dispose: function dispose() {\n        disposables.forEach(function (disposable) {\n          disposable.dispose();\n        });\n      }\n    };\n  };\n\n  _proto2.checkMissedUpdates = function checkMissedUpdates(fragmentResult) {\n    var environment = this._environment;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return [false, null];\n    }\n\n    var storeEpoch = null; // Bail out if the store hasn't been written since last read\n\n    storeEpoch = environment.getStore().getEpoch();\n\n    if (fragmentResult.storeEpoch === storeEpoch) {\n      return [false, fragmentResult.snapshot];\n    }\n\n    var cacheKey = fragmentResult.cacheKey;\n\n    if (Array.isArray(renderedSnapshot)) {\n      var didMissUpdates = false;\n      var currentSnapshots = [];\n      renderedSnapshot.forEach(function (snapshot, idx) {\n        var currentSnapshot = environment.lookup(snapshot.selector);\n        var renderData = snapshot.data;\n        var currentData = currentSnapshot.data;\n        var updatedData = recycleNodesInto(renderData, currentData);\n\n        if (updatedData !== renderData) {\n          currentSnapshot = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, currentSnapshot), {}, {\n            data: updatedData\n          });\n          didMissUpdates = true;\n        }\n\n        currentSnapshots[idx] = currentSnapshot;\n      }); // Only update the cache when the data is changed to avoid\n      // returning different `data` instances\n\n      if (didMissUpdates) {\n        this._cache.set(cacheKey, {\n          kind: 'done',\n          result: getFragmentResult(cacheKey, currentSnapshots, storeEpoch)\n        });\n      }\n\n      return [didMissUpdates, currentSnapshots];\n    }\n\n    var currentSnapshot = environment.lookup(renderedSnapshot.selector);\n    var renderData = renderedSnapshot.data;\n    var currentData = currentSnapshot.data;\n    var updatedData = recycleNodesInto(renderData, currentData);\n    var updatedCurrentSnapshot = {\n      data: updatedData,\n      isMissingData: currentSnapshot.isMissingData,\n      missingClientEdges: currentSnapshot.missingClientEdges,\n      seenRecords: currentSnapshot.seenRecords,\n      selector: currentSnapshot.selector,\n      missingRequiredFields: currentSnapshot.missingRequiredFields\n    };\n\n    if (updatedData !== renderData) {\n      this._cache.set(cacheKey, {\n        kind: 'done',\n        result: getFragmentResult(cacheKey, updatedCurrentSnapshot, storeEpoch)\n      });\n    }\n\n    return [updatedData !== renderData, updatedCurrentSnapshot];\n  };\n\n  _proto2.checkMissedUpdatesSpec = function checkMissedUpdatesSpec(fragmentResults) {\n    var _this7 = this;\n\n    return Object.keys(fragmentResults).some(function (key) {\n      return _this7.checkMissedUpdates(fragmentResults[key])[0];\n    });\n  };\n\n  _proto2._getAndSavePromiseForFragmentRequestInFlight = function _getAndSavePromiseForFragmentRequestInFlight(cacheKey, fragmentNode, fragmentOwner, fragmentResult) {\n    var _this8 = this;\n\n    var pendingOperationsResult = getPendingOperationsForFragment(this._environment, fragmentNode, fragmentOwner);\n\n    if (pendingOperationsResult == null) {\n      return null;\n    } // When the Promise for the request resolves, we need to make sure to\n    // update the cache with the latest data available in the store before\n    // resolving the Promise\n\n\n    var networkPromise = pendingOperationsResult.promise;\n    var pendingOperations = pendingOperationsResult.pendingOperations;\n    var promise = networkPromise.then(function () {\n      _this8._cache[\"delete\"](cacheKey);\n    })[\"catch\"](function (error) {\n      _this8._cache[\"delete\"](cacheKey);\n    }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n    promise.displayName = networkPromise.displayName;\n\n    this._cache.set(cacheKey, {\n      kind: 'pending',\n      pendingOperations: pendingOperations,\n      promise: promise,\n      result: fragmentResult\n    });\n\n    return {\n      promise: promise,\n      pendingOperations: pendingOperations\n    };\n  };\n\n  _proto2._updatePluralSnapshot = function _updatePluralSnapshot(cacheKey, baseSnapshots, latestSnapshot, idx, storeEpoch) {\n    var _currentFragmentResul;\n\n    var currentFragmentResult = this._cache.get(cacheKey);\n\n    if (isPromise(currentFragmentResult)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var currentSnapshot = currentFragmentResult === null || currentFragmentResult === void 0 ? void 0 : (_currentFragmentResul = currentFragmentResult.result) === null || _currentFragmentResul === void 0 ? void 0 : _currentFragmentResul.snapshot;\n\n    if (currentSnapshot && !Array.isArray(currentSnapshot)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var nextSnapshots = currentSnapshot ? (0, _toConsumableArray2[\"default\"])(currentSnapshot) : (0, _toConsumableArray2[\"default\"])(baseSnapshots);\n    nextSnapshots[idx] = latestSnapshot;\n\n    this._cache.set(cacheKey, {\n      kind: 'done',\n      result: getFragmentResult(cacheKey, nextSnapshots, storeEpoch)\n    });\n  };\n\n  return FragmentResourceImpl;\n}();\n\nfunction reportInvalidCachedData(nodeName) {\n  !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to find cached data for plural fragment `%s` when ' + 'receiving a subscription. ' + \"If you're seeing this, this is likely a bug in Relay.\", nodeName) : invariant(false) : void 0;\n}\n\nfunction createFragmentResource(environment) {\n  return new FragmentResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getFragmentResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createFragmentResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createFragmentResource: createFragmentResource,\n  getFragmentResourceForEnvironment: getFragmentResourceForEnvironment\n};"]},"metadata":{},"sourceType":"script"}