{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _require = require('../multi-actor-environment/ActorIdentifier'),\n    INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE = _require.INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE,\n    assertInternalActorIndentifier = _require.assertInternalActorIndentifier;\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar resolveImmediate = require('../util/resolveImmediate');\n\nvar DataChecker = require('./DataChecker');\n\nvar defaultGetDataID = require('./defaultGetDataID');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayOptimisticRecordSource = require('./RelayOptimisticRecordSource');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayReferenceMarker = require('./RelayReferenceMarker');\n\nvar RelayStoreReactFlightUtils = require('./RelayStoreReactFlightUtils');\n\nvar RelayStoreSubscriptions = require('./RelayStoreSubscriptions');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar _require2 = require('./RelayStoreUtils'),\n    ROOT_ID = _require2.ROOT_ID,\n    ROOT_TYPE = _require2.ROOT_TYPE;\n\nvar _require3 = require('./ResolverCache'),\n    RecordResolverCache = _require3.RecordResolverCache;\n\nvar invariant = require('invariant');\n\nvar DEFAULT_RELEASE_BUFFER_SIZE = 10;\n/**\n * @public\n *\n * An implementation of the `Store` interface defined in `RelayStoreTypes`.\n *\n * Note that a Store takes ownership of all records provided to it: other\n * objects may continue to hold a reference to such records but may not mutate\n * them. The static Relay core is architected to avoid mutating records that may have been\n * passed to a store: operations that mutate records will either create fresh\n * records or clone existing records and modify the clones. Record immutability\n * is also enforced in development mode by freezing all records passed to a store.\n */\n\nvar RelayModernStore = /*#__PURE__*/function () {\n  function RelayModernStore(source, options) {\n    var _this = this;\n\n    var _options$gcReleaseBuf, _options$gcScheduler, _options$getDataID, _options$log, _options$operationLoa;\n\n    (0, _defineProperty2[\"default\"])(this, \"_gcStep\", function () {\n      if (_this._gcRun) {\n        if (_this._gcRun.next().done) {\n          _this._gcRun = null;\n        } else {\n          _this._gcScheduler(_this._gcStep);\n        }\n      }\n    }); // Prevent mutation of a record from outside the store.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      var storeIDs = source.getRecordIDs();\n\n      for (var ii = 0; ii < storeIDs.length; ii++) {\n        var record = source.get(storeIDs[ii]);\n\n        if (record) {\n          RelayModernRecord.freeze(record);\n        }\n      }\n    }\n\n    this._currentWriteEpoch = 0;\n    this._gcHoldCounter = 0;\n    this._gcReleaseBufferSize = (_options$gcReleaseBuf = options === null || options === void 0 ? void 0 : options.gcReleaseBufferSize) !== null && _options$gcReleaseBuf !== void 0 ? _options$gcReleaseBuf : DEFAULT_RELEASE_BUFFER_SIZE;\n    this._gcRun = null;\n    this._gcScheduler = (_options$gcScheduler = options === null || options === void 0 ? void 0 : options.gcScheduler) !== null && _options$gcScheduler !== void 0 ? _options$gcScheduler : resolveImmediate;\n    this._getDataID = (_options$getDataID = options === null || options === void 0 ? void 0 : options.getDataID) !== null && _options$getDataID !== void 0 ? _options$getDataID : defaultGetDataID;\n    this._globalInvalidationEpoch = null;\n    this._invalidationSubscriptions = new Set();\n    this._invalidatedRecordIDs = new Set();\n    this.__log = (_options$log = options === null || options === void 0 ? void 0 : options.log) !== null && _options$log !== void 0 ? _options$log : null;\n    this._queryCacheExpirationTime = options === null || options === void 0 ? void 0 : options.queryCacheExpirationTime;\n    this._operationLoader = (_options$operationLoa = options === null || options === void 0 ? void 0 : options.operationLoader) !== null && _options$operationLoa !== void 0 ? _options$operationLoa : null;\n    this._optimisticSource = null;\n    this._recordSource = source;\n    this._releaseBuffer = [];\n    this._roots = new Map();\n    this._shouldScheduleGC = false;\n    this._resolverCache = new RecordResolverCache(function () {\n      return _this._getMutableRecordSource();\n    });\n    this._storeSubscriptions = new RelayStoreSubscriptions(options === null || options === void 0 ? void 0 : options.log, this._resolverCache);\n    this._updatedRecordIDs = new Set();\n    this._shouldProcessClientComponents = options === null || options === void 0 ? void 0 : options.shouldProcessClientComponents;\n    initializeRecordSource(this._recordSource);\n  }\n\n  var _proto = RelayModernStore.prototype;\n\n  _proto.getSource = function getSource() {\n    var _this$_optimisticSour;\n\n    return (_this$_optimisticSour = this._optimisticSource) !== null && _this$_optimisticSour !== void 0 ? _this$_optimisticSour : this._recordSource;\n  };\n\n  _proto._getMutableRecordSource = function _getMutableRecordSource() {\n    var _this$_optimisticSour2;\n\n    return (_this$_optimisticSour2 = this._optimisticSource) !== null && _this$_optimisticSour2 !== void 0 ? _this$_optimisticSour2 : this._recordSource;\n  };\n\n  _proto.check = function check(operation, options) {\n    var _options$handlers, _options$getSourceFor, _options$getTargetFor, _options$defaultActor;\n\n    var selector = operation.root;\n\n    var source = this._getMutableRecordSource();\n\n    var globalInvalidationEpoch = this._globalInvalidationEpoch;\n\n    var rootEntry = this._roots.get(operation.request.identifier);\n\n    var operationLastWrittenAt = rootEntry != null ? rootEntry.epoch : null; // Check if store has been globally invalidated\n\n    if (globalInvalidationEpoch != null) {\n      // If so, check if the operation we're checking was last written\n      // before or after invalidation occurred.\n      if (operationLastWrittenAt == null || operationLastWrittenAt <= globalInvalidationEpoch) {\n        // If the operation was written /before/ global invalidation occurred,\n        // or if this operation has never been written to the store before,\n        // we will consider the data for this operation to be stale\n        // (i.e. not resolvable from the store).\n        return {\n          status: 'stale'\n        };\n      }\n    }\n\n    var handlers = (_options$handlers = options === null || options === void 0 ? void 0 : options.handlers) !== null && _options$handlers !== void 0 ? _options$handlers : [];\n    var getSourceForActor = (_options$getSourceFor = options === null || options === void 0 ? void 0 : options.getSourceForActor) !== null && _options$getSourceFor !== void 0 ? _options$getSourceFor : function (actorIdentifier) {\n      assertInternalActorIndentifier(actorIdentifier);\n      return source;\n    };\n    var getTargetForActor = (_options$getTargetFor = options === null || options === void 0 ? void 0 : options.getTargetForActor) !== null && _options$getTargetFor !== void 0 ? _options$getTargetFor : function (actorIdentifier) {\n      assertInternalActorIndentifier(actorIdentifier);\n      return source;\n    };\n    var operationAvailability = DataChecker.check(getSourceForActor, getTargetForActor, (_options$defaultActor = options === null || options === void 0 ? void 0 : options.defaultActorIdentifier) !== null && _options$defaultActor !== void 0 ? _options$defaultActor : INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE, selector, handlers, this._operationLoader, this._getDataID, this._shouldProcessClientComponents);\n    return getAvailabilityStatus(operationAvailability, operationLastWrittenAt, rootEntry === null || rootEntry === void 0 ? void 0 : rootEntry.fetchTime, this._queryCacheExpirationTime);\n  };\n\n  _proto.retain = function retain(operation) {\n    var _this2 = this;\n\n    var id = operation.request.identifier;\n    var disposed = false;\n\n    var dispose = function dispose() {\n      // Ensure each retain can only dispose once\n      if (disposed) {\n        return;\n      }\n\n      disposed = true; // For Flow: guard against the entry somehow not existing\n\n      var rootEntry = _this2._roots.get(id);\n\n      if (rootEntry == null) {\n        return;\n      } // Decrement the ref count: if it becomes zero it is eligible\n      // for release.\n\n\n      rootEntry.refCount--;\n\n      if (rootEntry.refCount === 0) {\n        var _queryCacheExpirationTime = _this2._queryCacheExpirationTime;\n\n        var rootEntryIsStale = rootEntry.fetchTime != null && _queryCacheExpirationTime != null && rootEntry.fetchTime <= Date.now() - _queryCacheExpirationTime;\n\n        if (rootEntryIsStale) {\n          _this2._roots[\"delete\"](id);\n\n          _this2.scheduleGC();\n        } else {\n          _this2._releaseBuffer.push(id); // If the release buffer is now over-full, remove the least-recently\n          // added entry and schedule a GC. Note that all items in the release\n          // buffer have a refCount of 0.\n\n\n          if (_this2._releaseBuffer.length > _this2._gcReleaseBufferSize) {\n            var _id = _this2._releaseBuffer.shift();\n\n            _this2._roots[\"delete\"](_id);\n\n            _this2.scheduleGC();\n          }\n        }\n      }\n    };\n\n    var rootEntry = this._roots.get(id);\n\n    if (rootEntry != null) {\n      if (rootEntry.refCount === 0) {\n        // This entry should be in the release buffer, but it no longer belongs\n        // there since it's retained. Remove it to maintain the invariant that\n        // all release buffer entries have a refCount of 0.\n        this._releaseBuffer = this._releaseBuffer.filter(function (_id) {\n          return _id !== id;\n        });\n      } // If we've previously retained this operation, increment the refCount\n\n\n      rootEntry.refCount += 1;\n    } else {\n      // Otherwise create a new entry for the operation\n      this._roots.set(id, {\n        operation: operation,\n        refCount: 1,\n        epoch: null,\n        fetchTime: null\n      });\n    }\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.lookup = function lookup(selector) {\n    var source = this.getSource();\n    var snapshot = RelayReader.read(source, selector, this._resolverCache);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(snapshot);\n    }\n\n    return snapshot;\n  } // This method will return a list of updated owners from the subscriptions\n  ;\n\n  _proto.notify = function notify(sourceOperation, invalidateStore) {\n    var _this3 = this;\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.notify.start',\n        sourceOperation: sourceOperation\n      });\n    } // Increment the current write when notifying after executing\n    // a set of changes to the store.\n\n\n    this._currentWriteEpoch++;\n\n    if (invalidateStore === true) {\n      this._globalInvalidationEpoch = this._currentWriteEpoch;\n    }\n\n    if (RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n      // When a record is updated, we need to also handle records that depend on it,\n      // specifically Relay Resolver result records containing results based on the\n      // updated records. This both adds to updatedRecordIDs and invalidates any\n      // cached data as needed.\n      this._resolverCache.invalidateDataIDs(this._updatedRecordIDs);\n    }\n\n    var source = this.getSource();\n    var updatedOwners = [];\n\n    this._storeSubscriptions.updateSubscriptions(source, this._updatedRecordIDs, updatedOwners, sourceOperation);\n\n    this._invalidationSubscriptions.forEach(function (subscription) {\n      _this3._updateInvalidationSubscription(subscription, invalidateStore === true);\n    });\n\n    if (log != null) {\n      log({\n        name: 'store.notify.complete',\n        sourceOperation: sourceOperation,\n        updatedRecordIDs: this._updatedRecordIDs,\n        invalidatedRecordIDs: this._invalidatedRecordIDs\n      });\n    }\n\n    this._updatedRecordIDs.clear();\n\n    this._invalidatedRecordIDs.clear(); // If a source operation was provided (indicating the operation\n    // that produced this update to the store), record the current epoch\n    // at which this operation was written.\n\n\n    if (sourceOperation != null) {\n      // We only track the epoch at which the operation was written if\n      // it was previously retained, to keep the size of our operation\n      // epoch map bounded. If a query wasn't retained, we assume it can\n      // may be deleted at any moment and thus is not relevant for us to track\n      // for the purposes of invalidation.\n      var id = sourceOperation.request.identifier;\n\n      var rootEntry = this._roots.get(id);\n\n      if (rootEntry != null) {\n        rootEntry.epoch = this._currentWriteEpoch;\n        rootEntry.fetchTime = Date.now();\n      } else if (sourceOperation.request.node.params.operationKind === 'query' && this._gcReleaseBufferSize > 0 && this._releaseBuffer.length < this._gcReleaseBufferSize) {\n        // The operation isn't retained but there is space in the release buffer:\n        // temporarily track this operation in case the data can be reused soon.\n        var temporaryRootEntry = {\n          operation: sourceOperation,\n          refCount: 0,\n          epoch: this._currentWriteEpoch,\n          fetchTime: Date.now()\n        };\n\n        this._releaseBuffer.push(id);\n\n        this._roots.set(id, temporaryRootEntry);\n      }\n    }\n\n    return updatedOwners;\n  };\n\n  _proto.publish = function publish(source, idsMarkedForInvalidation) {\n    var target = this._getMutableRecordSource();\n\n    updateTargetFromSource(target, source, // We increment the current epoch at the end of the set of updates,\n    // in notify(). Here, we pass what will be the incremented value of\n    // the epoch to use to write to invalidated records.\n    this._currentWriteEpoch + 1, idsMarkedForInvalidation, this._updatedRecordIDs, this._invalidatedRecordIDs); // NOTE: log *after* processing the source so that even if a bad log function\n    // mutates the source, it doesn't affect Relay processing of it.\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.publish',\n        source: source,\n        optimistic: target === this._optimisticSource\n      });\n    }\n  };\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    return this._storeSubscriptions.subscribe(snapshot, callback);\n  };\n\n  _proto.holdGC = function holdGC() {\n    var _this4 = this;\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._gcHoldCounter++;\n\n    var dispose = function dispose() {\n      if (_this4._gcHoldCounter > 0) {\n        _this4._gcHoldCounter--;\n\n        if (_this4._gcHoldCounter === 0 && _this4._shouldScheduleGC) {\n          _this4.scheduleGC();\n\n          _this4._shouldScheduleGC = false;\n        }\n      }\n    };\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.toJSON = function toJSON() {\n    return 'RelayModernStore()';\n  };\n\n  _proto.getEpoch = function getEpoch() {\n    return this._currentWriteEpoch;\n  } // Internal API\n  ;\n\n  _proto.__getUpdatedRecordIDs = function __getUpdatedRecordIDs() {\n    return this._updatedRecordIDs;\n  };\n\n  _proto.lookupInvalidationState = function lookupInvalidationState(dataIDs) {\n    var _this5 = this;\n\n    var invalidations = new Map();\n    dataIDs.forEach(function (dataID) {\n      var _RelayModernRecord$ge;\n\n      var record = _this5.getSource().get(dataID);\n\n      invalidations.set(dataID, (_RelayModernRecord$ge = RelayModernRecord.getInvalidationEpoch(record)) !== null && _RelayModernRecord$ge !== void 0 ? _RelayModernRecord$ge : null);\n    });\n    invalidations.set('global', this._globalInvalidationEpoch);\n    return {\n      dataIDs: dataIDs,\n      invalidations: invalidations\n    };\n  };\n\n  _proto.checkInvalidationState = function checkInvalidationState(prevInvalidationState) {\n    var latestInvalidationState = this.lookupInvalidationState(prevInvalidationState.dataIDs);\n    var currentInvalidations = latestInvalidationState.invalidations;\n    var prevInvalidations = prevInvalidationState.invalidations; // Check if global invalidation has changed\n\n    if (currentInvalidations.get('global') !== prevInvalidations.get('global')) {\n      return true;\n    } // Check if the invalidation state for any of the ids has changed.\n\n\n    var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(prevInvalidationState.dataIDs),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dataID = _step.value;\n\n        if (currentInvalidations.get(dataID) !== prevInvalidations.get(dataID)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return false;\n  };\n\n  _proto.subscribeToInvalidationState = function subscribeToInvalidationState(invalidationState, callback) {\n    var _this6 = this;\n\n    var subscription = {\n      callback: callback,\n      invalidationState: invalidationState\n    };\n\n    var dispose = function dispose() {\n      _this6._invalidationSubscriptions[\"delete\"](subscription);\n    };\n\n    this._invalidationSubscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto._updateInvalidationSubscription = function _updateInvalidationSubscription(subscription, invalidatedStore) {\n    var _this7 = this;\n\n    var callback = subscription.callback,\n        invalidationState = subscription.invalidationState;\n    var dataIDs = invalidationState.dataIDs;\n    var isSubscribedToInvalidatedIDs = invalidatedStore || dataIDs.some(function (dataID) {\n      return _this7._invalidatedRecordIDs.has(dataID);\n    });\n\n    if (!isSubscribedToInvalidatedIDs) {\n      return;\n    }\n\n    callback();\n  };\n\n  _proto.snapshot = function snapshot() {\n    !(this._optimisticSource == null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to snapshot() while a previous ' + 'snapshot exists.') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.snapshot'\n      });\n    }\n\n    this._storeSubscriptions.snapshotSubscriptions(this.getSource());\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._optimisticSource = RelayOptimisticRecordSource.create(this.getSource());\n  };\n\n  _proto.restore = function restore() {\n    !(this._optimisticSource != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to restore(), expected a snapshot ' + 'to exist (make sure to call snapshot()).') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.restore'\n      });\n    }\n\n    this._optimisticSource = null;\n\n    if (this._shouldScheduleGC) {\n      this.scheduleGC();\n    }\n\n    this._storeSubscriptions.restoreSubscriptions();\n  };\n\n  _proto.scheduleGC = function scheduleGC() {\n    if (this._gcHoldCounter > 0) {\n      this._shouldScheduleGC = true;\n      return;\n    }\n\n    if (this._gcRun) {\n      return;\n    }\n\n    this._gcRun = this._collect();\n\n    this._gcScheduler(this._gcStep);\n  }\n  /**\n   * Run a full GC synchronously.\n   */\n  ;\n\n  _proto.__gc = function __gc() {\n    // Don't run GC while there are optimistic updates applied\n    if (this._optimisticSource != null) {\n      return;\n    }\n\n    var gcRun = this._collect();\n\n    while (!gcRun.next().done) {}\n  };\n\n  _proto._collect = function* _collect() {\n    /* eslint-disable no-labels */\n    top: while (true) {\n      var startEpoch = this._currentWriteEpoch;\n      var references = new Set(); // Mark all records that are traversable from a root\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(this._roots.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var operation = _step2.value.operation;\n          var selector = operation.root;\n          RelayReferenceMarker.mark(this._recordSource, selector, references, this._operationLoader, this._shouldProcessClientComponents); // Yield for other work after each operation\n\n          yield; // If the store was updated, restart\n\n          if (startEpoch !== this._currentWriteEpoch) {\n            continue top;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var log = this.__log;\n\n      if (log != null) {\n        log({\n          name: 'store.gc',\n          references: references\n        });\n      } // Sweep records without references\n\n\n      if (references.size === 0) {\n        // Short-circuit if *nothing* is referenced\n        this._recordSource.clear();\n      } else {\n        // Evict any unreferenced nodes\n        var storeIDs = this._recordSource.getRecordIDs();\n\n        for (var ii = 0; ii < storeIDs.length; ii++) {\n          var dataID = storeIDs[ii];\n\n          if (!references.has(dataID)) {\n            this._recordSource.remove(dataID);\n          }\n        }\n      }\n\n      return;\n    }\n  };\n\n  return RelayModernStore;\n}();\n\nfunction initializeRecordSource(target) {\n  if (!target.has(ROOT_ID)) {\n    var rootRecord = RelayModernRecord.create(ROOT_ID, ROOT_TYPE);\n    target.set(ROOT_ID, rootRecord);\n  }\n}\n/**\n * Updates the target with information from source, also updating a mapping of\n * which records in the target were changed as a result.\n * Additionally, will mark records as invalidated at the current write epoch\n * given the set of record ids marked as stale in this update.\n */\n\n\nfunction updateTargetFromSource(target, source, currentWriteEpoch, idsMarkedForInvalidation, updatedRecordIDs, invalidatedRecordIDs) {\n  // First, update any records that were marked for invalidation.\n  // For each provided dataID that was invalidated, we write the\n  // INVALIDATED_AT_KEY on the record, indicating\n  // the epoch at which the record was invalidated.\n  if (idsMarkedForInvalidation) {\n    idsMarkedForInvalidation.forEach(function (dataID) {\n      var targetRecord = target.get(dataID);\n      var sourceRecord = source.get(dataID); // If record was deleted during the update (and also invalidated),\n      // we don't need to count it as an invalidated id\n\n      if (sourceRecord === null) {\n        return;\n      }\n\n      var nextRecord;\n\n      if (targetRecord != null) {\n        // If the target record exists, use it to set the epoch\n        // at which it was invalidated. This record will be updated with\n        // any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = RelayModernRecord.clone(targetRecord);\n      } else {\n        // If the target record doesn't exist, it means that a new record\n        // in the source was created (and also invalidated), so we use that\n        // record to set the epoch at which it was invalidated. This record\n        // will be updated with any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = sourceRecord != null ? RelayModernRecord.clone(sourceRecord) : null;\n      }\n\n      if (!nextRecord) {\n        return;\n      }\n\n      RelayModernRecord.setValue(nextRecord, RelayStoreUtils.INVALIDATED_AT_KEY, currentWriteEpoch);\n      invalidatedRecordIDs.add(dataID);\n      target.set(dataID, nextRecord);\n    });\n  } // Update the target based on the changes present in source\n\n\n  var dataIDs = source.getRecordIDs();\n\n  for (var ii = 0; ii < dataIDs.length; ii++) {\n    var dataID = dataIDs[ii];\n    var sourceRecord = source.get(dataID);\n    var targetRecord = target.get(dataID); // Prevent mutation of a record from outside the store.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (sourceRecord) {\n        RelayModernRecord.freeze(sourceRecord);\n      }\n    }\n\n    if (sourceRecord && targetRecord) {\n      // ReactFlightClientResponses are lazy and only materialize when readRoot\n      // is called when we read the field, so if the record is a Flight field\n      // we always use the new record's data regardless of whether\n      // it actually changed. Let React take care of reconciliation instead.\n      var nextRecord = RelayModernRecord.getType(targetRecord) === RelayStoreReactFlightUtils.REACT_FLIGHT_TYPE_NAME ? sourceRecord : RelayModernRecord.update(targetRecord, sourceRecord);\n\n      if (nextRecord !== targetRecord) {\n        // Prevent mutation of a record from outside the store.\n        if (process.env.NODE_ENV !== \"production\") {\n          RelayModernRecord.freeze(nextRecord);\n        }\n\n        updatedRecordIDs.add(dataID);\n        target.set(dataID, nextRecord);\n      }\n    } else if (sourceRecord === null) {\n      target[\"delete\"](dataID);\n\n      if (targetRecord !== null) {\n        updatedRecordIDs.add(dataID);\n      }\n    } else if (sourceRecord) {\n      target.set(dataID, sourceRecord);\n      updatedRecordIDs.add(dataID);\n    } // don't add explicit undefined\n\n  }\n}\n/**\n * Returns an OperationAvailability given the Availability returned\n * by checking an operation, and when that operation was last written to the store.\n * Specifically, the provided Availability of an operation will contain the\n * value of when a record referenced by the operation was most recently\n * invalidated; given that value, and given when this operation was last\n * written to the store, this function will return the overall\n * OperationAvailability for the operation.\n */\n\n\nfunction getAvailabilityStatus(operationAvailability, operationLastWrittenAt, operationFetchTime, queryCacheExpirationTime) {\n  var mostRecentlyInvalidatedAt = operationAvailability.mostRecentlyInvalidatedAt,\n      status = operationAvailability.status;\n\n  if (typeof mostRecentlyInvalidatedAt === 'number') {\n    // If some record referenced by this operation is stale, then the operation itself is stale\n    // if either the operation itself was never written *or* the operation was last written\n    // before the most recent invalidation of its reachable records.\n    if (operationLastWrittenAt == null || mostRecentlyInvalidatedAt > operationLastWrittenAt) {\n      return {\n        status: 'stale'\n      };\n    }\n  }\n\n  if (status === 'missing') {\n    return {\n      status: 'missing'\n    };\n  }\n\n  if (operationFetchTime != null && queryCacheExpirationTime != null) {\n    var isStale = operationFetchTime <= Date.now() - queryCacheExpirationTime;\n\n    if (isStale) {\n      return {\n        status: 'stale'\n      };\n    }\n  } // There were no invalidations of any reachable records *or* the operation is known to have\n  // been fetched after the most recent record invalidation.\n\n\n  return {\n    status: 'available',\n    fetchTime: operationFetchTime !== null && operationFetchTime !== void 0 ? operationFetchTime : null\n  };\n}\n\nmodule.exports = RelayModernStore;","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/store/RelayModernStore.js"],"names":["_interopRequireDefault","require","_createForOfIteratorHelper2","_defineProperty2","_require","INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE","assertInternalActorIndentifier","deepFreeze","RelayFeatureFlags","resolveImmediate","DataChecker","defaultGetDataID","RelayModernRecord","RelayOptimisticRecordSource","RelayReader","RelayReferenceMarker","RelayStoreReactFlightUtils","RelayStoreSubscriptions","RelayStoreUtils","_require2","ROOT_ID","ROOT_TYPE","_require3","RecordResolverCache","invariant","DEFAULT_RELEASE_BUFFER_SIZE","RelayModernStore","source","options","_this","_options$gcReleaseBuf","_options$gcScheduler","_options$getDataID","_options$log","_options$operationLoa","_gcRun","next","done","_gcScheduler","_gcStep","process","env","NODE_ENV","storeIDs","getRecordIDs","ii","length","record","get","freeze","_currentWriteEpoch","_gcHoldCounter","_gcReleaseBufferSize","gcReleaseBufferSize","gcScheduler","_getDataID","getDataID","_globalInvalidationEpoch","_invalidationSubscriptions","Set","_invalidatedRecordIDs","__log","log","_queryCacheExpirationTime","queryCacheExpirationTime","_operationLoader","operationLoader","_optimisticSource","_recordSource","_releaseBuffer","_roots","Map","_shouldScheduleGC","_resolverCache","_getMutableRecordSource","_storeSubscriptions","_updatedRecordIDs","_shouldProcessClientComponents","shouldProcessClientComponents","initializeRecordSource","_proto","prototype","getSource","_this$_optimisticSour","_this$_optimisticSour2","check","operation","_options$handlers","_options$getSourceFor","_options$getTargetFor","_options$defaultActor","selector","root","globalInvalidationEpoch","rootEntry","request","identifier","operationLastWrittenAt","epoch","status","handlers","getSourceForActor","actorIdentifier","getTargetForActor","operationAvailability","defaultActorIdentifier","getAvailabilityStatus","fetchTime","retain","_this2","id","disposed","dispose","refCount","rootEntryIsStale","Date","now","scheduleGC","push","_id","shift","filter","set","lookup","snapshot","read","notify","sourceOperation","invalidateStore","_this3","name","ENABLE_RELAY_RESOLVERS","invalidateDataIDs","updatedOwners","updateSubscriptions","forEach","subscription","_updateInvalidationSubscription","updatedRecordIDs","invalidatedRecordIDs","clear","node","params","operationKind","temporaryRootEntry","publish","idsMarkedForInvalidation","target","updateTargetFromSource","optimistic","subscribe","callback","holdGC","_this4","toJSON","getEpoch","__getUpdatedRecordIDs","lookupInvalidationState","dataIDs","_this5","invalidations","dataID","_RelayModernRecord$ge","getInvalidationEpoch","checkInvalidationState","prevInvalidationState","latestInvalidationState","currentInvalidations","prevInvalidations","_iterator","_step","s","n","value","err","e","f","subscribeToInvalidationState","invalidationState","_this6","add","invalidatedStore","_this7","isSubscribedToInvalidatedIDs","some","has","snapshotSubscriptions","create","restore","restoreSubscriptions","_collect","__gc","gcRun","top","startEpoch","references","_iterator2","values","_step2","mark","size","remove","rootRecord","currentWriteEpoch","targetRecord","sourceRecord","nextRecord","clone","setValue","INVALIDATED_AT_KEY","getType","REACT_FLIGHT_TYPE_NAME","update","operationFetchTime","mostRecentlyInvalidatedAt","isStale","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _require = require('../multi-actor-environment/ActorIdentifier'),\n    INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE = _require.INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE,\n    assertInternalActorIndentifier = _require.assertInternalActorIndentifier;\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar resolveImmediate = require('../util/resolveImmediate');\n\nvar DataChecker = require('./DataChecker');\n\nvar defaultGetDataID = require('./defaultGetDataID');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayOptimisticRecordSource = require('./RelayOptimisticRecordSource');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayReferenceMarker = require('./RelayReferenceMarker');\n\nvar RelayStoreReactFlightUtils = require('./RelayStoreReactFlightUtils');\n\nvar RelayStoreSubscriptions = require('./RelayStoreSubscriptions');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar _require2 = require('./RelayStoreUtils'),\n    ROOT_ID = _require2.ROOT_ID,\n    ROOT_TYPE = _require2.ROOT_TYPE;\n\nvar _require3 = require('./ResolverCache'),\n    RecordResolverCache = _require3.RecordResolverCache;\n\nvar invariant = require('invariant');\n\nvar DEFAULT_RELEASE_BUFFER_SIZE = 10;\n/**\n * @public\n *\n * An implementation of the `Store` interface defined in `RelayStoreTypes`.\n *\n * Note that a Store takes ownership of all records provided to it: other\n * objects may continue to hold a reference to such records but may not mutate\n * them. The static Relay core is architected to avoid mutating records that may have been\n * passed to a store: operations that mutate records will either create fresh\n * records or clone existing records and modify the clones. Record immutability\n * is also enforced in development mode by freezing all records passed to a store.\n */\n\nvar RelayModernStore = /*#__PURE__*/function () {\n  function RelayModernStore(source, options) {\n    var _this = this;\n\n    var _options$gcReleaseBuf, _options$gcScheduler, _options$getDataID, _options$log, _options$operationLoa;\n\n    (0, _defineProperty2[\"default\"])(this, \"_gcStep\", function () {\n      if (_this._gcRun) {\n        if (_this._gcRun.next().done) {\n          _this._gcRun = null;\n        } else {\n          _this._gcScheduler(_this._gcStep);\n        }\n      }\n    });\n\n    // Prevent mutation of a record from outside the store.\n    if (process.env.NODE_ENV !== \"production\") {\n      var storeIDs = source.getRecordIDs();\n\n      for (var ii = 0; ii < storeIDs.length; ii++) {\n        var record = source.get(storeIDs[ii]);\n\n        if (record) {\n          RelayModernRecord.freeze(record);\n        }\n      }\n    }\n\n    this._currentWriteEpoch = 0;\n    this._gcHoldCounter = 0;\n    this._gcReleaseBufferSize = (_options$gcReleaseBuf = options === null || options === void 0 ? void 0 : options.gcReleaseBufferSize) !== null && _options$gcReleaseBuf !== void 0 ? _options$gcReleaseBuf : DEFAULT_RELEASE_BUFFER_SIZE;\n    this._gcRun = null;\n    this._gcScheduler = (_options$gcScheduler = options === null || options === void 0 ? void 0 : options.gcScheduler) !== null && _options$gcScheduler !== void 0 ? _options$gcScheduler : resolveImmediate;\n    this._getDataID = (_options$getDataID = options === null || options === void 0 ? void 0 : options.getDataID) !== null && _options$getDataID !== void 0 ? _options$getDataID : defaultGetDataID;\n    this._globalInvalidationEpoch = null;\n    this._invalidationSubscriptions = new Set();\n    this._invalidatedRecordIDs = new Set();\n    this.__log = (_options$log = options === null || options === void 0 ? void 0 : options.log) !== null && _options$log !== void 0 ? _options$log : null;\n    this._queryCacheExpirationTime = options === null || options === void 0 ? void 0 : options.queryCacheExpirationTime;\n    this._operationLoader = (_options$operationLoa = options === null || options === void 0 ? void 0 : options.operationLoader) !== null && _options$operationLoa !== void 0 ? _options$operationLoa : null;\n    this._optimisticSource = null;\n    this._recordSource = source;\n    this._releaseBuffer = [];\n    this._roots = new Map();\n    this._shouldScheduleGC = false;\n    this._resolverCache = new RecordResolverCache(function () {\n      return _this._getMutableRecordSource();\n    });\n    this._storeSubscriptions = new RelayStoreSubscriptions(options === null || options === void 0 ? void 0 : options.log, this._resolverCache);\n    this._updatedRecordIDs = new Set();\n    this._shouldProcessClientComponents = options === null || options === void 0 ? void 0 : options.shouldProcessClientComponents;\n    initializeRecordSource(this._recordSource);\n  }\n\n  var _proto = RelayModernStore.prototype;\n\n  _proto.getSource = function getSource() {\n    var _this$_optimisticSour;\n\n    return (_this$_optimisticSour = this._optimisticSource) !== null && _this$_optimisticSour !== void 0 ? _this$_optimisticSour : this._recordSource;\n  };\n\n  _proto._getMutableRecordSource = function _getMutableRecordSource() {\n    var _this$_optimisticSour2;\n\n    return (_this$_optimisticSour2 = this._optimisticSource) !== null && _this$_optimisticSour2 !== void 0 ? _this$_optimisticSour2 : this._recordSource;\n  };\n\n  _proto.check = function check(operation, options) {\n    var _options$handlers, _options$getSourceFor, _options$getTargetFor, _options$defaultActor;\n\n    var selector = operation.root;\n\n    var source = this._getMutableRecordSource();\n\n    var globalInvalidationEpoch = this._globalInvalidationEpoch;\n\n    var rootEntry = this._roots.get(operation.request.identifier);\n\n    var operationLastWrittenAt = rootEntry != null ? rootEntry.epoch : null; // Check if store has been globally invalidated\n\n    if (globalInvalidationEpoch != null) {\n      // If so, check if the operation we're checking was last written\n      // before or after invalidation occurred.\n      if (operationLastWrittenAt == null || operationLastWrittenAt <= globalInvalidationEpoch) {\n        // If the operation was written /before/ global invalidation occurred,\n        // or if this operation has never been written to the store before,\n        // we will consider the data for this operation to be stale\n        // (i.e. not resolvable from the store).\n        return {\n          status: 'stale'\n        };\n      }\n    }\n\n    var handlers = (_options$handlers = options === null || options === void 0 ? void 0 : options.handlers) !== null && _options$handlers !== void 0 ? _options$handlers : [];\n    var getSourceForActor = (_options$getSourceFor = options === null || options === void 0 ? void 0 : options.getSourceForActor) !== null && _options$getSourceFor !== void 0 ? _options$getSourceFor : function (actorIdentifier) {\n      assertInternalActorIndentifier(actorIdentifier);\n      return source;\n    };\n    var getTargetForActor = (_options$getTargetFor = options === null || options === void 0 ? void 0 : options.getTargetForActor) !== null && _options$getTargetFor !== void 0 ? _options$getTargetFor : function (actorIdentifier) {\n      assertInternalActorIndentifier(actorIdentifier);\n      return source;\n    };\n    var operationAvailability = DataChecker.check(getSourceForActor, getTargetForActor, (_options$defaultActor = options === null || options === void 0 ? void 0 : options.defaultActorIdentifier) !== null && _options$defaultActor !== void 0 ? _options$defaultActor : INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE, selector, handlers, this._operationLoader, this._getDataID, this._shouldProcessClientComponents);\n    return getAvailabilityStatus(operationAvailability, operationLastWrittenAt, rootEntry === null || rootEntry === void 0 ? void 0 : rootEntry.fetchTime, this._queryCacheExpirationTime);\n  };\n\n  _proto.retain = function retain(operation) {\n    var _this2 = this;\n\n    var id = operation.request.identifier;\n    var disposed = false;\n\n    var dispose = function dispose() {\n      // Ensure each retain can only dispose once\n      if (disposed) {\n        return;\n      }\n\n      disposed = true; // For Flow: guard against the entry somehow not existing\n\n      var rootEntry = _this2._roots.get(id);\n\n      if (rootEntry == null) {\n        return;\n      } // Decrement the ref count: if it becomes zero it is eligible\n      // for release.\n\n\n      rootEntry.refCount--;\n\n      if (rootEntry.refCount === 0) {\n        var _queryCacheExpirationTime = _this2._queryCacheExpirationTime;\n\n        var rootEntryIsStale = rootEntry.fetchTime != null && _queryCacheExpirationTime != null && rootEntry.fetchTime <= Date.now() - _queryCacheExpirationTime;\n\n        if (rootEntryIsStale) {\n          _this2._roots[\"delete\"](id);\n\n          _this2.scheduleGC();\n        } else {\n          _this2._releaseBuffer.push(id); // If the release buffer is now over-full, remove the least-recently\n          // added entry and schedule a GC. Note that all items in the release\n          // buffer have a refCount of 0.\n\n\n          if (_this2._releaseBuffer.length > _this2._gcReleaseBufferSize) {\n            var _id = _this2._releaseBuffer.shift();\n\n            _this2._roots[\"delete\"](_id);\n\n            _this2.scheduleGC();\n          }\n        }\n      }\n    };\n\n    var rootEntry = this._roots.get(id);\n\n    if (rootEntry != null) {\n      if (rootEntry.refCount === 0) {\n        // This entry should be in the release buffer, but it no longer belongs\n        // there since it's retained. Remove it to maintain the invariant that\n        // all release buffer entries have a refCount of 0.\n        this._releaseBuffer = this._releaseBuffer.filter(function (_id) {\n          return _id !== id;\n        });\n      } // If we've previously retained this operation, increment the refCount\n\n\n      rootEntry.refCount += 1;\n    } else {\n      // Otherwise create a new entry for the operation\n      this._roots.set(id, {\n        operation: operation,\n        refCount: 1,\n        epoch: null,\n        fetchTime: null\n      });\n    }\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.lookup = function lookup(selector) {\n    var source = this.getSource();\n    var snapshot = RelayReader.read(source, selector, this._resolverCache);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(snapshot);\n    }\n\n    return snapshot;\n  } // This method will return a list of updated owners from the subscriptions\n  ;\n\n  _proto.notify = function notify(sourceOperation, invalidateStore) {\n    var _this3 = this;\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.notify.start',\n        sourceOperation: sourceOperation\n      });\n    } // Increment the current write when notifying after executing\n    // a set of changes to the store.\n\n\n    this._currentWriteEpoch++;\n\n    if (invalidateStore === true) {\n      this._globalInvalidationEpoch = this._currentWriteEpoch;\n    }\n\n    if (RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n      // When a record is updated, we need to also handle records that depend on it,\n      // specifically Relay Resolver result records containing results based on the\n      // updated records. This both adds to updatedRecordIDs and invalidates any\n      // cached data as needed.\n      this._resolverCache.invalidateDataIDs(this._updatedRecordIDs);\n    }\n\n    var source = this.getSource();\n    var updatedOwners = [];\n\n    this._storeSubscriptions.updateSubscriptions(source, this._updatedRecordIDs, updatedOwners, sourceOperation);\n\n    this._invalidationSubscriptions.forEach(function (subscription) {\n      _this3._updateInvalidationSubscription(subscription, invalidateStore === true);\n    });\n\n    if (log != null) {\n      log({\n        name: 'store.notify.complete',\n        sourceOperation: sourceOperation,\n        updatedRecordIDs: this._updatedRecordIDs,\n        invalidatedRecordIDs: this._invalidatedRecordIDs\n      });\n    }\n\n    this._updatedRecordIDs.clear();\n\n    this._invalidatedRecordIDs.clear(); // If a source operation was provided (indicating the operation\n    // that produced this update to the store), record the current epoch\n    // at which this operation was written.\n\n\n    if (sourceOperation != null) {\n      // We only track the epoch at which the operation was written if\n      // it was previously retained, to keep the size of our operation\n      // epoch map bounded. If a query wasn't retained, we assume it can\n      // may be deleted at any moment and thus is not relevant for us to track\n      // for the purposes of invalidation.\n      var id = sourceOperation.request.identifier;\n\n      var rootEntry = this._roots.get(id);\n\n      if (rootEntry != null) {\n        rootEntry.epoch = this._currentWriteEpoch;\n        rootEntry.fetchTime = Date.now();\n      } else if (sourceOperation.request.node.params.operationKind === 'query' && this._gcReleaseBufferSize > 0 && this._releaseBuffer.length < this._gcReleaseBufferSize) {\n        // The operation isn't retained but there is space in the release buffer:\n        // temporarily track this operation in case the data can be reused soon.\n        var temporaryRootEntry = {\n          operation: sourceOperation,\n          refCount: 0,\n          epoch: this._currentWriteEpoch,\n          fetchTime: Date.now()\n        };\n\n        this._releaseBuffer.push(id);\n\n        this._roots.set(id, temporaryRootEntry);\n      }\n    }\n\n    return updatedOwners;\n  };\n\n  _proto.publish = function publish(source, idsMarkedForInvalidation) {\n    var target = this._getMutableRecordSource();\n\n    updateTargetFromSource(target, source, // We increment the current epoch at the end of the set of updates,\n    // in notify(). Here, we pass what will be the incremented value of\n    // the epoch to use to write to invalidated records.\n    this._currentWriteEpoch + 1, idsMarkedForInvalidation, this._updatedRecordIDs, this._invalidatedRecordIDs); // NOTE: log *after* processing the source so that even if a bad log function\n    // mutates the source, it doesn't affect Relay processing of it.\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.publish',\n        source: source,\n        optimistic: target === this._optimisticSource\n      });\n    }\n  };\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    return this._storeSubscriptions.subscribe(snapshot, callback);\n  };\n\n  _proto.holdGC = function holdGC() {\n    var _this4 = this;\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._gcHoldCounter++;\n\n    var dispose = function dispose() {\n      if (_this4._gcHoldCounter > 0) {\n        _this4._gcHoldCounter--;\n\n        if (_this4._gcHoldCounter === 0 && _this4._shouldScheduleGC) {\n          _this4.scheduleGC();\n\n          _this4._shouldScheduleGC = false;\n        }\n      }\n    };\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.toJSON = function toJSON() {\n    return 'RelayModernStore()';\n  };\n\n  _proto.getEpoch = function getEpoch() {\n    return this._currentWriteEpoch;\n  } // Internal API\n  ;\n\n  _proto.__getUpdatedRecordIDs = function __getUpdatedRecordIDs() {\n    return this._updatedRecordIDs;\n  };\n\n  _proto.lookupInvalidationState = function lookupInvalidationState(dataIDs) {\n    var _this5 = this;\n\n    var invalidations = new Map();\n    dataIDs.forEach(function (dataID) {\n      var _RelayModernRecord$ge;\n\n      var record = _this5.getSource().get(dataID);\n\n      invalidations.set(dataID, (_RelayModernRecord$ge = RelayModernRecord.getInvalidationEpoch(record)) !== null && _RelayModernRecord$ge !== void 0 ? _RelayModernRecord$ge : null);\n    });\n    invalidations.set('global', this._globalInvalidationEpoch);\n    return {\n      dataIDs: dataIDs,\n      invalidations: invalidations\n    };\n  };\n\n  _proto.checkInvalidationState = function checkInvalidationState(prevInvalidationState) {\n    var latestInvalidationState = this.lookupInvalidationState(prevInvalidationState.dataIDs);\n    var currentInvalidations = latestInvalidationState.invalidations;\n    var prevInvalidations = prevInvalidationState.invalidations; // Check if global invalidation has changed\n\n    if (currentInvalidations.get('global') !== prevInvalidations.get('global')) {\n      return true;\n    } // Check if the invalidation state for any of the ids has changed.\n\n\n    var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(prevInvalidationState.dataIDs),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dataID = _step.value;\n\n        if (currentInvalidations.get(dataID) !== prevInvalidations.get(dataID)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return false;\n  };\n\n  _proto.subscribeToInvalidationState = function subscribeToInvalidationState(invalidationState, callback) {\n    var _this6 = this;\n\n    var subscription = {\n      callback: callback,\n      invalidationState: invalidationState\n    };\n\n    var dispose = function dispose() {\n      _this6._invalidationSubscriptions[\"delete\"](subscription);\n    };\n\n    this._invalidationSubscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto._updateInvalidationSubscription = function _updateInvalidationSubscription(subscription, invalidatedStore) {\n    var _this7 = this;\n\n    var callback = subscription.callback,\n        invalidationState = subscription.invalidationState;\n    var dataIDs = invalidationState.dataIDs;\n    var isSubscribedToInvalidatedIDs = invalidatedStore || dataIDs.some(function (dataID) {\n      return _this7._invalidatedRecordIDs.has(dataID);\n    });\n\n    if (!isSubscribedToInvalidatedIDs) {\n      return;\n    }\n\n    callback();\n  };\n\n  _proto.snapshot = function snapshot() {\n    !(this._optimisticSource == null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to snapshot() while a previous ' + 'snapshot exists.') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.snapshot'\n      });\n    }\n\n    this._storeSubscriptions.snapshotSubscriptions(this.getSource());\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._optimisticSource = RelayOptimisticRecordSource.create(this.getSource());\n  };\n\n  _proto.restore = function restore() {\n    !(this._optimisticSource != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to restore(), expected a snapshot ' + 'to exist (make sure to call snapshot()).') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.restore'\n      });\n    }\n\n    this._optimisticSource = null;\n\n    if (this._shouldScheduleGC) {\n      this.scheduleGC();\n    }\n\n    this._storeSubscriptions.restoreSubscriptions();\n  };\n\n  _proto.scheduleGC = function scheduleGC() {\n    if (this._gcHoldCounter > 0) {\n      this._shouldScheduleGC = true;\n      return;\n    }\n\n    if (this._gcRun) {\n      return;\n    }\n\n    this._gcRun = this._collect();\n\n    this._gcScheduler(this._gcStep);\n  }\n  /**\n   * Run a full GC synchronously.\n   */\n  ;\n\n  _proto.__gc = function __gc() {\n    // Don't run GC while there are optimistic updates applied\n    if (this._optimisticSource != null) {\n      return;\n    }\n\n    var gcRun = this._collect();\n\n    while (!gcRun.next().done) {}\n  };\n\n  _proto._collect = function* _collect() {\n    /* eslint-disable no-labels */\n    top: while (true) {\n      var startEpoch = this._currentWriteEpoch;\n      var references = new Set(); // Mark all records that are traversable from a root\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(this._roots.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var operation = _step2.value.operation;\n          var selector = operation.root;\n          RelayReferenceMarker.mark(this._recordSource, selector, references, this._operationLoader, this._shouldProcessClientComponents); // Yield for other work after each operation\n\n          yield; // If the store was updated, restart\n\n          if (startEpoch !== this._currentWriteEpoch) {\n            continue top;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var log = this.__log;\n\n      if (log != null) {\n        log({\n          name: 'store.gc',\n          references: references\n        });\n      } // Sweep records without references\n\n\n      if (references.size === 0) {\n        // Short-circuit if *nothing* is referenced\n        this._recordSource.clear();\n      } else {\n        // Evict any unreferenced nodes\n        var storeIDs = this._recordSource.getRecordIDs();\n\n        for (var ii = 0; ii < storeIDs.length; ii++) {\n          var dataID = storeIDs[ii];\n\n          if (!references.has(dataID)) {\n            this._recordSource.remove(dataID);\n          }\n        }\n      }\n\n      return;\n    }\n  };\n\n  return RelayModernStore;\n}();\n\nfunction initializeRecordSource(target) {\n  if (!target.has(ROOT_ID)) {\n    var rootRecord = RelayModernRecord.create(ROOT_ID, ROOT_TYPE);\n    target.set(ROOT_ID, rootRecord);\n  }\n}\n/**\n * Updates the target with information from source, also updating a mapping of\n * which records in the target were changed as a result.\n * Additionally, will mark records as invalidated at the current write epoch\n * given the set of record ids marked as stale in this update.\n */\n\n\nfunction updateTargetFromSource(target, source, currentWriteEpoch, idsMarkedForInvalidation, updatedRecordIDs, invalidatedRecordIDs) {\n  // First, update any records that were marked for invalidation.\n  // For each provided dataID that was invalidated, we write the\n  // INVALIDATED_AT_KEY on the record, indicating\n  // the epoch at which the record was invalidated.\n  if (idsMarkedForInvalidation) {\n    idsMarkedForInvalidation.forEach(function (dataID) {\n      var targetRecord = target.get(dataID);\n      var sourceRecord = source.get(dataID); // If record was deleted during the update (and also invalidated),\n      // we don't need to count it as an invalidated id\n\n      if (sourceRecord === null) {\n        return;\n      }\n\n      var nextRecord;\n\n      if (targetRecord != null) {\n        // If the target record exists, use it to set the epoch\n        // at which it was invalidated. This record will be updated with\n        // any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = RelayModernRecord.clone(targetRecord);\n      } else {\n        // If the target record doesn't exist, it means that a new record\n        // in the source was created (and also invalidated), so we use that\n        // record to set the epoch at which it was invalidated. This record\n        // will be updated with any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = sourceRecord != null ? RelayModernRecord.clone(sourceRecord) : null;\n      }\n\n      if (!nextRecord) {\n        return;\n      }\n\n      RelayModernRecord.setValue(nextRecord, RelayStoreUtils.INVALIDATED_AT_KEY, currentWriteEpoch);\n      invalidatedRecordIDs.add(dataID);\n      target.set(dataID, nextRecord);\n    });\n  } // Update the target based on the changes present in source\n\n\n  var dataIDs = source.getRecordIDs();\n\n  for (var ii = 0; ii < dataIDs.length; ii++) {\n    var dataID = dataIDs[ii];\n    var sourceRecord = source.get(dataID);\n    var targetRecord = target.get(dataID); // Prevent mutation of a record from outside the store.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (sourceRecord) {\n        RelayModernRecord.freeze(sourceRecord);\n      }\n    }\n\n    if (sourceRecord && targetRecord) {\n      // ReactFlightClientResponses are lazy and only materialize when readRoot\n      // is called when we read the field, so if the record is a Flight field\n      // we always use the new record's data regardless of whether\n      // it actually changed. Let React take care of reconciliation instead.\n      var nextRecord = RelayModernRecord.getType(targetRecord) === RelayStoreReactFlightUtils.REACT_FLIGHT_TYPE_NAME ? sourceRecord : RelayModernRecord.update(targetRecord, sourceRecord);\n\n      if (nextRecord !== targetRecord) {\n        // Prevent mutation of a record from outside the store.\n        if (process.env.NODE_ENV !== \"production\") {\n          RelayModernRecord.freeze(nextRecord);\n        }\n\n        updatedRecordIDs.add(dataID);\n        target.set(dataID, nextRecord);\n      }\n    } else if (sourceRecord === null) {\n      target[\"delete\"](dataID);\n\n      if (targetRecord !== null) {\n        updatedRecordIDs.add(dataID);\n      }\n    } else if (sourceRecord) {\n      target.set(dataID, sourceRecord);\n      updatedRecordIDs.add(dataID);\n    } // don't add explicit undefined\n\n  }\n}\n/**\n * Returns an OperationAvailability given the Availability returned\n * by checking an operation, and when that operation was last written to the store.\n * Specifically, the provided Availability of an operation will contain the\n * value of when a record referenced by the operation was most recently\n * invalidated; given that value, and given when this operation was last\n * written to the store, this function will return the overall\n * OperationAvailability for the operation.\n */\n\n\nfunction getAvailabilityStatus(operationAvailability, operationLastWrittenAt, operationFetchTime, queryCacheExpirationTime) {\n  var mostRecentlyInvalidatedAt = operationAvailability.mostRecentlyInvalidatedAt,\n      status = operationAvailability.status;\n\n  if (typeof mostRecentlyInvalidatedAt === 'number') {\n    // If some record referenced by this operation is stale, then the operation itself is stale\n    // if either the operation itself was never written *or* the operation was last written\n    // before the most recent invalidation of its reachable records.\n    if (operationLastWrittenAt == null || mostRecentlyInvalidatedAt > operationLastWrittenAt) {\n      return {\n        status: 'stale'\n      };\n    }\n  }\n\n  if (status === 'missing') {\n    return {\n      status: 'missing'\n    };\n  }\n\n  if (operationFetchTime != null && queryCacheExpirationTime != null) {\n    var isStale = operationFetchTime <= Date.now() - queryCacheExpirationTime;\n\n    if (isStale) {\n      return {\n        status: 'stale'\n      };\n    }\n  } // There were no invalidations of any reachable records *or* the operation is known to have\n  // been fetched after the most recent record invalidation.\n\n\n  return {\n    status: 'available',\n    fetchTime: operationFetchTime !== null && operationFetchTime !== void 0 ? operationFetchTime : null\n  };\n}\n\nmodule.exports = RelayModernStore;"]},"metadata":{},"sourceType":"script"}