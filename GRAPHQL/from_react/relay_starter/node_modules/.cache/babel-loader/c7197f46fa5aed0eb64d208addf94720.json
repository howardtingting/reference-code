{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar RelayObservable = require('../network/RelayObservable');\n\nvar generateID = require('../util/generateID');\n\nvar getOperation = require('../util/getOperation');\n\nvar RelayError = require('../util/RelayError');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar stableCopy = require('../util/stableCopy');\n\nvar withDuration = require('../util/withDuration');\n\nvar _require = require('./ClientID'),\n    generateClientID = _require.generateClientID,\n    generateUniqueClientID = _require.generateUniqueClientID;\n\nvar _require2 = require('./RelayConcreteVariables'),\n    getLocalVariables = _require2.getLocalVariables;\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require3 = require('./RelayModernSelector'),\n    createNormalizationSelector = _require3.createNormalizationSelector,\n    createReaderSelector = _require3.createReaderSelector;\n\nvar RelayRecordSource = require('./RelayRecordSource');\n\nvar RelayResponseNormalizer = require('./RelayResponseNormalizer');\n\nvar _require4 = require('./RelayStoreUtils'),\n    ROOT_TYPE = _require4.ROOT_TYPE,\n    TYPENAME_KEY = _require4.TYPENAME_KEY,\n    getStorageKey = _require4.getStorageKey;\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nfunction execute(config) {\n  return new Executor(config);\n}\n/**\n * Coordinates the execution of a query, handling network callbacks\n * including optimistic payloads, standard payloads, resolution of match\n * dependencies, etc.\n */\n\n\nvar Executor = /*#__PURE__*/function () {\n  function Executor(_ref) {\n    var _this = this;\n\n    var actorIdentifier = _ref.actorIdentifier,\n        getDataID = _ref.getDataID,\n        getPublishQueue = _ref.getPublishQueue,\n        getStore = _ref.getStore,\n        isClientPayload = _ref.isClientPayload,\n        operation = _ref.operation,\n        operationExecutions = _ref.operationExecutions,\n        operationLoader = _ref.operationLoader,\n        operationTracker = _ref.operationTracker,\n        optimisticConfig = _ref.optimisticConfig,\n        _reactFlightPayloadDeserializer = _ref.reactFlightPayloadDeserializer,\n        reactFlightServerErrorHandler = _ref.reactFlightServerErrorHandler,\n        scheduler = _ref.scheduler,\n        shouldProcessClientComponents = _ref.shouldProcessClientComponents,\n        sink = _ref.sink,\n        source = _ref.source,\n        treatMissingFieldsAsNull = _ref.treatMissingFieldsAsNull,\n        updater = _ref.updater,\n        log = _ref.log;\n    (0, _defineProperty2[\"default\"])(this, \"_deserializeReactFlightPayloadWithLogging\", function (tree) {\n      var reactFlightPayloadDeserializer = _this._reactFlightPayloadDeserializer;\n      !(typeof reactFlightPayloadDeserializer === 'function') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected reactFlightPayloadDeserializer to be available when calling _deserializeReactFlightPayloadWithLogging.') : invariant(false) : void 0;\n\n      var _withDuration = withDuration(function () {\n        return reactFlightPayloadDeserializer(tree);\n      }),\n          duration = _withDuration[0],\n          result = _withDuration[1];\n\n      _this._log({\n        name: 'execute.flight.payload_deserialize',\n        executeId: _this._executeId,\n        operationName: _this._operation.request.node.params.name,\n        duration: duration\n      });\n\n      return result;\n    });\n    this._actorIdentifier = actorIdentifier;\n    this._getDataID = getDataID;\n    this._treatMissingFieldsAsNull = treatMissingFieldsAsNull;\n    this._incrementalPayloadsPending = false;\n    this._incrementalResults = new Map();\n    this._log = log;\n    this._executeId = generateID();\n    this._nextSubscriptionId = 0;\n    this._operation = operation;\n    this._operationExecutions = operationExecutions;\n    this._operationLoader = operationLoader;\n    this._operationTracker = operationTracker;\n    this._operationUpdateEpochs = new Map();\n    this._optimisticUpdates = null;\n    this._pendingModulePayloadsCount = 0;\n    this._getPublishQueue = getPublishQueue;\n    this._scheduler = scheduler;\n    this._sink = sink;\n    this._source = new Map();\n    this._state = 'started';\n    this._getStore = getStore;\n    this._subscriptions = new Map();\n    this._updater = updater;\n    this._isClientPayload = isClientPayload === true;\n    this._reactFlightPayloadDeserializer = _reactFlightPayloadDeserializer;\n    this._reactFlightServerErrorHandler = reactFlightServerErrorHandler;\n    this._isSubscriptionOperation = this._operation.request.node.params.operationKind === 'subscription';\n    this._shouldProcessClientComponents = shouldProcessClientComponents;\n    this._retainDisposables = new Map();\n    this._seenActors = new Set();\n    this._completeFns = [];\n    var id = this._nextSubscriptionId++;\n    source.subscribe({\n      complete: function complete() {\n        return _this._complete(id);\n      },\n      error: function error(_error2) {\n        return _this._error(_error2);\n      },\n      next: function next(response) {\n        try {\n          _this._next(id, response);\n        } catch (error) {\n          sink.error(error);\n        }\n      },\n      start: function start(subscription) {\n        var _this$_operation$requ;\n\n        _this._start(id, subscription);\n\n        _this._log({\n          name: 'execute.start',\n          executeId: _this._executeId,\n          params: _this._operation.request.node.params,\n          variables: _this._operation.request.variables,\n          cacheConfig: (_this$_operation$requ = _this._operation.request.cacheConfig) !== null && _this$_operation$requ !== void 0 ? _this$_operation$requ : {}\n        });\n      }\n    });\n\n    if (optimisticConfig != null) {\n      this._processOptimisticResponse(optimisticConfig.response != null ? {\n        data: optimisticConfig.response\n      } : null, optimisticConfig.updater, false);\n    }\n  } // Cancel any pending execution tasks and mark the executor as completed.\n\n\n  var _proto = Executor.prototype;\n\n  _proto.cancel = function cancel() {\n    var _this2 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    this._state = 'completed';\n\n    this._operationExecutions[\"delete\"](this._operation.request.identifier);\n\n    if (this._subscriptions.size !== 0) {\n      this._subscriptions.forEach(function (sub) {\n        return sub.unsubscribe();\n      });\n\n      this._subscriptions.clear();\n    }\n\n    var optimisticUpdates = this._optimisticUpdates;\n\n    if (optimisticUpdates !== null) {\n      this._optimisticUpdates = null;\n      optimisticUpdates.forEach(function (update) {\n        return _this2._getPublishQueueAndSaveActor().revertUpdate(update);\n      }); // OK: run revert on cancel\n\n      this._runPublishQueue();\n    }\n\n    this._incrementalResults.clear();\n\n    if (this._asyncStoreUpdateDisposable != null) {\n      this._asyncStoreUpdateDisposable.dispose();\n\n      this._asyncStoreUpdateDisposable = null;\n    }\n\n    this._completeFns = [];\n\n    this._completeOperationTracker();\n\n    this._disposeRetainedData();\n  };\n\n  _proto._updateActiveState = function _updateActiveState() {\n    var activeState;\n\n    switch (this._state) {\n      case 'started':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'loading_incremental':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'completed':\n        {\n          activeState = 'inactive';\n          break;\n        }\n\n      case 'loading_final':\n        {\n          activeState = this._pendingModulePayloadsCount > 0 ? 'active' : 'inactive';\n          break;\n        }\n\n      default:\n        this._state;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: invalid executor state.') : invariant(false) : void 0;\n    }\n\n    this._operationExecutions.set(this._operation.request.identifier, activeState);\n  };\n\n  _proto._schedule = function _schedule(task) {\n    var _this3 = this;\n\n    var scheduler = this._scheduler;\n\n    if (scheduler != null) {\n      var _id2 = this._nextSubscriptionId++;\n\n      RelayObservable.create(function (sink) {\n        var cancellationToken = scheduler.schedule(function () {\n          try {\n            task();\n            sink.complete();\n          } catch (error) {\n            sink.error(error);\n          }\n        });\n        return function () {\n          return scheduler.cancel(cancellationToken);\n        };\n      }).subscribe({\n        complete: function complete() {\n          return _this3._complete(_id2);\n        },\n        error: function error(_error3) {\n          return _this3._error(_error3);\n        },\n        start: function start(subscription) {\n          return _this3._start(_id2, subscription);\n        }\n      });\n    } else {\n      task();\n    }\n  };\n\n  _proto._complete = function _complete(id) {\n    this._subscriptions[\"delete\"](id);\n\n    if (this._subscriptions.size === 0) {\n      this.cancel();\n\n      this._sink.complete();\n\n      this._log({\n        name: 'execute.complete',\n        executeId: this._executeId\n      });\n    }\n  };\n\n  _proto._error = function _error(error) {\n    this.cancel();\n\n    this._sink.error(error);\n\n    this._log({\n      name: 'execute.error',\n      executeId: this._executeId,\n      error: error\n    });\n  };\n\n  _proto._start = function _start(id, subscription) {\n    this._subscriptions.set(id, subscription);\n\n    this._updateActiveState();\n  } // Handle a raw GraphQL response.\n  ;\n\n  _proto._next = function _next(_id, response) {\n    var _this4 = this;\n\n    this._schedule(function () {\n      var _withDuration2 = withDuration(function () {\n        _this4._handleNext(response);\n\n        _this4._maybeCompleteSubscriptionOperationTracking();\n      }),\n          duration = _withDuration2[0];\n\n      _this4._log({\n        name: 'execute.next',\n        executeId: _this4._executeId,\n        response: response,\n        duration: duration\n      });\n    });\n  };\n\n  _proto._handleErrorResponse = function _handleErrorResponse(responses) {\n    var _this5 = this;\n\n    var results = [];\n    responses.forEach(function (response) {\n      if (response.data === null && response.extensions != null && !response.hasOwnProperty('errors')) {\n        // Skip extensions-only payloads\n        return;\n      } else if (response.data == null) {\n        // Error if any other payload in the batch is missing data, regardless of whether\n        // it had `errors` or not.\n        var errors = response.hasOwnProperty('errors') && response.errors != null ? response.errors : null;\n        var messages = errors ? errors.map(function (_ref2) {\n          var message = _ref2.message;\n          return message;\n        }).join('\\n') : '(No errors)';\n        var error = RelayError.create('RelayNetwork', 'No data returned for operation `' + _this5._operation.request.node.params.name + '`, got error(s):\\n' + messages + '\\n\\nSee the error `source` property for more information.');\n        error.source = {\n          errors: errors,\n          operation: _this5._operation.request.node,\n          variables: _this5._operation.request.variables\n        }; // In V8, Error objects keep the closure scope chain alive until the\n        // err.stack property is accessed.\n\n        error.stack;\n        throw error;\n      } else {\n        var responseWithData = response;\n        results.push(responseWithData);\n      }\n    });\n    return results;\n  }\n  /**\n   * This method return boolean to indicate if the optimistic\n   * response has been handled\n   */\n  ;\n\n  _proto._handleOptimisticResponses = function _handleOptimisticResponses(responses) {\n    var _response$extensions;\n\n    if (responses.length > 1) {\n      if (responses.some(function (responsePart) {\n        var _responsePart$extensi;\n\n        return ((_responsePart$extensi = responsePart.extensions) === null || _responsePart$extensi === void 0 ? void 0 : _responsePart$extensi.isOptimistic) === true;\n      })) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Optimistic responses cannot be batched.') : invariant(false) : void 0;\n      }\n\n      return false;\n    }\n\n    var response = responses[0];\n    var isOptimistic = ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.isOptimistic) === true;\n\n    if (isOptimistic && this._state !== 'started') {\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: optimistic payload received after server payload.') : invariant(false) : void 0;\n    }\n\n    if (isOptimistic) {\n      this._processOptimisticResponse(response, null, this._treatMissingFieldsAsNull);\n\n      this._sink.next(response);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto._handleNext = function _handleNext(response) {\n    if (this._state === 'completed') {\n      return;\n    }\n\n    this._seenActors.clear();\n\n    var responses = Array.isArray(response) ? response : [response];\n\n    var responsesWithData = this._handleErrorResponse(responses);\n\n    if (responsesWithData.length === 0) {\n      // no results with data, nothing to process\n      // this can occur with extensions-only payloads\n      var isFinal = responses.some(function (x) {\n        var _x$extensions;\n\n        return ((_x$extensions = x.extensions) === null || _x$extensions === void 0 ? void 0 : _x$extensions.is_final) === true;\n      });\n\n      if (isFinal) {\n        this._state = 'loading_final';\n\n        this._updateActiveState();\n\n        this._incrementalPayloadsPending = false;\n      }\n\n      this._sink.next(response);\n\n      return;\n    } // Next, handle optimistic responses\n\n\n    var isOptimistic = this._handleOptimisticResponses(responsesWithData);\n\n    if (isOptimistic) {\n      return;\n    }\n\n    var _partitionGraphQLResp = partitionGraphQLResponses(responsesWithData),\n        nonIncrementalResponses = _partitionGraphQLResp[0],\n        incrementalResponses = _partitionGraphQLResp[1];\n\n    var hasNonIncrementalResponses = nonIncrementalResponses.length > 0; // In theory this doesn't preserve the ordering of the batch.\n    // The idea is that a batch is always:\n    //  * at most one non-incremental payload\n    //  * followed by zero or more incremental payloads\n    // The non-incremental payload can appear if the server sends a batch\n    // with the initial payload followed by some early-to-resolve incremental\n    // payloads (although, can that even happen?)\n\n    if (hasNonIncrementalResponses) {\n      // For subscriptions, to avoid every new payload from overwriting existing\n      // data from previous payloads, assign a unique rootID for every new\n      // non-incremental payload.\n      if (this._isSubscriptionOperation) {\n        var nextID = generateUniqueClientID();\n        this._operation = {\n          request: this._operation.request,\n          fragment: createReaderSelector(this._operation.fragment.node, nextID, this._operation.fragment.variables, this._operation.fragment.owner),\n          root: createNormalizationSelector(this._operation.root.node, nextID, this._operation.root.variables)\n        };\n      }\n\n      var payloadFollowups = this._processResponses(nonIncrementalResponses);\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n\n    if (incrementalResponses.length > 0) {\n      var _payloadFollowups = this._processIncrementalResponses(incrementalResponses);\n\n      this._processPayloadFollowups(_payloadFollowups);\n    }\n\n    if (this._isSubscriptionOperation) {\n      // We attach the id to allow the `requestSubscription` to read from the store using\n      // the current id in its `onNext` callback\n      if (responsesWithData[0].extensions == null) {\n        // $FlowFixMe[cannot-write]\n        responsesWithData[0].extensions = {\n          __relay_subscription_root_id: this._operation.fragment.dataID\n        };\n      } else {\n        responsesWithData[0].extensions.__relay_subscription_root_id = this._operation.fragment.dataID;\n      }\n    } // OK: run once after each new payload\n    // If we have non-incremental responses, we passing `this._operation` to\n    // the publish queue here, which will later be passed to the store (via\n    // notify) to indicate that this operation caused the store to update\n\n\n    var updatedOwners = this._runPublishQueue(hasNonIncrementalResponses ? this._operation : undefined);\n\n    if (hasNonIncrementalResponses) {\n      if (this._incrementalPayloadsPending) {\n        this._retainData();\n      }\n    }\n\n    this._updateOperationTracker(updatedOwners);\n\n    this._sink.next(response);\n  };\n\n  _proto._processOptimisticResponse = function _processOptimisticResponse(response, updater, treatMissingFieldsAsNull) {\n    var _this6 = this;\n\n    !(this._optimisticUpdates === null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: environment.execute: only support one optimistic response per ' + 'execute.') : invariant(false) : void 0;\n\n    if (response == null && updater == null) {\n      return;\n    }\n\n    var optimisticUpdates = [];\n\n    if (response) {\n      var payload = normalizeResponse(response, this._operation.root, ROOT_TYPE, {\n        actorIdentifier: this._actorIdentifier,\n        getDataID: this._getDataID,\n        path: [],\n        reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n        reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n        shouldProcessClientComponents: this._shouldProcessClientComponents,\n        treatMissingFieldsAsNull: treatMissingFieldsAsNull\n      });\n      validateOptimisticResponsePayload(payload);\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: payload,\n        updater: updater\n      });\n\n      this._processOptimisticFollowups(payload, optimisticUpdates);\n    } else if (updater) {\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: {\n          errors: null,\n          fieldPayloads: null,\n          incrementalPlaceholders: null,\n          followupPayloads: null,\n          source: RelayRecordSource.create(),\n          isFinal: false\n        },\n        updater: updater\n      });\n    }\n\n    this._optimisticUpdates = optimisticUpdates;\n    optimisticUpdates.forEach(function (update) {\n      return _this6._getPublishQueueAndSaveActor().applyUpdate(update);\n    }); // OK: only called on construction and when receiving an optimistic payload from network,\n    // which doesn't fall-through to the regular next() handling\n\n    this._runPublishQueue();\n  };\n\n  _proto._processOptimisticFollowups = function _processOptimisticFollowups(payload, optimisticUpdates) {\n    if (payload.followupPayloads && payload.followupPayloads.length) {\n      var followupPayloads = payload.followupPayloads;\n\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(followupPayloads),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var followupPayload = _step.value;\n\n          switch (followupPayload.kind) {\n            case 'ModuleImportPayload':\n              var operationLoader = this._expectOperationLoader();\n\n              var operation = operationLoader.get(followupPayload.operationReference);\n\n              if (operation == null) {\n                this._processAsyncOptimisticModuleImport(followupPayload);\n              } else {\n                var moduleImportOptimisticUpdates = this._processOptimisticModuleImport(operation, followupPayload);\n\n                optimisticUpdates.push.apply(optimisticUpdates, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisticUpdates));\n              }\n\n              break;\n\n            case 'ActorPayload':\n              process.env.NODE_ENV !== \"production\" ? warning(false, 'OperationExecutor: Unexpected optimistic ActorPayload. These updates are not supported.') : void 0;\n              break;\n\n            default:\n              followupPayload;\n              !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Unexpected followup kind `%s`. when processing optimistic updates.', followupPayload.kind) : invariant(false) : void 0;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n  /**\n   * Normalize Data for @module payload, and actor-specific payload\n   */\n  ;\n\n  _proto._normalizeFollowupPayload = function _normalizeFollowupPayload(followupPayload, normalizationNode) {\n    var variables;\n\n    if (normalizationNode.kind === 'SplitOperation' && followupPayload.kind === 'ModuleImportPayload') {\n      variables = getLocalVariables(followupPayload.variables, normalizationNode.argumentDefinitions, followupPayload.args);\n    } else {\n      variables = followupPayload.variables;\n    }\n\n    var selector = createNormalizationSelector(normalizationNode, followupPayload.dataID, variables);\n    return normalizeResponse({\n      data: followupPayload.data\n    }, selector, followupPayload.typeName, {\n      actorIdentifier: this._actorIdentifier,\n      getDataID: this._getDataID,\n      path: followupPayload.path,\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n  };\n\n  _proto._processOptimisticModuleImport = function _processOptimisticModuleImport(normalizationRootNode, moduleImportPayload) {\n    var operation = getOperation(normalizationRootNode);\n    var optimisticUpdates = [];\n\n    var modulePayload = this._normalizeFollowupPayload(moduleImportPayload, operation);\n\n    validateOptimisticResponsePayload(modulePayload);\n    optimisticUpdates.push({\n      operation: this._operation,\n      payload: modulePayload,\n      updater: null\n    });\n\n    this._processOptimisticFollowups(modulePayload, optimisticUpdates);\n\n    return optimisticUpdates;\n  };\n\n  _proto._processAsyncOptimisticModuleImport = function _processAsyncOptimisticModuleImport(moduleImportPayload) {\n    var _this7 = this;\n\n    this._expectOperationLoader().load(moduleImportPayload.operationReference).then(function (operation) {\n      if (operation == null || _this7._state !== 'started') {\n        return;\n      }\n\n      var moduleImportOptimisticUpdates = _this7._processOptimisticModuleImport(operation, moduleImportPayload);\n\n      moduleImportOptimisticUpdates.forEach(function (update) {\n        return _this7._getPublishQueueAndSaveActor().applyUpdate(update);\n      });\n\n      if (_this7._optimisticUpdates == null) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'OperationExecutor: Unexpected ModuleImport optimistic ' + 'update in operation %s.' + _this7._operation.request.node.params.name) : void 0;\n      } else {\n        var _this$_optimisticUpda;\n\n        (_this$_optimisticUpda = _this7._optimisticUpdates).push.apply(_this$_optimisticUpda, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisticUpdates)); // OK: always have to run() after an module import resolves async\n\n\n        _this7._runPublishQueue();\n      }\n    });\n  };\n\n  _proto._processResponses = function _processResponses(responses) {\n    var _this8 = this;\n\n    if (this._optimisticUpdates !== null) {\n      this._optimisticUpdates.forEach(function (update) {\n        _this8._getPublishQueueAndSaveActor().revertUpdate(update);\n      });\n\n      this._optimisticUpdates = null;\n    }\n\n    this._incrementalPayloadsPending = false;\n\n    this._incrementalResults.clear();\n\n    this._source.clear();\n\n    return responses.map(function (payloadPart) {\n      var relayPayload = normalizeResponse(payloadPart, _this8._operation.root, ROOT_TYPE, {\n        actorIdentifier: _this8._actorIdentifier,\n        getDataID: _this8._getDataID,\n        path: [],\n        reactFlightPayloadDeserializer: _this8._reactFlightPayloadDeserializer != null ? _this8._deserializeReactFlightPayloadWithLogging : null,\n        reactFlightServerErrorHandler: _this8._reactFlightServerErrorHandler,\n        treatMissingFieldsAsNull: _this8._treatMissingFieldsAsNull,\n        shouldProcessClientComponents: _this8._shouldProcessClientComponents\n      });\n\n      _this8._getPublishQueueAndSaveActor().commitPayload(_this8._operation, relayPayload, _this8._updater);\n\n      return relayPayload;\n    });\n  }\n  /**\n   * Handles any follow-up actions for a Relay payload for @match, @defer,\n   * and @stream directives.\n   */\n  ;\n\n  _proto._processPayloadFollowups = function _processPayloadFollowups(payloads) {\n    var _this9 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    payloads.forEach(function (payload) {\n      var incrementalPlaceholders = payload.incrementalPlaceholders,\n          followupPayloads = payload.followupPayloads,\n          isFinal = payload.isFinal;\n      _this9._state = isFinal ? 'loading_final' : 'loading_incremental';\n\n      _this9._updateActiveState();\n\n      if (isFinal) {\n        _this9._incrementalPayloadsPending = false;\n      }\n\n      if (followupPayloads && followupPayloads.length !== 0) {\n        followupPayloads.forEach(function (followupPayload) {\n          var _followupPayload$acto;\n\n          var prevActorIdentifier = _this9._actorIdentifier;\n          _this9._actorIdentifier = (_followupPayload$acto = followupPayload.actorIdentifier) !== null && _followupPayload$acto !== void 0 ? _followupPayload$acto : _this9._actorIdentifier;\n\n          _this9._processFollowupPayload(followupPayload);\n\n          _this9._actorIdentifier = prevActorIdentifier;\n        });\n      }\n\n      if (incrementalPlaceholders && incrementalPlaceholders.length !== 0) {\n        _this9._incrementalPayloadsPending = _this9._state !== 'loading_final';\n        incrementalPlaceholders.forEach(function (incrementalPlaceholder) {\n          var _incrementalPlacehold;\n\n          var prevActorIdentifier = _this9._actorIdentifier;\n          _this9._actorIdentifier = (_incrementalPlacehold = incrementalPlaceholder.actorIdentifier) !== null && _incrementalPlacehold !== void 0 ? _incrementalPlacehold : _this9._actorIdentifier;\n\n          _this9._processIncrementalPlaceholder(payload, incrementalPlaceholder);\n\n          _this9._actorIdentifier = prevActorIdentifier;\n        });\n\n        if (_this9._isClientPayload || _this9._state === 'loading_final') {\n          // The query has defer/stream selections that are enabled, but either\n          // the server indicated that this is a \"final\" payload: no incremental\n          // payloads will be delivered, then warn that the query was (likely)\n          // executed on the server in non-streaming mode, with incremental\n          // delivery disabled; or this is a client payload, and there will be\n          // no incremental payload.\n          process.env.NODE_ENV !== \"production\" ? warning(_this9._isClientPayload, 'RelayModernEnvironment: Operation `%s` contains @defer/@stream ' + 'directives but was executed in non-streaming mode. See ' + 'https://fburl.com/relay-incremental-delivery-non-streaming-warning.', _this9._operation.request.node.params.name) : void 0; // But eagerly process any deferred payloads\n\n          var relayPayloads = [];\n          incrementalPlaceholders.forEach(function (placeholder) {\n            if (placeholder.kind === 'defer') {\n              relayPayloads.push(_this9._processDeferResponse(placeholder.label, placeholder.path, placeholder, {\n                data: placeholder.data\n              }));\n            }\n          });\n\n          if (relayPayloads.length > 0) {\n            _this9._processPayloadFollowups(relayPayloads);\n          }\n        }\n      }\n    });\n  };\n\n  _proto._maybeCompleteSubscriptionOperationTracking = function _maybeCompleteSubscriptionOperationTracking() {\n    if (!this._isSubscriptionOperation) {\n      return;\n    }\n\n    if (this._pendingModulePayloadsCount === 0 && this._incrementalPayloadsPending === false) {\n      this._completeOperationTracker();\n    }\n  }\n  /**\n   * Processes a ModuleImportPayload, asynchronously resolving the normalization\n   * AST and using it to normalize the field data into a RelayResponsePayload.\n   * The resulting payload may contain other incremental payloads (match,\n   * defer, stream, etc); these are handled by calling\n   * `_processPayloadFollowups()`.\n   */\n  ;\n\n  _proto._processFollowupPayload = function _processFollowupPayload(followupPayload) {\n    var _this10 = this;\n\n    switch (followupPayload.kind) {\n      case 'ModuleImportPayload':\n        var operationLoader = this._expectOperationLoader();\n\n        var node = operationLoader.get(followupPayload.operationReference);\n\n        if (node != null) {\n          // If the operation module is available synchronously, normalize the\n          // data synchronously.\n          this._processFollowupPayloadWithNormalizationNode(followupPayload, getOperation(node));\n        } else {\n          // Otherwise load the operation module and schedule a task to normalize\n          // the data when the module is available.\n          var _id3 = this._nextSubscriptionId++;\n\n          this._pendingModulePayloadsCount++;\n\n          var decrementPendingCount = function decrementPendingCount() {\n            _this10._pendingModulePayloadsCount--;\n\n            _this10._maybeCompleteSubscriptionOperationTracking();\n          }; // Observable.from(operationLoader.load()) wouldn't catch synchronous\n          // errors thrown by the load function, which is user-defined. Guard\n          // against that with Observable.from(new Promise(<work>)).\n\n\n          var networkObservable = RelayObservable.from(new Promise(function (resolve, reject) {\n            operationLoader.load(followupPayload.operationReference).then(resolve, reject);\n          }));\n          RelayObservable.create(function (sink) {\n            var cancellationToken;\n            var subscription = networkObservable.subscribe({\n              next: function next(loadedNode) {\n                if (loadedNode != null) {\n                  var publishModuleImportPayload = function publishModuleImportPayload() {\n                    try {\n                      var operation = getOperation(loadedNode);\n                      var batchAsyncModuleUpdatesFN = RelayFeatureFlags.BATCH_ASYNC_MODULE_UPDATES_FN;\n                      var shouldScheduleAsyncStoreUpdate = batchAsyncModuleUpdatesFN != null && _this10._pendingModulePayloadsCount > 1;\n\n                      var _withDuration3 = withDuration(function () {\n                        _this10._handleFollowupPayload(followupPayload, operation); // OK: always have to run after an async module import resolves\n                        // OK: always have to run after an async module import resolves\n\n\n                        if (shouldScheduleAsyncStoreUpdate) {\n                          _this10._scheduleAsyncStoreUpdate( // $FlowFixMe[incompatible-call] `shouldScheduleAsyncStoreUpdate` check should cover `null` case\n                          batchAsyncModuleUpdatesFN, sink.complete);\n                        } else {\n                          var updatedOwners = _this10._runPublishQueue();\n\n                          _this10._updateOperationTracker(updatedOwners);\n                        }\n                      }),\n                          duration = _withDuration3[0];\n\n                      _this10._log({\n                        name: 'execute.async.module',\n                        executeId: _this10._executeId,\n                        operationName: operation.name,\n                        duration: duration\n                      });\n\n                      if (!shouldScheduleAsyncStoreUpdate) {\n                        sink.complete();\n                      }\n                    } catch (error) {\n                      sink.error(error);\n                    }\n                  };\n\n                  var scheduler = _this10._scheduler;\n\n                  if (scheduler == null) {\n                    publishModuleImportPayload();\n                  } else {\n                    cancellationToken = scheduler.schedule(publishModuleImportPayload);\n                  }\n                } else {\n                  sink.complete();\n                }\n              },\n              error: sink.error\n            });\n            return function () {\n              subscription.unsubscribe();\n\n              if (_this10._scheduler != null && cancellationToken != null) {\n                _this10._scheduler.cancel(cancellationToken);\n              }\n            };\n          }).subscribe({\n            complete: function complete() {\n              _this10._complete(_id3);\n\n              decrementPendingCount();\n            },\n            error: function error(_error4) {\n              _this10._error(_error4);\n\n              decrementPendingCount();\n            },\n            start: function start(subscription) {\n              return _this10._start(_id3, subscription);\n            }\n          });\n        }\n\n        break;\n\n      case 'ActorPayload':\n        this._processFollowupPayloadWithNormalizationNode(followupPayload, followupPayload.node);\n\n        break;\n\n      default:\n        followupPayload;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Unexpected followup kind `%s`.', followupPayload.kind) : invariant(false) : void 0;\n    }\n  };\n\n  _proto._processFollowupPayloadWithNormalizationNode = function _processFollowupPayloadWithNormalizationNode(followupPayload, normalizationNode) {\n    this._handleFollowupPayload(followupPayload, normalizationNode);\n\n    this._maybeCompleteSubscriptionOperationTracking();\n  };\n\n  _proto._handleFollowupPayload = function _handleFollowupPayload(followupPayload, normalizationNode) {\n    var relayPayload = this._normalizeFollowupPayload(followupPayload, normalizationNode);\n\n    this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload);\n\n    this._processPayloadFollowups([relayPayload]);\n  }\n  /**\n   * The executor now knows that GraphQL responses are expected for a given\n   * label/path:\n   * - Store the placeholder in order to process any future responses that may\n   *   arrive.\n   * - Then process any responses that had already arrived.\n   *\n   * The placeholder contains the normalization selector, path (for nested\n   * defer/stream), and other metadata used to normalize the incremental\n   * response(s).\n   */\n  ;\n\n  _proto._processIncrementalPlaceholder = function _processIncrementalPlaceholder(relayPayload, placeholder) {\n    var _relayPayload$fieldPa; // Update the label => path => placeholder map\n\n\n    var label = placeholder.label,\n        path = placeholder.path;\n    var pathKey = path.map(String).join('.');\n\n    var resultForLabel = this._incrementalResults.get(label);\n\n    if (resultForLabel == null) {\n      resultForLabel = new Map();\n\n      this._incrementalResults.set(label, resultForLabel);\n    }\n\n    var resultForPath = resultForLabel.get(pathKey);\n    var pendingResponses = resultForPath != null && resultForPath.kind === 'response' ? resultForPath.responses : null;\n    resultForLabel.set(pathKey, {\n      kind: 'placeholder',\n      placeholder: placeholder\n    }); // Store references to the parent node to allow detecting concurrent\n    // modifications to the parent before items arrive and to replay\n    // handle field payloads to account for new information on source records.\n\n    var parentID;\n\n    if (placeholder.kind === 'stream') {\n      parentID = placeholder.parentID;\n    } else if (placeholder.kind === 'defer') {\n      parentID = placeholder.selector.dataID;\n    } else {\n      placeholder;\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Unsupported incremental placeholder kind `%s`.', placeholder.kind) : invariant(false) : void 0;\n    }\n\n    var parentRecord = relayPayload.source.get(parentID);\n    var parentPayloads = ((_relayPayload$fieldPa = relayPayload.fieldPayloads) !== null && _relayPayload$fieldPa !== void 0 ? _relayPayload$fieldPa : []).filter(function (fieldPayload) {\n      var fieldID = generateClientID(fieldPayload.dataID, fieldPayload.fieldKey);\n      return (// handlers applied to the streamed field itself\n        fieldPayload.dataID === parentID || // handlers applied to a field on an ancestor object, where\n        // ancestor.field links to the parent record (example: connections)\n        fieldID === parentID\n      );\n    }); // If an incremental payload exists for some id that record should also\n    // exist.\n\n    !(parentRecord != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected record `%s` to exist.', parentID) : invariant(false) : void 0;\n    var nextParentRecord;\n    var nextParentPayloads;\n\n    var previousParentEntry = this._source.get(parentID);\n\n    if (previousParentEntry != null) {\n      // If a previous entry exists, merge the previous/next records and\n      // payloads together.\n      nextParentRecord = RelayModernRecord.update(previousParentEntry.record, parentRecord);\n      var handlePayloads = new Map();\n\n      var dedupePayload = function dedupePayload(payload) {\n        var key = stableStringify(payload);\n        handlePayloads.set(key, payload);\n      };\n\n      previousParentEntry.fieldPayloads.forEach(dedupePayload);\n      parentPayloads.forEach(dedupePayload);\n      nextParentPayloads = Array.from(handlePayloads.values());\n    } else {\n      nextParentRecord = parentRecord;\n      nextParentPayloads = parentPayloads;\n    }\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: nextParentPayloads\n    }); // If there were any queued responses, process them now that placeholders\n    // are in place\n\n\n    if (pendingResponses != null) {\n      var payloadFollowups = this._processIncrementalResponses(pendingResponses);\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n  }\n  /**\n   * Lookup the placeholder the describes how to process an incremental\n   * response, normalize/publish it, and process any nested defer/match/stream\n   * metadata.\n   */\n  ;\n\n  _proto._processIncrementalResponses = function _processIncrementalResponses(incrementalResponses) {\n    var _this11 = this;\n\n    var relayPayloads = [];\n    incrementalResponses.forEach(function (incrementalResponse) {\n      var label = incrementalResponse.label,\n          path = incrementalResponse.path,\n          response = incrementalResponse.response;\n\n      var resultForLabel = _this11._incrementalResults.get(label);\n\n      if (resultForLabel == null) {\n        resultForLabel = new Map();\n\n        _this11._incrementalResults.set(label, resultForLabel);\n      }\n\n      if (label.indexOf('$defer$') !== -1) {\n        var pathKey = path.map(String).join('.');\n        var resultForPath = resultForLabel.get(pathKey);\n\n        if (resultForPath == null) {\n          resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(pathKey, resultForPath);\n          return;\n        } else if (resultForPath.kind === 'response') {\n          resultForPath.responses.push(incrementalResponse);\n          return;\n        }\n\n        var placeholder = resultForPath.placeholder;\n        !(placeholder.kind === 'defer') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected data for path `%s` for label `%s` ' + 'to be data for @defer, was `@%s`.', pathKey, label, placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processDeferResponse(label, path, placeholder, response));\n      } else {\n        // @stream payload path values end in the field name and item index,\n        // but Relay records paths relative to the parent of the stream node:\n        // therefore we strip the last two elements just to lookup the path\n        // (the item index is used later to insert the element in the list)\n        var _pathKey = path.slice(0, -2).map(String).join('.');\n\n        var _resultForPath = resultForLabel.get(_pathKey);\n\n        if (_resultForPath == null) {\n          _resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(_pathKey, _resultForPath);\n          return;\n        } else if (_resultForPath.kind === 'response') {\n          _resultForPath.responses.push(incrementalResponse);\n\n          return;\n        }\n\n        var _placeholder = _resultForPath.placeholder;\n        !(_placeholder.kind === 'stream') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected data for path `%s` for label `%s` ' + 'to be data for @stream, was `@%s`.', _pathKey, label, _placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processStreamResponse(label, path, _placeholder, response));\n      }\n    });\n    return relayPayloads;\n  };\n\n  _proto._processDeferResponse = function _processDeferResponse(label, path, placeholder, response) {\n    var _placeholder$actorIde;\n\n    var parentID = placeholder.selector.dataID;\n    var prevActorIdentifier = this._actorIdentifier;\n    this._actorIdentifier = (_placeholder$actorIde = placeholder.actorIdentifier) !== null && _placeholder$actorIde !== void 0 ? _placeholder$actorIde : this._actorIdentifier;\n    var relayPayload = normalizeResponse(response, placeholder.selector, placeholder.typeName, {\n      actorIdentifier: this._actorIdentifier,\n      getDataID: this._getDataID,\n      path: placeholder.path,\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n\n    this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload); // Load the version of the parent record from which this incremental data\n    // was derived\n\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected the parent record `%s` for @defer ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var fieldPayloads = parentEntry.fieldPayloads;\n\n    if (fieldPayloads.length !== 0) {\n      var _response$extensions2;\n\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        followupPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: ((_response$extensions2 = response.extensions) === null || _response$extensions2 === void 0 ? void 0 : _response$extensions2.is_final) === true\n      };\n\n      this._getPublishQueueAndSaveActor().commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    this._actorIdentifier = prevActorIdentifier;\n    return relayPayload;\n  }\n  /**\n   * Process the data for one item in a @stream field.\n   */\n  ;\n\n  _proto._processStreamResponse = function _processStreamResponse(label, path, placeholder, response) {\n    var parentID = placeholder.parentID,\n        node = placeholder.node,\n        variables = placeholder.variables,\n        actorIdentifier = placeholder.actorIdentifier;\n    var prevActorIdentifier = this._actorIdentifier;\n    this._actorIdentifier = actorIdentifier !== null && actorIdentifier !== void 0 ? actorIdentifier : this._actorIdentifier; // Find the LinkedField where @stream was applied\n\n    var field = node.selections[0];\n    !(field != null && field.kind === 'LinkedField' && field.plural === true) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected @stream to be used on a plural field.') : invariant(false) : void 0;\n\n    var _this$_normalizeStrea = this._normalizeStreamItem(response, parentID, field, variables, path, placeholder.path),\n        fieldPayloads = _this$_normalizeStrea.fieldPayloads,\n        itemID = _this$_normalizeStrea.itemID,\n        itemIndex = _this$_normalizeStrea.itemIndex,\n        prevIDs = _this$_normalizeStrea.prevIDs,\n        relayPayload = _this$_normalizeStrea.relayPayload,\n        storageKey = _this$_normalizeStrea.storageKey; // Publish the new item and update the parent record to set\n    // field[index] = item *if* the parent record hasn't been concurrently\n    // modified.\n\n\n    this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload, function (store) {\n      var currentParentRecord = store.get(parentID);\n\n      if (currentParentRecord == null) {\n        // parent has since been deleted, stream data is stale\n        return;\n      }\n\n      var currentItems = currentParentRecord.getLinkedRecords(storageKey);\n\n      if (currentItems == null) {\n        // field has since been deleted, stream data is stale\n        return;\n      }\n\n      if (currentItems.length !== prevIDs.length || currentItems.some(function (currentItem, index) {\n        return prevIDs[index] !== (currentItem && currentItem.getDataID());\n      })) {\n        // field has been modified by something other than this query,\n        // stream data is stale\n        return;\n      } // parent.field has not been concurrently modified:\n      // update `parent.field[index] = item`\n\n\n      var nextItems = (0, _toConsumableArray2[\"default\"])(currentItems);\n      nextItems[itemIndex] = store.get(itemID);\n      currentParentRecord.setLinkedRecords(nextItems, storageKey);\n    }); // Now that the parent record has been updated to include the new item,\n    // also update any handle fields that are derived from the parent record.\n\n\n    if (fieldPayloads.length !== 0) {\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        followupPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: false\n      };\n\n      this._getPublishQueueAndSaveActor().commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    this._actorIdentifier = prevActorIdentifier;\n    return relayPayload;\n  };\n\n  _proto._normalizeStreamItem = function _normalizeStreamItem(response, parentID, field, variables, path, normalizationPath) {\n    var _field$alias, _field$concreteType, _this$_getDataID;\n\n    var data = response.data;\n    !(typeof data === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected the GraphQL @stream payload `data` ' + 'value to be an object.') : invariant(false) : void 0;\n    var responseKey = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, variables); // Load the version of the parent record from which this incremental data\n    // was derived\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected the parent record `%s` for @stream ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var parentRecord = parentEntry.record,\n        fieldPayloads = parentEntry.fieldPayloads; // Load the field value (items) that were created by *this* query executor\n    // in order to check if there has been any concurrent modifications by some\n    // other operation.\n\n    var prevIDs = RelayModernRecord.getLinkedRecordIDs(parentRecord, storageKey);\n    !(prevIDs != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected record `%s` to have fetched field ' + '`%s` with @stream.', parentID, field.name) : invariant(false) : void 0; // Determine the index in the field of the new item\n\n    var finalPathEntry = path[path.length - 1];\n    var itemIndex = parseInt(finalPathEntry, 10);\n    !(itemIndex === finalPathEntry && itemIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected path for @stream to end in a ' + 'positive integer index, got `%s`', finalPathEntry) : invariant(false) : void 0;\n    var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : data[TYPENAME_KEY];\n    !(typeof typeName === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected @stream field `%s` to have a ' + '__typename.', field.name) : invariant(false) : void 0; // Determine the __id of the new item: this must equal the value that would\n    // be assigned had the item not been streamed\n\n    var itemID = // https://github.com/prettier/prettier/issues/6403\n    // prettier-ignore\n    ((_this$_getDataID = this._getDataID(data, typeName)) !== null && _this$_getDataID !== void 0 ? _this$_getDataID : prevIDs && prevIDs[itemIndex]) || // Reuse previously generated client IDs\n    generateClientID(parentID, storageKey, itemIndex);\n    !(typeof itemID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : invariant(false) : void 0; // Build a selector to normalize the item data with\n\n    var selector = createNormalizationSelector(field, itemID, variables); // Update the cached version of the parent record to reflect the new item:\n    // this is used when subsequent stream payloads arrive to see if there\n    // have been concurrent modifications to the list\n\n    var nextParentRecord = RelayModernRecord.clone(parentRecord);\n    var nextIDs = (0, _toConsumableArray2[\"default\"])(prevIDs);\n    nextIDs[itemIndex] = itemID;\n    RelayModernRecord.setLinkedRecordIDs(nextParentRecord, storageKey, nextIDs);\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: fieldPayloads\n    });\n\n    var relayPayload = normalizeResponse(response, selector, typeName, {\n      actorIdentifier: this._actorIdentifier,\n      getDataID: this._getDataID,\n      path: [].concat((0, _toConsumableArray2[\"default\"])(normalizationPath), [responseKey, String(itemIndex)]),\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n    return {\n      fieldPayloads: fieldPayloads,\n      itemID: itemID,\n      itemIndex: itemIndex,\n      prevIDs: prevIDs,\n      relayPayload: relayPayload,\n      storageKey: storageKey\n    };\n  };\n\n  _proto._scheduleAsyncStoreUpdate = function _scheduleAsyncStoreUpdate(scheduleFn, completeFn) {\n    var _this12 = this;\n\n    this._completeFns.push(completeFn);\n\n    if (this._asyncStoreUpdateDisposable != null) {\n      return;\n    }\n\n    this._asyncStoreUpdateDisposable = scheduleFn(function () {\n      _this12._asyncStoreUpdateDisposable = null;\n\n      var updatedOwners = _this12._runPublishQueue();\n\n      _this12._updateOperationTracker(updatedOwners);\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(_this12._completeFns),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var complete = _step2.value;\n          complete();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      _this12._completeFns = [];\n    });\n  };\n\n  _proto._updateOperationTracker = function _updateOperationTracker(updatedOwners) {\n    if (updatedOwners != null && updatedOwners.length > 0) {\n      this._operationTracker.update(this._operation.request, new Set(updatedOwners));\n    }\n  };\n\n  _proto._completeOperationTracker = function _completeOperationTracker() {\n    this._operationTracker.complete(this._operation.request);\n  };\n\n  _proto._getPublishQueueAndSaveActor = function _getPublishQueueAndSaveActor() {\n    this._seenActors.add(this._actorIdentifier);\n\n    return this._getPublishQueue(this._actorIdentifier);\n  };\n\n  _proto._getActorsToVisit = function _getActorsToVisit() {\n    if (this._seenActors.size === 0) {\n      return new Set([this._actorIdentifier]);\n    } else {\n      return this._seenActors;\n    }\n  };\n\n  _proto._runPublishQueue = function _runPublishQueue(operation) {\n    var updatedOwners = new Set();\n\n    var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(this._getActorsToVisit()),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _actorIdentifier = _step3.value;\n\n        var owners = this._getPublishQueue(_actorIdentifier).run(operation);\n\n        owners.forEach(function (owner) {\n          return updatedOwners.add(owner);\n        });\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return Array.from(updatedOwners);\n  };\n\n  _proto._retainData = function _retainData() {\n    var _iterator4 = (0, _createForOfIteratorHelper2[\"default\"])(this._getActorsToVisit()),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _actorIdentifier2 = _step4.value;\n\n        if (!this._retainDisposables.has(_actorIdentifier2)) {\n          this._retainDisposables.set(_actorIdentifier2, this._getStore(_actorIdentifier2).retain(this._operation));\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  };\n\n  _proto._disposeRetainedData = function _disposeRetainedData() {\n    var _iterator5 = (0, _createForOfIteratorHelper2[\"default\"])(this._retainDisposables.values()),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var disposable = _step5.value;\n        disposable.dispose();\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    this._retainDisposables.clear();\n  };\n\n  _proto._expectOperationLoader = function _expectOperationLoader() {\n    var operationLoader = this._operationLoader;\n    !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n    return operationLoader;\n  };\n\n  return Executor;\n}();\n\nfunction partitionGraphQLResponses(responses) {\n  var nonIncrementalResponses = [];\n  var incrementalResponses = [];\n  responses.forEach(function (response) {\n    if (response.path != null || response.label != null) {\n      var label = response.label,\n          path = response.path;\n\n      if (label == null || path == null) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: invalid incremental payload, expected ' + '`path` and `label` to either both be null/undefined, or ' + '`path` to be an `Array<string | number>` and `label` to be a ' + '`string`.') : invariant(false) : void 0;\n      }\n\n      incrementalResponses.push({\n        label: label,\n        path: path,\n        response: response\n      });\n    } else {\n      nonIncrementalResponses.push(response);\n    }\n  });\n  return [nonIncrementalResponses, incrementalResponses];\n}\n\nfunction normalizeResponse(response, selector, typeName, options) {\n  var _response$extensions3;\n\n  var data = response.data,\n      errors = response.errors;\n  var source = RelayRecordSource.create();\n  var record = RelayModernRecord.create(selector.dataID, typeName);\n  source.set(selector.dataID, record);\n  var relayPayload = RelayResponseNormalizer.normalize(source, selector, data, options);\n  return (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, relayPayload), {}, {\n    errors: errors,\n    isFinal: ((_response$extensions3 = response.extensions) === null || _response$extensions3 === void 0 ? void 0 : _response$extensions3.is_final) === true\n  });\n}\n\nfunction stableStringify(value) {\n  var _JSON$stringify;\n\n  return (_JSON$stringify = JSON.stringify(stableCopy(value))) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : ''; // null-check for flow\n}\n\nfunction validateOptimisticResponsePayload(payload) {\n  var incrementalPlaceholders = payload.incrementalPlaceholders;\n\n  if (incrementalPlaceholders != null && incrementalPlaceholders.length !== 0) {\n    !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: optimistic responses cannot be returned ' + 'for operations that use incremental data delivery (@defer, ' + '@stream, and @stream_connection).') : invariant(false) : void 0;\n  }\n}\n\nmodule.exports = {\n  execute: execute\n};","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/store/OperationExecutor.js"],"names":["_interopRequireDefault","require","_objectSpread2","_createForOfIteratorHelper2","_defineProperty2","_toConsumableArray2","RelayObservable","generateID","getOperation","RelayError","RelayFeatureFlags","stableCopy","withDuration","_require","generateClientID","generateUniqueClientID","_require2","getLocalVariables","RelayModernRecord","_require3","createNormalizationSelector","createReaderSelector","RelayRecordSource","RelayResponseNormalizer","_require4","ROOT_TYPE","TYPENAME_KEY","getStorageKey","invariant","warning","execute","config","Executor","_ref","_this","actorIdentifier","getDataID","getPublishQueue","getStore","isClientPayload","operation","operationExecutions","operationLoader","operationTracker","optimisticConfig","_reactFlightPayloadDeserializer","reactFlightPayloadDeserializer","reactFlightServerErrorHandler","scheduler","shouldProcessClientComponents","sink","source","treatMissingFieldsAsNull","updater","log","tree","process","env","NODE_ENV","_withDuration","duration","result","_log","name","executeId","_executeId","operationName","_operation","request","node","params","_actorIdentifier","_getDataID","_treatMissingFieldsAsNull","_incrementalPayloadsPending","_incrementalResults","Map","_nextSubscriptionId","_operationExecutions","_operationLoader","_operationTracker","_operationUpdateEpochs","_optimisticUpdates","_pendingModulePayloadsCount","_getPublishQueue","_scheduler","_sink","_source","_state","_getStore","_subscriptions","_updater","_isClientPayload","_reactFlightServerErrorHandler","_isSubscriptionOperation","operationKind","_shouldProcessClientComponents","_retainDisposables","_seenActors","Set","_completeFns","id","subscribe","complete","_complete","error","_error2","_error","next","response","_next","start","subscription","_this$_operation$requ","_start","variables","cacheConfig","_processOptimisticResponse","data","_proto","prototype","cancel","_this2","identifier","size","forEach","sub","unsubscribe","clear","optimisticUpdates","update","_getPublishQueueAndSaveActor","revertUpdate","_runPublishQueue","_asyncStoreUpdateDisposable","dispose","_completeOperationTracker","_disposeRetainedData","_updateActiveState","activeState","set","_schedule","task","_this3","_id2","create","cancellationToken","schedule","_error3","_id","_this4","_withDuration2","_handleNext","_maybeCompleteSubscriptionOperationTracking","_handleErrorResponse","responses","_this5","results","extensions","hasOwnProperty","errors","messages","map","_ref2","message","join","stack","responseWithData","push","_handleOptimisticResponses","_response$extensions","length","some","responsePart","_responsePart$extensi","isOptimistic","Array","isArray","responsesWithData","isFinal","x","_x$extensions","is_final","_partitionGraphQLResp","partitionGraphQLResponses","nonIncrementalResponses","incrementalResponses","hasNonIncrementalResponses","nextID","fragment","owner","root","payloadFollowups","_processResponses","_processPayloadFollowups","_payloadFollowups","_processIncrementalResponses","__relay_subscription_root_id","dataID","updatedOwners","undefined","_retainData","_updateOperationTracker","_this6","payload","normalizeResponse","path","_deserializeReactFlightPayloadWithLogging","validateOptimisticResponsePayload","_processOptimisticFollowups","fieldPayloads","incrementalPlaceholders","followupPayloads","applyUpdate","_iterator","_step","s","n","done","followupPayload","value","kind","_expectOperationLoader","get","operationReference","_processAsyncOptimisticModuleImport","moduleImportOptimisticUpdates","_processOptimisticModuleImport","apply","err","e","f","_normalizeFollowupPayload","normalizationNode","argumentDefinitions","args","selector","typeName","normalizationRootNode","moduleImportPayload","modulePayload","_this7","load","then","_this$_optimisticUpda","_this8","payloadPart","relayPayload","commitPayload","payloads","_this9","_followupPayload$acto","prevActorIdentifier","_processFollowupPayload","incrementalPlaceholder","_incrementalPlacehold","_processIncrementalPlaceholder","relayPayloads","placeholder","_processDeferResponse","label","_this10","_processFollowupPayloadWithNormalizationNode","_id3","decrementPendingCount","networkObservable","from","Promise","resolve","reject","loadedNode","publishModuleImportPayload","batchAsyncModuleUpdatesFN","BATCH_ASYNC_MODULE_UPDATES_FN","shouldScheduleAsyncStoreUpdate","_withDuration3","_handleFollowupPayload","_scheduleAsyncStoreUpdate","_error4","_relayPayload$fieldPa","pathKey","String","resultForLabel","resultForPath","pendingResponses","parentID","parentRecord","parentPayloads","filter","fieldPayload","fieldID","fieldKey","nextParentRecord","nextParentPayloads","previousParentEntry","record","handlePayloads","dedupePayload","key","stableStringify","values","_this11","incrementalResponse","indexOf","_pathKey","slice","_resultForPath","_placeholder","_processStreamResponse","_placeholder$actorIde","parentEntry","_response$extensions2","handleFieldsRelayPayload","field","selections","plural","_this$_normalizeStrea","_normalizeStreamItem","itemID","itemIndex","prevIDs","storageKey","store","currentParentRecord","currentItems","getLinkedRecords","currentItem","index","nextItems","setLinkedRecords","normalizationPath","_field$alias","_field$concreteType","_this$_getDataID","responseKey","alias","getLinkedRecordIDs","finalPathEntry","parseInt","concreteType","clone","nextIDs","setLinkedRecordIDs","concat","scheduleFn","completeFn","_this12","_iterator2","_step2","add","_getActorsToVisit","_iterator3","_step3","owners","run","_iterator4","_step4","_actorIdentifier2","has","retain","_iterator5","_step5","disposable","options","_response$extensions3","normalize","_JSON$stringify","JSON","stringify","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar RelayObservable = require('../network/RelayObservable');\n\nvar generateID = require('../util/generateID');\n\nvar getOperation = require('../util/getOperation');\n\nvar RelayError = require('../util/RelayError');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar stableCopy = require('../util/stableCopy');\n\nvar withDuration = require('../util/withDuration');\n\nvar _require = require('./ClientID'),\n    generateClientID = _require.generateClientID,\n    generateUniqueClientID = _require.generateUniqueClientID;\n\nvar _require2 = require('./RelayConcreteVariables'),\n    getLocalVariables = _require2.getLocalVariables;\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar _require3 = require('./RelayModernSelector'),\n    createNormalizationSelector = _require3.createNormalizationSelector,\n    createReaderSelector = _require3.createReaderSelector;\n\nvar RelayRecordSource = require('./RelayRecordSource');\n\nvar RelayResponseNormalizer = require('./RelayResponseNormalizer');\n\nvar _require4 = require('./RelayStoreUtils'),\n    ROOT_TYPE = _require4.ROOT_TYPE,\n    TYPENAME_KEY = _require4.TYPENAME_KEY,\n    getStorageKey = _require4.getStorageKey;\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nfunction execute(config) {\n  return new Executor(config);\n}\n/**\n * Coordinates the execution of a query, handling network callbacks\n * including optimistic payloads, standard payloads, resolution of match\n * dependencies, etc.\n */\n\n\nvar Executor = /*#__PURE__*/function () {\n  function Executor(_ref) {\n    var _this = this;\n\n    var actorIdentifier = _ref.actorIdentifier,\n        getDataID = _ref.getDataID,\n        getPublishQueue = _ref.getPublishQueue,\n        getStore = _ref.getStore,\n        isClientPayload = _ref.isClientPayload,\n        operation = _ref.operation,\n        operationExecutions = _ref.operationExecutions,\n        operationLoader = _ref.operationLoader,\n        operationTracker = _ref.operationTracker,\n        optimisticConfig = _ref.optimisticConfig,\n        _reactFlightPayloadDeserializer = _ref.reactFlightPayloadDeserializer,\n        reactFlightServerErrorHandler = _ref.reactFlightServerErrorHandler,\n        scheduler = _ref.scheduler,\n        shouldProcessClientComponents = _ref.shouldProcessClientComponents,\n        sink = _ref.sink,\n        source = _ref.source,\n        treatMissingFieldsAsNull = _ref.treatMissingFieldsAsNull,\n        updater = _ref.updater,\n        log = _ref.log;\n    (0, _defineProperty2[\"default\"])(this, \"_deserializeReactFlightPayloadWithLogging\", function (tree) {\n      var reactFlightPayloadDeserializer = _this._reactFlightPayloadDeserializer;\n      !(typeof reactFlightPayloadDeserializer === 'function') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected reactFlightPayloadDeserializer to be available when calling _deserializeReactFlightPayloadWithLogging.') : invariant(false) : void 0;\n\n      var _withDuration = withDuration(function () {\n        return reactFlightPayloadDeserializer(tree);\n      }),\n          duration = _withDuration[0],\n          result = _withDuration[1];\n\n      _this._log({\n        name: 'execute.flight.payload_deserialize',\n        executeId: _this._executeId,\n        operationName: _this._operation.request.node.params.name,\n        duration: duration\n      });\n\n      return result;\n    });\n    this._actorIdentifier = actorIdentifier;\n    this._getDataID = getDataID;\n    this._treatMissingFieldsAsNull = treatMissingFieldsAsNull;\n    this._incrementalPayloadsPending = false;\n    this._incrementalResults = new Map();\n    this._log = log;\n    this._executeId = generateID();\n    this._nextSubscriptionId = 0;\n    this._operation = operation;\n    this._operationExecutions = operationExecutions;\n    this._operationLoader = operationLoader;\n    this._operationTracker = operationTracker;\n    this._operationUpdateEpochs = new Map();\n    this._optimisticUpdates = null;\n    this._pendingModulePayloadsCount = 0;\n    this._getPublishQueue = getPublishQueue;\n    this._scheduler = scheduler;\n    this._sink = sink;\n    this._source = new Map();\n    this._state = 'started';\n    this._getStore = getStore;\n    this._subscriptions = new Map();\n    this._updater = updater;\n    this._isClientPayload = isClientPayload === true;\n    this._reactFlightPayloadDeserializer = _reactFlightPayloadDeserializer;\n    this._reactFlightServerErrorHandler = reactFlightServerErrorHandler;\n    this._isSubscriptionOperation = this._operation.request.node.params.operationKind === 'subscription';\n    this._shouldProcessClientComponents = shouldProcessClientComponents;\n    this._retainDisposables = new Map();\n    this._seenActors = new Set();\n    this._completeFns = [];\n    var id = this._nextSubscriptionId++;\n    source.subscribe({\n      complete: function complete() {\n        return _this._complete(id);\n      },\n      error: function error(_error2) {\n        return _this._error(_error2);\n      },\n      next: function next(response) {\n        try {\n          _this._next(id, response);\n        } catch (error) {\n          sink.error(error);\n        }\n      },\n      start: function start(subscription) {\n        var _this$_operation$requ;\n\n        _this._start(id, subscription);\n\n        _this._log({\n          name: 'execute.start',\n          executeId: _this._executeId,\n          params: _this._operation.request.node.params,\n          variables: _this._operation.request.variables,\n          cacheConfig: (_this$_operation$requ = _this._operation.request.cacheConfig) !== null && _this$_operation$requ !== void 0 ? _this$_operation$requ : {}\n        });\n      }\n    });\n\n    if (optimisticConfig != null) {\n      this._processOptimisticResponse(optimisticConfig.response != null ? {\n        data: optimisticConfig.response\n      } : null, optimisticConfig.updater, false);\n    }\n  } // Cancel any pending execution tasks and mark the executor as completed.\n\n\n  var _proto = Executor.prototype;\n\n  _proto.cancel = function cancel() {\n    var _this2 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    this._state = 'completed';\n\n    this._operationExecutions[\"delete\"](this._operation.request.identifier);\n\n    if (this._subscriptions.size !== 0) {\n      this._subscriptions.forEach(function (sub) {\n        return sub.unsubscribe();\n      });\n\n      this._subscriptions.clear();\n    }\n\n    var optimisticUpdates = this._optimisticUpdates;\n\n    if (optimisticUpdates !== null) {\n      this._optimisticUpdates = null;\n      optimisticUpdates.forEach(function (update) {\n        return _this2._getPublishQueueAndSaveActor().revertUpdate(update);\n      }); // OK: run revert on cancel\n\n      this._runPublishQueue();\n    }\n\n    this._incrementalResults.clear();\n\n    if (this._asyncStoreUpdateDisposable != null) {\n      this._asyncStoreUpdateDisposable.dispose();\n\n      this._asyncStoreUpdateDisposable = null;\n    }\n\n    this._completeFns = [];\n\n    this._completeOperationTracker();\n\n    this._disposeRetainedData();\n  };\n\n  _proto._updateActiveState = function _updateActiveState() {\n    var activeState;\n\n    switch (this._state) {\n      case 'started':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'loading_incremental':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'completed':\n        {\n          activeState = 'inactive';\n          break;\n        }\n\n      case 'loading_final':\n        {\n          activeState = this._pendingModulePayloadsCount > 0 ? 'active' : 'inactive';\n          break;\n        }\n\n      default:\n        this._state;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: invalid executor state.') : invariant(false) : void 0;\n    }\n\n    this._operationExecutions.set(this._operation.request.identifier, activeState);\n  };\n\n  _proto._schedule = function _schedule(task) {\n    var _this3 = this;\n\n    var scheduler = this._scheduler;\n\n    if (scheduler != null) {\n      var _id2 = this._nextSubscriptionId++;\n\n      RelayObservable.create(function (sink) {\n        var cancellationToken = scheduler.schedule(function () {\n          try {\n            task();\n            sink.complete();\n          } catch (error) {\n            sink.error(error);\n          }\n        });\n        return function () {\n          return scheduler.cancel(cancellationToken);\n        };\n      }).subscribe({\n        complete: function complete() {\n          return _this3._complete(_id2);\n        },\n        error: function error(_error3) {\n          return _this3._error(_error3);\n        },\n        start: function start(subscription) {\n          return _this3._start(_id2, subscription);\n        }\n      });\n    } else {\n      task();\n    }\n  };\n\n  _proto._complete = function _complete(id) {\n    this._subscriptions[\"delete\"](id);\n\n    if (this._subscriptions.size === 0) {\n      this.cancel();\n\n      this._sink.complete();\n\n      this._log({\n        name: 'execute.complete',\n        executeId: this._executeId\n      });\n    }\n  };\n\n  _proto._error = function _error(error) {\n    this.cancel();\n\n    this._sink.error(error);\n\n    this._log({\n      name: 'execute.error',\n      executeId: this._executeId,\n      error: error\n    });\n  };\n\n  _proto._start = function _start(id, subscription) {\n    this._subscriptions.set(id, subscription);\n\n    this._updateActiveState();\n  } // Handle a raw GraphQL response.\n  ;\n\n  _proto._next = function _next(_id, response) {\n    var _this4 = this;\n\n    this._schedule(function () {\n      var _withDuration2 = withDuration(function () {\n        _this4._handleNext(response);\n\n        _this4._maybeCompleteSubscriptionOperationTracking();\n      }),\n          duration = _withDuration2[0];\n\n      _this4._log({\n        name: 'execute.next',\n        executeId: _this4._executeId,\n        response: response,\n        duration: duration\n      });\n    });\n  };\n\n  _proto._handleErrorResponse = function _handleErrorResponse(responses) {\n    var _this5 = this;\n\n    var results = [];\n    responses.forEach(function (response) {\n      if (response.data === null && response.extensions != null && !response.hasOwnProperty('errors')) {\n        // Skip extensions-only payloads\n        return;\n      } else if (response.data == null) {\n        // Error if any other payload in the batch is missing data, regardless of whether\n        // it had `errors` or not.\n        var errors = response.hasOwnProperty('errors') && response.errors != null ? response.errors : null;\n        var messages = errors ? errors.map(function (_ref2) {\n          var message = _ref2.message;\n          return message;\n        }).join('\\n') : '(No errors)';\n        var error = RelayError.create('RelayNetwork', 'No data returned for operation `' + _this5._operation.request.node.params.name + '`, got error(s):\\n' + messages + '\\n\\nSee the error `source` property for more information.');\n        error.source = {\n          errors: errors,\n          operation: _this5._operation.request.node,\n          variables: _this5._operation.request.variables\n        }; // In V8, Error objects keep the closure scope chain alive until the\n        // err.stack property is accessed.\n\n        error.stack;\n        throw error;\n      } else {\n        var responseWithData = response;\n        results.push(responseWithData);\n      }\n    });\n    return results;\n  }\n  /**\n   * This method return boolean to indicate if the optimistic\n   * response has been handled\n   */\n  ;\n\n  _proto._handleOptimisticResponses = function _handleOptimisticResponses(responses) {\n    var _response$extensions;\n\n    if (responses.length > 1) {\n      if (responses.some(function (responsePart) {\n        var _responsePart$extensi;\n\n        return ((_responsePart$extensi = responsePart.extensions) === null || _responsePart$extensi === void 0 ? void 0 : _responsePart$extensi.isOptimistic) === true;\n      })) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Optimistic responses cannot be batched.') : invariant(false) : void 0;\n      }\n\n      return false;\n    }\n\n    var response = responses[0];\n    var isOptimistic = ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.isOptimistic) === true;\n\n    if (isOptimistic && this._state !== 'started') {\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: optimistic payload received after server payload.') : invariant(false) : void 0;\n    }\n\n    if (isOptimistic) {\n      this._processOptimisticResponse(response, null, this._treatMissingFieldsAsNull);\n\n      this._sink.next(response);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto._handleNext = function _handleNext(response) {\n    if (this._state === 'completed') {\n      return;\n    }\n\n    this._seenActors.clear();\n\n    var responses = Array.isArray(response) ? response : [response];\n\n    var responsesWithData = this._handleErrorResponse(responses);\n\n    if (responsesWithData.length === 0) {\n      // no results with data, nothing to process\n      // this can occur with extensions-only payloads\n      var isFinal = responses.some(function (x) {\n        var _x$extensions;\n\n        return ((_x$extensions = x.extensions) === null || _x$extensions === void 0 ? void 0 : _x$extensions.is_final) === true;\n      });\n\n      if (isFinal) {\n        this._state = 'loading_final';\n\n        this._updateActiveState();\n\n        this._incrementalPayloadsPending = false;\n      }\n\n      this._sink.next(response);\n\n      return;\n    } // Next, handle optimistic responses\n\n\n    var isOptimistic = this._handleOptimisticResponses(responsesWithData);\n\n    if (isOptimistic) {\n      return;\n    }\n\n    var _partitionGraphQLResp = partitionGraphQLResponses(responsesWithData),\n        nonIncrementalResponses = _partitionGraphQLResp[0],\n        incrementalResponses = _partitionGraphQLResp[1];\n\n    var hasNonIncrementalResponses = nonIncrementalResponses.length > 0; // In theory this doesn't preserve the ordering of the batch.\n    // The idea is that a batch is always:\n    //  * at most one non-incremental payload\n    //  * followed by zero or more incremental payloads\n    // The non-incremental payload can appear if the server sends a batch\n    // with the initial payload followed by some early-to-resolve incremental\n    // payloads (although, can that even happen?)\n\n    if (hasNonIncrementalResponses) {\n      // For subscriptions, to avoid every new payload from overwriting existing\n      // data from previous payloads, assign a unique rootID for every new\n      // non-incremental payload.\n      if (this._isSubscriptionOperation) {\n        var nextID = generateUniqueClientID();\n        this._operation = {\n          request: this._operation.request,\n          fragment: createReaderSelector(this._operation.fragment.node, nextID, this._operation.fragment.variables, this._operation.fragment.owner),\n          root: createNormalizationSelector(this._operation.root.node, nextID, this._operation.root.variables)\n        };\n      }\n\n      var payloadFollowups = this._processResponses(nonIncrementalResponses);\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n\n    if (incrementalResponses.length > 0) {\n      var _payloadFollowups = this._processIncrementalResponses(incrementalResponses);\n\n      this._processPayloadFollowups(_payloadFollowups);\n    }\n\n    if (this._isSubscriptionOperation) {\n      // We attach the id to allow the `requestSubscription` to read from the store using\n      // the current id in its `onNext` callback\n      if (responsesWithData[0].extensions == null) {\n        // $FlowFixMe[cannot-write]\n        responsesWithData[0].extensions = {\n          __relay_subscription_root_id: this._operation.fragment.dataID\n        };\n      } else {\n        responsesWithData[0].extensions.__relay_subscription_root_id = this._operation.fragment.dataID;\n      }\n    } // OK: run once after each new payload\n    // If we have non-incremental responses, we passing `this._operation` to\n    // the publish queue here, which will later be passed to the store (via\n    // notify) to indicate that this operation caused the store to update\n\n\n    var updatedOwners = this._runPublishQueue(hasNonIncrementalResponses ? this._operation : undefined);\n\n    if (hasNonIncrementalResponses) {\n      if (this._incrementalPayloadsPending) {\n        this._retainData();\n      }\n    }\n\n    this._updateOperationTracker(updatedOwners);\n\n    this._sink.next(response);\n  };\n\n  _proto._processOptimisticResponse = function _processOptimisticResponse(response, updater, treatMissingFieldsAsNull) {\n    var _this6 = this;\n\n    !(this._optimisticUpdates === null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: environment.execute: only support one optimistic response per ' + 'execute.') : invariant(false) : void 0;\n\n    if (response == null && updater == null) {\n      return;\n    }\n\n    var optimisticUpdates = [];\n\n    if (response) {\n      var payload = normalizeResponse(response, this._operation.root, ROOT_TYPE, {\n        actorIdentifier: this._actorIdentifier,\n        getDataID: this._getDataID,\n        path: [],\n        reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n        reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n        shouldProcessClientComponents: this._shouldProcessClientComponents,\n        treatMissingFieldsAsNull: treatMissingFieldsAsNull\n      });\n      validateOptimisticResponsePayload(payload);\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: payload,\n        updater: updater\n      });\n\n      this._processOptimisticFollowups(payload, optimisticUpdates);\n    } else if (updater) {\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: {\n          errors: null,\n          fieldPayloads: null,\n          incrementalPlaceholders: null,\n          followupPayloads: null,\n          source: RelayRecordSource.create(),\n          isFinal: false\n        },\n        updater: updater\n      });\n    }\n\n    this._optimisticUpdates = optimisticUpdates;\n    optimisticUpdates.forEach(function (update) {\n      return _this6._getPublishQueueAndSaveActor().applyUpdate(update);\n    }); // OK: only called on construction and when receiving an optimistic payload from network,\n    // which doesn't fall-through to the regular next() handling\n\n    this._runPublishQueue();\n  };\n\n  _proto._processOptimisticFollowups = function _processOptimisticFollowups(payload, optimisticUpdates) {\n    if (payload.followupPayloads && payload.followupPayloads.length) {\n      var followupPayloads = payload.followupPayloads;\n\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(followupPayloads),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var followupPayload = _step.value;\n\n          switch (followupPayload.kind) {\n            case 'ModuleImportPayload':\n              var operationLoader = this._expectOperationLoader();\n\n              var operation = operationLoader.get(followupPayload.operationReference);\n\n              if (operation == null) {\n                this._processAsyncOptimisticModuleImport(followupPayload);\n              } else {\n                var moduleImportOptimisticUpdates = this._processOptimisticModuleImport(operation, followupPayload);\n\n                optimisticUpdates.push.apply(optimisticUpdates, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisticUpdates));\n              }\n\n              break;\n\n            case 'ActorPayload':\n              process.env.NODE_ENV !== \"production\" ? warning(false, 'OperationExecutor: Unexpected optimistic ActorPayload. These updates are not supported.') : void 0;\n              break;\n\n            default:\n              followupPayload;\n              !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Unexpected followup kind `%s`. when processing optimistic updates.', followupPayload.kind) : invariant(false) : void 0;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n  /**\n   * Normalize Data for @module payload, and actor-specific payload\n   */\n  ;\n\n  _proto._normalizeFollowupPayload = function _normalizeFollowupPayload(followupPayload, normalizationNode) {\n    var variables;\n\n    if (normalizationNode.kind === 'SplitOperation' && followupPayload.kind === 'ModuleImportPayload') {\n      variables = getLocalVariables(followupPayload.variables, normalizationNode.argumentDefinitions, followupPayload.args);\n    } else {\n      variables = followupPayload.variables;\n    }\n\n    var selector = createNormalizationSelector(normalizationNode, followupPayload.dataID, variables);\n    return normalizeResponse({\n      data: followupPayload.data\n    }, selector, followupPayload.typeName, {\n      actorIdentifier: this._actorIdentifier,\n      getDataID: this._getDataID,\n      path: followupPayload.path,\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n  };\n\n  _proto._processOptimisticModuleImport = function _processOptimisticModuleImport(normalizationRootNode, moduleImportPayload) {\n    var operation = getOperation(normalizationRootNode);\n    var optimisticUpdates = [];\n\n    var modulePayload = this._normalizeFollowupPayload(moduleImportPayload, operation);\n\n    validateOptimisticResponsePayload(modulePayload);\n    optimisticUpdates.push({\n      operation: this._operation,\n      payload: modulePayload,\n      updater: null\n    });\n\n    this._processOptimisticFollowups(modulePayload, optimisticUpdates);\n\n    return optimisticUpdates;\n  };\n\n  _proto._processAsyncOptimisticModuleImport = function _processAsyncOptimisticModuleImport(moduleImportPayload) {\n    var _this7 = this;\n\n    this._expectOperationLoader().load(moduleImportPayload.operationReference).then(function (operation) {\n      if (operation == null || _this7._state !== 'started') {\n        return;\n      }\n\n      var moduleImportOptimisticUpdates = _this7._processOptimisticModuleImport(operation, moduleImportPayload);\n\n      moduleImportOptimisticUpdates.forEach(function (update) {\n        return _this7._getPublishQueueAndSaveActor().applyUpdate(update);\n      });\n\n      if (_this7._optimisticUpdates == null) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'OperationExecutor: Unexpected ModuleImport optimistic ' + 'update in operation %s.' + _this7._operation.request.node.params.name) : void 0;\n      } else {\n        var _this$_optimisticUpda;\n\n        (_this$_optimisticUpda = _this7._optimisticUpdates).push.apply(_this$_optimisticUpda, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisticUpdates)); // OK: always have to run() after an module import resolves async\n\n\n        _this7._runPublishQueue();\n      }\n    });\n  };\n\n  _proto._processResponses = function _processResponses(responses) {\n    var _this8 = this;\n\n    if (this._optimisticUpdates !== null) {\n      this._optimisticUpdates.forEach(function (update) {\n        _this8._getPublishQueueAndSaveActor().revertUpdate(update);\n      });\n\n      this._optimisticUpdates = null;\n    }\n\n    this._incrementalPayloadsPending = false;\n\n    this._incrementalResults.clear();\n\n    this._source.clear();\n\n    return responses.map(function (payloadPart) {\n      var relayPayload = normalizeResponse(payloadPart, _this8._operation.root, ROOT_TYPE, {\n        actorIdentifier: _this8._actorIdentifier,\n        getDataID: _this8._getDataID,\n        path: [],\n        reactFlightPayloadDeserializer: _this8._reactFlightPayloadDeserializer != null ? _this8._deserializeReactFlightPayloadWithLogging : null,\n        reactFlightServerErrorHandler: _this8._reactFlightServerErrorHandler,\n        treatMissingFieldsAsNull: _this8._treatMissingFieldsAsNull,\n        shouldProcessClientComponents: _this8._shouldProcessClientComponents\n      });\n\n      _this8._getPublishQueueAndSaveActor().commitPayload(_this8._operation, relayPayload, _this8._updater);\n\n      return relayPayload;\n    });\n  }\n  /**\n   * Handles any follow-up actions for a Relay payload for @match, @defer,\n   * and @stream directives.\n   */\n  ;\n\n  _proto._processPayloadFollowups = function _processPayloadFollowups(payloads) {\n    var _this9 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    payloads.forEach(function (payload) {\n      var incrementalPlaceholders = payload.incrementalPlaceholders,\n          followupPayloads = payload.followupPayloads,\n          isFinal = payload.isFinal;\n      _this9._state = isFinal ? 'loading_final' : 'loading_incremental';\n\n      _this9._updateActiveState();\n\n      if (isFinal) {\n        _this9._incrementalPayloadsPending = false;\n      }\n\n      if (followupPayloads && followupPayloads.length !== 0) {\n        followupPayloads.forEach(function (followupPayload) {\n          var _followupPayload$acto;\n\n          var prevActorIdentifier = _this9._actorIdentifier;\n          _this9._actorIdentifier = (_followupPayload$acto = followupPayload.actorIdentifier) !== null && _followupPayload$acto !== void 0 ? _followupPayload$acto : _this9._actorIdentifier;\n\n          _this9._processFollowupPayload(followupPayload);\n\n          _this9._actorIdentifier = prevActorIdentifier;\n        });\n      }\n\n      if (incrementalPlaceholders && incrementalPlaceholders.length !== 0) {\n        _this9._incrementalPayloadsPending = _this9._state !== 'loading_final';\n        incrementalPlaceholders.forEach(function (incrementalPlaceholder) {\n          var _incrementalPlacehold;\n\n          var prevActorIdentifier = _this9._actorIdentifier;\n          _this9._actorIdentifier = (_incrementalPlacehold = incrementalPlaceholder.actorIdentifier) !== null && _incrementalPlacehold !== void 0 ? _incrementalPlacehold : _this9._actorIdentifier;\n\n          _this9._processIncrementalPlaceholder(payload, incrementalPlaceholder);\n\n          _this9._actorIdentifier = prevActorIdentifier;\n        });\n\n        if (_this9._isClientPayload || _this9._state === 'loading_final') {\n          // The query has defer/stream selections that are enabled, but either\n          // the server indicated that this is a \"final\" payload: no incremental\n          // payloads will be delivered, then warn that the query was (likely)\n          // executed on the server in non-streaming mode, with incremental\n          // delivery disabled; or this is a client payload, and there will be\n          // no incremental payload.\n          process.env.NODE_ENV !== \"production\" ? warning(_this9._isClientPayload, 'RelayModernEnvironment: Operation `%s` contains @defer/@stream ' + 'directives but was executed in non-streaming mode. See ' + 'https://fburl.com/relay-incremental-delivery-non-streaming-warning.', _this9._operation.request.node.params.name) : void 0; // But eagerly process any deferred payloads\n\n          var relayPayloads = [];\n          incrementalPlaceholders.forEach(function (placeholder) {\n            if (placeholder.kind === 'defer') {\n              relayPayloads.push(_this9._processDeferResponse(placeholder.label, placeholder.path, placeholder, {\n                data: placeholder.data\n              }));\n            }\n          });\n\n          if (relayPayloads.length > 0) {\n            _this9._processPayloadFollowups(relayPayloads);\n          }\n        }\n      }\n    });\n  };\n\n  _proto._maybeCompleteSubscriptionOperationTracking = function _maybeCompleteSubscriptionOperationTracking() {\n    if (!this._isSubscriptionOperation) {\n      return;\n    }\n\n    if (this._pendingModulePayloadsCount === 0 && this._incrementalPayloadsPending === false) {\n      this._completeOperationTracker();\n    }\n  }\n  /**\n   * Processes a ModuleImportPayload, asynchronously resolving the normalization\n   * AST and using it to normalize the field data into a RelayResponsePayload.\n   * The resulting payload may contain other incremental payloads (match,\n   * defer, stream, etc); these are handled by calling\n   * `_processPayloadFollowups()`.\n   */\n  ;\n\n  _proto._processFollowupPayload = function _processFollowupPayload(followupPayload) {\n    var _this10 = this;\n\n    switch (followupPayload.kind) {\n      case 'ModuleImportPayload':\n        var operationLoader = this._expectOperationLoader();\n\n        var node = operationLoader.get(followupPayload.operationReference);\n\n        if (node != null) {\n          // If the operation module is available synchronously, normalize the\n          // data synchronously.\n          this._processFollowupPayloadWithNormalizationNode(followupPayload, getOperation(node));\n        } else {\n          // Otherwise load the operation module and schedule a task to normalize\n          // the data when the module is available.\n          var _id3 = this._nextSubscriptionId++;\n\n          this._pendingModulePayloadsCount++;\n\n          var decrementPendingCount = function decrementPendingCount() {\n            _this10._pendingModulePayloadsCount--;\n\n            _this10._maybeCompleteSubscriptionOperationTracking();\n          }; // Observable.from(operationLoader.load()) wouldn't catch synchronous\n          // errors thrown by the load function, which is user-defined. Guard\n          // against that with Observable.from(new Promise(<work>)).\n\n\n          var networkObservable = RelayObservable.from(new Promise(function (resolve, reject) {\n            operationLoader.load(followupPayload.operationReference).then(resolve, reject);\n          }));\n          RelayObservable.create(function (sink) {\n            var cancellationToken;\n            var subscription = networkObservable.subscribe({\n              next: function next(loadedNode) {\n                if (loadedNode != null) {\n                  var publishModuleImportPayload = function publishModuleImportPayload() {\n                    try {\n                      var operation = getOperation(loadedNode);\n                      var batchAsyncModuleUpdatesFN = RelayFeatureFlags.BATCH_ASYNC_MODULE_UPDATES_FN;\n                      var shouldScheduleAsyncStoreUpdate = batchAsyncModuleUpdatesFN != null && _this10._pendingModulePayloadsCount > 1;\n\n                      var _withDuration3 = withDuration(function () {\n                        _this10._handleFollowupPayload(followupPayload, operation); // OK: always have to run after an async module import resolves\n\n\n                        // OK: always have to run after an async module import resolves\n                        if (shouldScheduleAsyncStoreUpdate) {\n                          _this10._scheduleAsyncStoreUpdate( // $FlowFixMe[incompatible-call] `shouldScheduleAsyncStoreUpdate` check should cover `null` case\n                          batchAsyncModuleUpdatesFN, sink.complete);\n                        } else {\n                          var updatedOwners = _this10._runPublishQueue();\n\n                          _this10._updateOperationTracker(updatedOwners);\n                        }\n                      }),\n                          duration = _withDuration3[0];\n\n                      _this10._log({\n                        name: 'execute.async.module',\n                        executeId: _this10._executeId,\n                        operationName: operation.name,\n                        duration: duration\n                      });\n\n                      if (!shouldScheduleAsyncStoreUpdate) {\n                        sink.complete();\n                      }\n                    } catch (error) {\n                      sink.error(error);\n                    }\n                  };\n\n                  var scheduler = _this10._scheduler;\n\n                  if (scheduler == null) {\n                    publishModuleImportPayload();\n                  } else {\n                    cancellationToken = scheduler.schedule(publishModuleImportPayload);\n                  }\n                } else {\n                  sink.complete();\n                }\n              },\n              error: sink.error\n            });\n            return function () {\n              subscription.unsubscribe();\n\n              if (_this10._scheduler != null && cancellationToken != null) {\n                _this10._scheduler.cancel(cancellationToken);\n              }\n            };\n          }).subscribe({\n            complete: function complete() {\n              _this10._complete(_id3);\n\n              decrementPendingCount();\n            },\n            error: function error(_error4) {\n              _this10._error(_error4);\n\n              decrementPendingCount();\n            },\n            start: function start(subscription) {\n              return _this10._start(_id3, subscription);\n            }\n          });\n        }\n\n        break;\n\n      case 'ActorPayload':\n        this._processFollowupPayloadWithNormalizationNode(followupPayload, followupPayload.node);\n\n        break;\n\n      default:\n        followupPayload;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Unexpected followup kind `%s`.', followupPayload.kind) : invariant(false) : void 0;\n    }\n  };\n\n  _proto._processFollowupPayloadWithNormalizationNode = function _processFollowupPayloadWithNormalizationNode(followupPayload, normalizationNode) {\n    this._handleFollowupPayload(followupPayload, normalizationNode);\n\n    this._maybeCompleteSubscriptionOperationTracking();\n  };\n\n  _proto._handleFollowupPayload = function _handleFollowupPayload(followupPayload, normalizationNode) {\n    var relayPayload = this._normalizeFollowupPayload(followupPayload, normalizationNode);\n\n    this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload);\n\n    this._processPayloadFollowups([relayPayload]);\n  }\n  /**\n   * The executor now knows that GraphQL responses are expected for a given\n   * label/path:\n   * - Store the placeholder in order to process any future responses that may\n   *   arrive.\n   * - Then process any responses that had already arrived.\n   *\n   * The placeholder contains the normalization selector, path (for nested\n   * defer/stream), and other metadata used to normalize the incremental\n   * response(s).\n   */\n  ;\n\n  _proto._processIncrementalPlaceholder = function _processIncrementalPlaceholder(relayPayload, placeholder) {\n    var _relayPayload$fieldPa;\n\n    // Update the label => path => placeholder map\n    var label = placeholder.label,\n        path = placeholder.path;\n    var pathKey = path.map(String).join('.');\n\n    var resultForLabel = this._incrementalResults.get(label);\n\n    if (resultForLabel == null) {\n      resultForLabel = new Map();\n\n      this._incrementalResults.set(label, resultForLabel);\n    }\n\n    var resultForPath = resultForLabel.get(pathKey);\n    var pendingResponses = resultForPath != null && resultForPath.kind === 'response' ? resultForPath.responses : null;\n    resultForLabel.set(pathKey, {\n      kind: 'placeholder',\n      placeholder: placeholder\n    }); // Store references to the parent node to allow detecting concurrent\n    // modifications to the parent before items arrive and to replay\n    // handle field payloads to account for new information on source records.\n\n    var parentID;\n\n    if (placeholder.kind === 'stream') {\n      parentID = placeholder.parentID;\n    } else if (placeholder.kind === 'defer') {\n      parentID = placeholder.selector.dataID;\n    } else {\n      placeholder;\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Unsupported incremental placeholder kind `%s`.', placeholder.kind) : invariant(false) : void 0;\n    }\n\n    var parentRecord = relayPayload.source.get(parentID);\n    var parentPayloads = ((_relayPayload$fieldPa = relayPayload.fieldPayloads) !== null && _relayPayload$fieldPa !== void 0 ? _relayPayload$fieldPa : []).filter(function (fieldPayload) {\n      var fieldID = generateClientID(fieldPayload.dataID, fieldPayload.fieldKey);\n      return (// handlers applied to the streamed field itself\n        fieldPayload.dataID === parentID || // handlers applied to a field on an ancestor object, where\n        // ancestor.field links to the parent record (example: connections)\n        fieldID === parentID\n      );\n    }); // If an incremental payload exists for some id that record should also\n    // exist.\n\n    !(parentRecord != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected record `%s` to exist.', parentID) : invariant(false) : void 0;\n    var nextParentRecord;\n    var nextParentPayloads;\n\n    var previousParentEntry = this._source.get(parentID);\n\n    if (previousParentEntry != null) {\n      // If a previous entry exists, merge the previous/next records and\n      // payloads together.\n      nextParentRecord = RelayModernRecord.update(previousParentEntry.record, parentRecord);\n      var handlePayloads = new Map();\n\n      var dedupePayload = function dedupePayload(payload) {\n        var key = stableStringify(payload);\n        handlePayloads.set(key, payload);\n      };\n\n      previousParentEntry.fieldPayloads.forEach(dedupePayload);\n      parentPayloads.forEach(dedupePayload);\n      nextParentPayloads = Array.from(handlePayloads.values());\n    } else {\n      nextParentRecord = parentRecord;\n      nextParentPayloads = parentPayloads;\n    }\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: nextParentPayloads\n    }); // If there were any queued responses, process them now that placeholders\n    // are in place\n\n\n    if (pendingResponses != null) {\n      var payloadFollowups = this._processIncrementalResponses(pendingResponses);\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n  }\n  /**\n   * Lookup the placeholder the describes how to process an incremental\n   * response, normalize/publish it, and process any nested defer/match/stream\n   * metadata.\n   */\n  ;\n\n  _proto._processIncrementalResponses = function _processIncrementalResponses(incrementalResponses) {\n    var _this11 = this;\n\n    var relayPayloads = [];\n    incrementalResponses.forEach(function (incrementalResponse) {\n      var label = incrementalResponse.label,\n          path = incrementalResponse.path,\n          response = incrementalResponse.response;\n\n      var resultForLabel = _this11._incrementalResults.get(label);\n\n      if (resultForLabel == null) {\n        resultForLabel = new Map();\n\n        _this11._incrementalResults.set(label, resultForLabel);\n      }\n\n      if (label.indexOf('$defer$') !== -1) {\n        var pathKey = path.map(String).join('.');\n        var resultForPath = resultForLabel.get(pathKey);\n\n        if (resultForPath == null) {\n          resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(pathKey, resultForPath);\n          return;\n        } else if (resultForPath.kind === 'response') {\n          resultForPath.responses.push(incrementalResponse);\n          return;\n        }\n\n        var placeholder = resultForPath.placeholder;\n        !(placeholder.kind === 'defer') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected data for path `%s` for label `%s` ' + 'to be data for @defer, was `@%s`.', pathKey, label, placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processDeferResponse(label, path, placeholder, response));\n      } else {\n        // @stream payload path values end in the field name and item index,\n        // but Relay records paths relative to the parent of the stream node:\n        // therefore we strip the last two elements just to lookup the path\n        // (the item index is used later to insert the element in the list)\n        var _pathKey = path.slice(0, -2).map(String).join('.');\n\n        var _resultForPath = resultForLabel.get(_pathKey);\n\n        if (_resultForPath == null) {\n          _resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(_pathKey, _resultForPath);\n          return;\n        } else if (_resultForPath.kind === 'response') {\n          _resultForPath.responses.push(incrementalResponse);\n\n          return;\n        }\n\n        var _placeholder = _resultForPath.placeholder;\n        !(_placeholder.kind === 'stream') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected data for path `%s` for label `%s` ' + 'to be data for @stream, was `@%s`.', _pathKey, label, _placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processStreamResponse(label, path, _placeholder, response));\n      }\n    });\n    return relayPayloads;\n  };\n\n  _proto._processDeferResponse = function _processDeferResponse(label, path, placeholder, response) {\n    var _placeholder$actorIde;\n\n    var parentID = placeholder.selector.dataID;\n    var prevActorIdentifier = this._actorIdentifier;\n    this._actorIdentifier = (_placeholder$actorIde = placeholder.actorIdentifier) !== null && _placeholder$actorIde !== void 0 ? _placeholder$actorIde : this._actorIdentifier;\n    var relayPayload = normalizeResponse(response, placeholder.selector, placeholder.typeName, {\n      actorIdentifier: this._actorIdentifier,\n      getDataID: this._getDataID,\n      path: placeholder.path,\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n\n    this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload); // Load the version of the parent record from which this incremental data\n    // was derived\n\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected the parent record `%s` for @defer ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var fieldPayloads = parentEntry.fieldPayloads;\n\n    if (fieldPayloads.length !== 0) {\n      var _response$extensions2;\n\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        followupPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: ((_response$extensions2 = response.extensions) === null || _response$extensions2 === void 0 ? void 0 : _response$extensions2.is_final) === true\n      };\n\n      this._getPublishQueueAndSaveActor().commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    this._actorIdentifier = prevActorIdentifier;\n    return relayPayload;\n  }\n  /**\n   * Process the data for one item in a @stream field.\n   */\n  ;\n\n  _proto._processStreamResponse = function _processStreamResponse(label, path, placeholder, response) {\n    var parentID = placeholder.parentID,\n        node = placeholder.node,\n        variables = placeholder.variables,\n        actorIdentifier = placeholder.actorIdentifier;\n    var prevActorIdentifier = this._actorIdentifier;\n    this._actorIdentifier = actorIdentifier !== null && actorIdentifier !== void 0 ? actorIdentifier : this._actorIdentifier; // Find the LinkedField where @stream was applied\n\n    var field = node.selections[0];\n    !(field != null && field.kind === 'LinkedField' && field.plural === true) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected @stream to be used on a plural field.') : invariant(false) : void 0;\n\n    var _this$_normalizeStrea = this._normalizeStreamItem(response, parentID, field, variables, path, placeholder.path),\n        fieldPayloads = _this$_normalizeStrea.fieldPayloads,\n        itemID = _this$_normalizeStrea.itemID,\n        itemIndex = _this$_normalizeStrea.itemIndex,\n        prevIDs = _this$_normalizeStrea.prevIDs,\n        relayPayload = _this$_normalizeStrea.relayPayload,\n        storageKey = _this$_normalizeStrea.storageKey; // Publish the new item and update the parent record to set\n    // field[index] = item *if* the parent record hasn't been concurrently\n    // modified.\n\n\n    this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload, function (store) {\n      var currentParentRecord = store.get(parentID);\n\n      if (currentParentRecord == null) {\n        // parent has since been deleted, stream data is stale\n        return;\n      }\n\n      var currentItems = currentParentRecord.getLinkedRecords(storageKey);\n\n      if (currentItems == null) {\n        // field has since been deleted, stream data is stale\n        return;\n      }\n\n      if (currentItems.length !== prevIDs.length || currentItems.some(function (currentItem, index) {\n        return prevIDs[index] !== (currentItem && currentItem.getDataID());\n      })) {\n        // field has been modified by something other than this query,\n        // stream data is stale\n        return;\n      } // parent.field has not been concurrently modified:\n      // update `parent.field[index] = item`\n\n\n      var nextItems = (0, _toConsumableArray2[\"default\"])(currentItems);\n      nextItems[itemIndex] = store.get(itemID);\n      currentParentRecord.setLinkedRecords(nextItems, storageKey);\n    }); // Now that the parent record has been updated to include the new item,\n    // also update any handle fields that are derived from the parent record.\n\n\n    if (fieldPayloads.length !== 0) {\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        followupPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: false\n      };\n\n      this._getPublishQueueAndSaveActor().commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    this._actorIdentifier = prevActorIdentifier;\n    return relayPayload;\n  };\n\n  _proto._normalizeStreamItem = function _normalizeStreamItem(response, parentID, field, variables, path, normalizationPath) {\n    var _field$alias, _field$concreteType, _this$_getDataID;\n\n    var data = response.data;\n    !(typeof data === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected the GraphQL @stream payload `data` ' + 'value to be an object.') : invariant(false) : void 0;\n    var responseKey = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, variables); // Load the version of the parent record from which this incremental data\n    // was derived\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected the parent record `%s` for @stream ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var parentRecord = parentEntry.record,\n        fieldPayloads = parentEntry.fieldPayloads; // Load the field value (items) that were created by *this* query executor\n    // in order to check if there has been any concurrent modifications by some\n    // other operation.\n\n    var prevIDs = RelayModernRecord.getLinkedRecordIDs(parentRecord, storageKey);\n    !(prevIDs != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected record `%s` to have fetched field ' + '`%s` with @stream.', parentID, field.name) : invariant(false) : void 0; // Determine the index in the field of the new item\n\n    var finalPathEntry = path[path.length - 1];\n    var itemIndex = parseInt(finalPathEntry, 10);\n    !(itemIndex === finalPathEntry && itemIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected path for @stream to end in a ' + 'positive integer index, got `%s`', finalPathEntry) : invariant(false) : void 0;\n    var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : data[TYPENAME_KEY];\n    !(typeof typeName === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected @stream field `%s` to have a ' + '__typename.', field.name) : invariant(false) : void 0; // Determine the __id of the new item: this must equal the value that would\n    // be assigned had the item not been streamed\n\n    var itemID = // https://github.com/prettier/prettier/issues/6403\n    // prettier-ignore\n    ((_this$_getDataID = this._getDataID(data, typeName)) !== null && _this$_getDataID !== void 0 ? _this$_getDataID : prevIDs && prevIDs[itemIndex]) || // Reuse previously generated client IDs\n    generateClientID(parentID, storageKey, itemIndex);\n    !(typeof itemID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : invariant(false) : void 0; // Build a selector to normalize the item data with\n\n    var selector = createNormalizationSelector(field, itemID, variables); // Update the cached version of the parent record to reflect the new item:\n    // this is used when subsequent stream payloads arrive to see if there\n    // have been concurrent modifications to the list\n\n    var nextParentRecord = RelayModernRecord.clone(parentRecord);\n    var nextIDs = (0, _toConsumableArray2[\"default\"])(prevIDs);\n    nextIDs[itemIndex] = itemID;\n    RelayModernRecord.setLinkedRecordIDs(nextParentRecord, storageKey, nextIDs);\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: fieldPayloads\n    });\n\n    var relayPayload = normalizeResponse(response, selector, typeName, {\n      actorIdentifier: this._actorIdentifier,\n      getDataID: this._getDataID,\n      path: [].concat((0, _toConsumableArray2[\"default\"])(normalizationPath), [responseKey, String(itemIndex)]),\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer != null ? this._deserializeReactFlightPayloadWithLogging : null,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n    return {\n      fieldPayloads: fieldPayloads,\n      itemID: itemID,\n      itemIndex: itemIndex,\n      prevIDs: prevIDs,\n      relayPayload: relayPayload,\n      storageKey: storageKey\n    };\n  };\n\n  _proto._scheduleAsyncStoreUpdate = function _scheduleAsyncStoreUpdate(scheduleFn, completeFn) {\n    var _this12 = this;\n\n    this._completeFns.push(completeFn);\n\n    if (this._asyncStoreUpdateDisposable != null) {\n      return;\n    }\n\n    this._asyncStoreUpdateDisposable = scheduleFn(function () {\n      _this12._asyncStoreUpdateDisposable = null;\n\n      var updatedOwners = _this12._runPublishQueue();\n\n      _this12._updateOperationTracker(updatedOwners);\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(_this12._completeFns),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var complete = _step2.value;\n          complete();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      _this12._completeFns = [];\n    });\n  };\n\n  _proto._updateOperationTracker = function _updateOperationTracker(updatedOwners) {\n    if (updatedOwners != null && updatedOwners.length > 0) {\n      this._operationTracker.update(this._operation.request, new Set(updatedOwners));\n    }\n  };\n\n  _proto._completeOperationTracker = function _completeOperationTracker() {\n    this._operationTracker.complete(this._operation.request);\n  };\n\n  _proto._getPublishQueueAndSaveActor = function _getPublishQueueAndSaveActor() {\n    this._seenActors.add(this._actorIdentifier);\n\n    return this._getPublishQueue(this._actorIdentifier);\n  };\n\n  _proto._getActorsToVisit = function _getActorsToVisit() {\n    if (this._seenActors.size === 0) {\n      return new Set([this._actorIdentifier]);\n    } else {\n      return this._seenActors;\n    }\n  };\n\n  _proto._runPublishQueue = function _runPublishQueue(operation) {\n    var updatedOwners = new Set();\n\n    var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(this._getActorsToVisit()),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _actorIdentifier = _step3.value;\n\n        var owners = this._getPublishQueue(_actorIdentifier).run(operation);\n\n        owners.forEach(function (owner) {\n          return updatedOwners.add(owner);\n        });\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return Array.from(updatedOwners);\n  };\n\n  _proto._retainData = function _retainData() {\n    var _iterator4 = (0, _createForOfIteratorHelper2[\"default\"])(this._getActorsToVisit()),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _actorIdentifier2 = _step4.value;\n\n        if (!this._retainDisposables.has(_actorIdentifier2)) {\n          this._retainDisposables.set(_actorIdentifier2, this._getStore(_actorIdentifier2).retain(this._operation));\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  };\n\n  _proto._disposeRetainedData = function _disposeRetainedData() {\n    var _iterator5 = (0, _createForOfIteratorHelper2[\"default\"])(this._retainDisposables.values()),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var disposable = _step5.value;\n        disposable.dispose();\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    this._retainDisposables.clear();\n  };\n\n  _proto._expectOperationLoader = function _expectOperationLoader() {\n    var operationLoader = this._operationLoader;\n    !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n    return operationLoader;\n  };\n\n  return Executor;\n}();\n\nfunction partitionGraphQLResponses(responses) {\n  var nonIncrementalResponses = [];\n  var incrementalResponses = [];\n  responses.forEach(function (response) {\n    if (response.path != null || response.label != null) {\n      var label = response.label,\n          path = response.path;\n\n      if (label == null || path == null) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: invalid incremental payload, expected ' + '`path` and `label` to either both be null/undefined, or ' + '`path` to be an `Array<string | number>` and `label` to be a ' + '`string`.') : invariant(false) : void 0;\n      }\n\n      incrementalResponses.push({\n        label: label,\n        path: path,\n        response: response\n      });\n    } else {\n      nonIncrementalResponses.push(response);\n    }\n  });\n  return [nonIncrementalResponses, incrementalResponses];\n}\n\nfunction normalizeResponse(response, selector, typeName, options) {\n  var _response$extensions3;\n\n  var data = response.data,\n      errors = response.errors;\n  var source = RelayRecordSource.create();\n  var record = RelayModernRecord.create(selector.dataID, typeName);\n  source.set(selector.dataID, record);\n  var relayPayload = RelayResponseNormalizer.normalize(source, selector, data, options);\n  return (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, relayPayload), {}, {\n    errors: errors,\n    isFinal: ((_response$extensions3 = response.extensions) === null || _response$extensions3 === void 0 ? void 0 : _response$extensions3.is_final) === true\n  });\n}\n\nfunction stableStringify(value) {\n  var _JSON$stringify;\n\n  return (_JSON$stringify = JSON.stringify(stableCopy(value))) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : ''; // null-check for flow\n}\n\nfunction validateOptimisticResponsePayload(payload) {\n  var incrementalPlaceholders = payload.incrementalPlaceholders;\n\n  if (incrementalPlaceholders != null && incrementalPlaceholders.length !== 0) {\n    !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: optimistic responses cannot be returned ' + 'for operations that use incremental data delivery (@defer, ' + '@stream, and @stream_connection).') : invariant(false) : void 0;\n  }\n}\n\nmodule.exports = {\n  execute: execute\n};"]},"metadata":{},"sourceType":"script"}