{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar RelayObservable = require('../network/RelayObservable');\n\nvar _require = require('../store/RelayModernOperationDescriptor'),\n    createOperationDescriptor = _require.createOperationDescriptor;\n\nvar reportMissingRequiredFields = require('../util/reportMissingRequiredFields');\n\nvar fetchQueryInternal = require('./fetchQueryInternal');\n\nvar _require2 = require('./GraphQLTag'),\n    getRequest = _require2.getRequest;\n\nvar invariant = require('invariant');\n/**\n * Fetches the given query and variables on the provided environment,\n * and de-dupes identical in-flight requests.\n *\n * Observing a request:\n * ====================\n * fetchQuery returns an Observable which you can call .subscribe()\n * on. Subscribe optionally takes an Observer, which you can provide to\n * observe network events:\n *\n * ```\n * fetchQuery(environment, query, variables).subscribe({\n *   // Called when network requests starts\n *   start: (subsctiption) => {},\n *\n *   // Called after a payload is received and written to the local store\n *   next: (payload) => {},\n *\n *   // Called when network requests errors\n *   error: (error) => {},\n *\n *   // Called when network requests fully completes\n *   complete: () => {},\n *\n *   // Called when network request is unsubscribed\n *   unsubscribe: (subscription) => {},\n * });\n * ```\n *\n * Request Promise:\n * ================\n * The obervable can be converted to a Promise with .toPromise(), which will\n * resolve to a snapshot of the query data when the first response is received\n * from the server.\n *\n * ```\n * fetchQuery(environment, query, variables).toPromise().then((data) => {\n *   // ...\n * });\n * ```\n *\n * In-flight request de-duping:\n * ============================\n * By default, calling fetchQuery multiple times with the same\n * environment, query and variables will not initiate a new request if a request\n * for those same parameters is already in flight.\n *\n * A request is marked in-flight from the moment it starts until the moment it\n * fully completes, regardless of error or successful completion.\n *\n * NOTE: If the request completes _synchronously_, calling fetchQuery\n * a second time with the same arguments in the same tick will _NOT_ de-dupe\n * the request given that it will no longer be in-flight.\n *\n *\n * Data Retention:\n * ===============\n * This function will NOT retain query data, meaning that it is not guaranteed\n * that the fetched data will remain in the Relay store after the request has\n * completed.\n * If you need to retain the query data outside of the network request,\n * you need to use `environment.retain()`.\n *\n *\n * Cancelling requests:\n * ====================\n * If the disposable returned by subscribe is called while the\n * request is in-flight, the request will be cancelled.\n *\n * ```\n * const disposable = fetchQuery(...).subscribe(...);\n *\n * // This will cancel the request if it is in-flight.\n * disposable.dispose();\n * ```\n * NOTE: When using .toPromise(), the request cannot be cancelled.\n */\n\n\nfunction fetchQuery(environment, query, variables, options) {\n  var _options$fetchPolicy;\n\n  var queryNode = getRequest(query);\n  !(queryNode.params.operationKind === 'query') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'fetchQuery: Expected query operation') : invariant(false) : void 0;\n  var networkCacheConfig = (0, _objectSpread2[\"default\"])({\n    force: true\n  }, options === null || options === void 0 ? void 0 : options.networkCacheConfig);\n  var operation = createOperationDescriptor(queryNode, variables, networkCacheConfig);\n  var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : 'network-only';\n\n  function readData(snapshot) {\n    if (snapshot.missingRequiredFields != null) {\n      reportMissingRequiredFields(environment, snapshot.missingRequiredFields);\n    }\n    /* $FlowFixMe[incompatible-return] we assume readData returns the right\n     * data just having written it from network or checked availability. */\n\n\n    return snapshot.data;\n  }\n\n  switch (fetchPolicy) {\n    case 'network-only':\n      {\n        return getNetworkObservable(environment, operation).map(readData);\n      }\n\n    case 'store-or-network':\n      {\n        if (environment.check(operation).status === 'available') {\n          return RelayObservable.from(environment.lookup(operation.fragment)).map(readData);\n        }\n\n        return getNetworkObservable(environment, operation).map(readData);\n      }\n\n    default:\n      fetchPolicy;\n      throw new Error('fetchQuery: Invalid fetchPolicy ' + fetchPolicy);\n  }\n}\n\nfunction getNetworkObservable(environment, operation) {\n  return fetchQueryInternal.fetchQuery(environment, operation).map(function () {\n    return environment.lookup(operation.fragment);\n  });\n}\n\nmodule.exports = fetchQuery;","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/query/fetchQuery.js"],"names":["_interopRequireDefault","require","_objectSpread2","RelayObservable","_require","createOperationDescriptor","reportMissingRequiredFields","fetchQueryInternal","_require2","getRequest","invariant","fetchQuery","environment","query","variables","options","_options$fetchPolicy","queryNode","params","operationKind","process","env","NODE_ENV","networkCacheConfig","force","operation","fetchPolicy","readData","snapshot","missingRequiredFields","data","getNetworkObservable","map","check","status","from","lookup","fragment","Error","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEA,IAAIC,cAAc,GAAGF,sBAAsB,CAACC,OAAO,CAAC,sCAAD,CAAR,CAA3C;;AAEA,IAAIE,eAAe,GAAGF,OAAO,CAAC,4BAAD,CAA7B;;AAEA,IAAIG,QAAQ,GAAGH,OAAO,CAAC,yCAAD,CAAtB;AAAA,IACII,yBAAyB,GAAGD,QAAQ,CAACC,yBADzC;;AAGA,IAAIC,2BAA2B,GAAGL,OAAO,CAAC,qCAAD,CAAzC;;AAEA,IAAIM,kBAAkB,GAAGN,OAAO,CAAC,sBAAD,CAAhC;;AAEA,IAAIO,SAAS,GAAGP,OAAO,CAAC,cAAD,CAAvB;AAAA,IACIQ,UAAU,GAAGD,SAAS,CAACC,UAD3B;;AAGA,IAAIC,SAAS,GAAGT,OAAO,CAAC,WAAD,CAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASU,UAAT,CAAoBC,WAApB,EAAiCC,KAAjC,EAAwCC,SAAxC,EAAmDC,OAAnD,EAA4D;AAC1D,MAAIC,oBAAJ;;AAEA,MAAIC,SAAS,GAAGR,UAAU,CAACI,KAAD,CAA1B;AACA,IAAEI,SAAS,CAACC,MAAV,CAAiBC,aAAjB,KAAmC,OAArC,IAAgDC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCZ,SAAS,CAAC,KAAD,EAAQ,sCAAR,CAAjD,GAAmGA,SAAS,CAAC,KAAD,CAA5J,GAAsK,KAAK,CAA3K;AACA,MAAIa,kBAAkB,GAAG,CAAC,GAAGrB,cAAc,CAAC,SAAD,CAAlB,EAA+B;AACtDsB,IAAAA,KAAK,EAAE;AAD+C,GAA/B,EAEtBT,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACQ,kBAFpC,CAAzB;AAGA,MAAIE,SAAS,GAAGpB,yBAAyB,CAACY,SAAD,EAAYH,SAAZ,EAAuBS,kBAAvB,CAAzC;AACA,MAAIG,WAAW,GAAG,CAACV,oBAAoB,GAAGD,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACW,WAAlF,MAAmG,IAAnG,IAA2GV,oBAAoB,KAAK,KAAK,CAAzI,GAA6IA,oBAA7I,GAAoK,cAAtL;;AAEA,WAASW,QAAT,CAAkBC,QAAlB,EAA4B;AAC1B,QAAIA,QAAQ,CAACC,qBAAT,IAAkC,IAAtC,EAA4C;AAC1CvB,MAAAA,2BAA2B,CAACM,WAAD,EAAcgB,QAAQ,CAACC,qBAAvB,CAA3B;AACD;AACD;AACJ;;;AAGI,WAAOD,QAAQ,CAACE,IAAhB;AACD;;AAED,UAAQJ,WAAR;AACE,SAAK,cAAL;AACE;AACE,eAAOK,oBAAoB,CAACnB,WAAD,EAAca,SAAd,CAApB,CAA6CO,GAA7C,CAAiDL,QAAjD,CAAP;AACD;;AAEH,SAAK,kBAAL;AACE;AACE,YAAIf,WAAW,CAACqB,KAAZ,CAAkBR,SAAlB,EAA6BS,MAA7B,KAAwC,WAA5C,EAAyD;AACvD,iBAAO/B,eAAe,CAACgC,IAAhB,CAAqBvB,WAAW,CAACwB,MAAZ,CAAmBX,SAAS,CAACY,QAA7B,CAArB,EAA6DL,GAA7D,CAAiEL,QAAjE,CAAP;AACD;;AAED,eAAOI,oBAAoB,CAACnB,WAAD,EAAca,SAAd,CAApB,CAA6CO,GAA7C,CAAiDL,QAAjD,CAAP;AACD;;AAEH;AACED,MAAAA,WAAW;AACX,YAAM,IAAIY,KAAJ,CAAU,qCAAqCZ,WAA/C,CAAN;AAjBJ;AAmBD;;AAED,SAASK,oBAAT,CAA8BnB,WAA9B,EAA2Ca,SAA3C,EAAsD;AACpD,SAAOlB,kBAAkB,CAACI,UAAnB,CAA8BC,WAA9B,EAA2Ca,SAA3C,EAAsDO,GAAtD,CAA0D,YAAY;AAC3E,WAAOpB,WAAW,CAACwB,MAAZ,CAAmBX,SAAS,CAACY,QAA7B,CAAP;AACD,GAFM,CAAP;AAGD;;AAEDE,MAAM,CAACC,OAAP,GAAiB7B,UAAjB","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+relay\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar RelayObservable = require('../network/RelayObservable');\n\nvar _require = require('../store/RelayModernOperationDescriptor'),\n    createOperationDescriptor = _require.createOperationDescriptor;\n\nvar reportMissingRequiredFields = require('../util/reportMissingRequiredFields');\n\nvar fetchQueryInternal = require('./fetchQueryInternal');\n\nvar _require2 = require('./GraphQLTag'),\n    getRequest = _require2.getRequest;\n\nvar invariant = require('invariant');\n/**\n * Fetches the given query and variables on the provided environment,\n * and de-dupes identical in-flight requests.\n *\n * Observing a request:\n * ====================\n * fetchQuery returns an Observable which you can call .subscribe()\n * on. Subscribe optionally takes an Observer, which you can provide to\n * observe network events:\n *\n * ```\n * fetchQuery(environment, query, variables).subscribe({\n *   // Called when network requests starts\n *   start: (subsctiption) => {},\n *\n *   // Called after a payload is received and written to the local store\n *   next: (payload) => {},\n *\n *   // Called when network requests errors\n *   error: (error) => {},\n *\n *   // Called when network requests fully completes\n *   complete: () => {},\n *\n *   // Called when network request is unsubscribed\n *   unsubscribe: (subscription) => {},\n * });\n * ```\n *\n * Request Promise:\n * ================\n * The obervable can be converted to a Promise with .toPromise(), which will\n * resolve to a snapshot of the query data when the first response is received\n * from the server.\n *\n * ```\n * fetchQuery(environment, query, variables).toPromise().then((data) => {\n *   // ...\n * });\n * ```\n *\n * In-flight request de-duping:\n * ============================\n * By default, calling fetchQuery multiple times with the same\n * environment, query and variables will not initiate a new request if a request\n * for those same parameters is already in flight.\n *\n * A request is marked in-flight from the moment it starts until the moment it\n * fully completes, regardless of error or successful completion.\n *\n * NOTE: If the request completes _synchronously_, calling fetchQuery\n * a second time with the same arguments in the same tick will _NOT_ de-dupe\n * the request given that it will no longer be in-flight.\n *\n *\n * Data Retention:\n * ===============\n * This function will NOT retain query data, meaning that it is not guaranteed\n * that the fetched data will remain in the Relay store after the request has\n * completed.\n * If you need to retain the query data outside of the network request,\n * you need to use `environment.retain()`.\n *\n *\n * Cancelling requests:\n * ====================\n * If the disposable returned by subscribe is called while the\n * request is in-flight, the request will be cancelled.\n *\n * ```\n * const disposable = fetchQuery(...).subscribe(...);\n *\n * // This will cancel the request if it is in-flight.\n * disposable.dispose();\n * ```\n * NOTE: When using .toPromise(), the request cannot be cancelled.\n */\n\n\nfunction fetchQuery(environment, query, variables, options) {\n  var _options$fetchPolicy;\n\n  var queryNode = getRequest(query);\n  !(queryNode.params.operationKind === 'query') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'fetchQuery: Expected query operation') : invariant(false) : void 0;\n  var networkCacheConfig = (0, _objectSpread2[\"default\"])({\n    force: true\n  }, options === null || options === void 0 ? void 0 : options.networkCacheConfig);\n  var operation = createOperationDescriptor(queryNode, variables, networkCacheConfig);\n  var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : 'network-only';\n\n  function readData(snapshot) {\n    if (snapshot.missingRequiredFields != null) {\n      reportMissingRequiredFields(environment, snapshot.missingRequiredFields);\n    }\n    /* $FlowFixMe[incompatible-return] we assume readData returns the right\n     * data just having written it from network or checked availability. */\n\n\n    return snapshot.data;\n  }\n\n  switch (fetchPolicy) {\n    case 'network-only':\n      {\n        return getNetworkObservable(environment, operation).map(readData);\n      }\n\n    case 'store-or-network':\n      {\n        if (environment.check(operation).status === 'available') {\n          return RelayObservable.from(environment.lookup(operation.fragment)).map(readData);\n        }\n\n        return getNetworkObservable(environment, operation).map(readData);\n      }\n\n    default:\n      fetchPolicy;\n      throw new Error('fetchQuery: Invalid fetchPolicy ' + fetchPolicy);\n  }\n}\n\nfunction getNetworkObservable(environment, operation) {\n  return fetchQueryInternal.fetchQuery(environment, operation).map(function () {\n    return environment.lookup(operation.fragment);\n  });\n}\n\nmodule.exports = fetchQuery;"]},"metadata":{},"sourceType":"script"}