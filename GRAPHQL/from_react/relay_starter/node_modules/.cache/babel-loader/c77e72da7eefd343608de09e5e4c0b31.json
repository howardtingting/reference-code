{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar getPendingOperationsForFragment = require('../util/getPendingOperationsForFragment');\n\nvar isScalarAndEqual = require('../util/isScalarAndEqual');\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar reportMissingRequiredFields = require('../util/reportMissingRequiredFields');\n\nvar _require = require('./RelayModernOperationDescriptor'),\n    createRequestDescriptor = _require.createRequestDescriptor;\n\nvar _require2 = require('./RelayModernSelector'),\n    areEqualSelectors = _require2.areEqualSelectors,\n    createReaderSelector = _require2.createReaderSelector,\n    getSelectorsFromObject = _require2.getSelectorsFromObject;\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n/**\n * A utility for resolving and subscribing to the results of a fragment spec\n * (key -> fragment mapping) given some \"props\" that determine the root ID\n * and variables to use when reading each fragment. When props are changed via\n * `setProps()`, the resolver will update its results and subscriptions\n * accordingly. Internally, the resolver:\n * - Converts the fragment map & props map into a map of `Selector`s.\n * - Removes any resolvers for any props that became null.\n * - Creates resolvers for any props that became non-null.\n * - Updates resolvers with the latest props.\n *\n * This utility is implemented as an imperative, stateful API for performance\n * reasons: reusing previous resolvers, callback functions, and subscriptions\n * all helps to reduce object allocation and thereby decrease GC time.\n *\n * The `resolve()` function is also lazy and memoized: changes in the store mark\n * the resolver as stale and notify the caller, and the actual results are\n * recomputed the first time `resolve()` is called.\n */\n\n\nvar RelayModernFragmentSpecResolver = /*#__PURE__*/function () {\n  function RelayModernFragmentSpecResolver(context, fragments, props, callback, rootIsQueryRenderer) {\n    var _this = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_onChange\", function () {\n      _this._stale = true;\n\n      if (typeof _this._callback === 'function') {\n        _this._callback();\n      }\n    });\n    this._callback = callback;\n    this._context = context;\n    this._data = {};\n    this._fragments = fragments;\n    this._props = {};\n    this._resolvers = {};\n    this._stale = false;\n    this._rootIsQueryRenderer = rootIsQueryRenderer;\n    this.setProps(props);\n  }\n\n  var _proto = RelayModernFragmentSpecResolver.prototype;\n\n  _proto.dispose = function dispose() {\n    for (var _key in this._resolvers) {\n      if (this._resolvers.hasOwnProperty(_key)) {\n        disposeCallback(this._resolvers[_key]);\n      }\n    }\n  };\n\n  _proto.resolve = function resolve() {\n    if (this._stale) {\n      // Avoid mapping the object multiple times, which could occur if data for\n      // multiple keys changes in the same event loop.\n      var prevData = this._data;\n      var nextData;\n\n      for (var _key2 in this._resolvers) {\n        if (this._resolvers.hasOwnProperty(_key2)) {\n          var resolver = this._resolvers[_key2];\n          var prevItem = prevData[_key2];\n\n          if (resolver) {\n            var nextItem = resolver.resolve();\n\n            if (nextData || nextItem !== prevItem) {\n              nextData = nextData || (0, _objectSpread2[\"default\"])({}, prevData);\n              nextData[_key2] = nextItem;\n            }\n          } else {\n            var prop = this._props[_key2];\n\n            var _nextItem = prop !== undefined ? prop : null;\n\n            if (nextData || !isScalarAndEqual(_nextItem, prevItem)) {\n              nextData = nextData || (0, _objectSpread2[\"default\"])({}, prevData);\n              nextData[_key2] = _nextItem;\n            }\n          }\n        }\n      }\n\n      this._data = nextData || prevData;\n      this._stale = false;\n    }\n\n    return this._data;\n  };\n\n  _proto.setCallback = function setCallback(props, callback) {\n    this._callback = callback;\n\n    if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n      this.setProps(props);\n    }\n  };\n\n  _proto.setProps = function setProps(props) {\n    this._props = {};\n    var ownedSelectors = getSelectorsFromObject(this._fragments, props);\n\n    for (var _key3 in ownedSelectors) {\n      if (ownedSelectors.hasOwnProperty(_key3)) {\n        var ownedSelector = ownedSelectors[_key3];\n        var resolver = this._resolvers[_key3];\n\n        if (ownedSelector == null) {\n          if (resolver != null) {\n            resolver.dispose();\n          }\n\n          resolver = null;\n        } else if (ownedSelector.kind === 'PluralReaderSelector') {\n          if (resolver == null) {\n            resolver = new SelectorListResolver(this._context.environment, this._rootIsQueryRenderer, ownedSelector, this._callback != null, this._onChange);\n          } else {\n            !(resolver instanceof SelectorListResolver) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an array.', _key3) : invariant(false) : void 0;\n            resolver.setSelector(ownedSelector);\n          }\n        } else {\n          if (resolver == null) {\n            resolver = new SelectorResolver(this._context.environment, this._rootIsQueryRenderer, ownedSelector, this._callback != null, this._onChange);\n          } else {\n            !(resolver instanceof SelectorResolver) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an object.', _key3) : invariant(false) : void 0;\n            resolver.setSelector(ownedSelector);\n          }\n        }\n\n        this._props[_key3] = props[_key3];\n        this._resolvers[_key3] = resolver;\n      }\n    }\n\n    this._stale = true;\n  };\n\n  _proto.setVariables = function setVariables(variables, request) {\n    for (var _key4 in this._resolvers) {\n      if (this._resolvers.hasOwnProperty(_key4)) {\n        var resolver = this._resolvers[_key4];\n\n        if (resolver) {\n          resolver.setVariables(variables, request);\n        }\n      }\n    }\n\n    this._stale = true;\n  };\n\n  return RelayModernFragmentSpecResolver;\n}();\n/**\n * A resolver for a single Selector.\n */\n\n\nvar SelectorResolver = /*#__PURE__*/function () {\n  function SelectorResolver(environment, rootIsQueryRenderer, selector, subscribeOnConstruction, callback) {\n    var _this2 = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_onChange\", function (snapshot) {\n      _this2._data = snapshot.data;\n      _this2._isMissingData = snapshot.isMissingData;\n      _this2._missingRequiredFields = snapshot.missingRequiredFields;\n\n      _this2._callback();\n    });\n\n    var _snapshot = environment.lookup(selector);\n\n    this._callback = callback;\n    this._data = _snapshot.data;\n    this._isMissingData = _snapshot.isMissingData;\n    this._missingRequiredFields = _snapshot.missingRequiredFields;\n    this._environment = environment;\n    this._rootIsQueryRenderer = rootIsQueryRenderer;\n    this._selector = selector;\n\n    if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n      if (subscribeOnConstruction) {\n        this._subscription = environment.subscribe(_snapshot, this._onChange);\n      }\n    } else {\n      this._subscription = environment.subscribe(_snapshot, this._onChange);\n    }\n  }\n\n  var _proto2 = SelectorResolver.prototype;\n\n  _proto2.dispose = function dispose() {\n    if (this._subscription) {\n      this._subscription.dispose();\n\n      this._subscription = null;\n    }\n  };\n\n  _proto2.resolve = function resolve() {\n    if (this._isMissingData === true) {\n      // NOTE: This branch exists to handle the case in which:\n      // - A RelayModern container is rendered as a descendant of a Relay Hook\n      //   root using a \"partial\" renderPolicy (this means that eargerly\n      //   reading any cached data that is available instead of blocking\n      //   at the root until the whole query is fetched).\n      // - A parent Relay Hook didnt' suspend earlier on data being fetched,\n      //   either because the fragment data for the parent was available, or\n      //   the parent fragment didn't have any data dependencies.\n      // Even though our Flow types reflect the possiblity of null data, there\n      // might still be cases where it's not handled at runtime becuase the\n      // Flow types are being ignored, or simply not being used (for example,\n      // the case reported here: https://fburl.com/srnbucf8, was due to\n      // misuse of Flow types here: https://fburl.com/g3m0mqqh).\n      // Additionally, even though the null data might be handled without a\n      // runtime error, we might not suspend when we intended to if a parent\n      // Relay Hook (e.g. that is using @defer) decided not to suspend becuase\n      // it's immediate data was already available (even if it was deferred),\n      // or it didn't actually need any data (was just spreading other fragments).\n      // This should eventually go away with something like @optional, where we only\n      // suspend at specific boundaries depending on whether the boundary\n      // can be fulfilled or not.\n      var pendingOperationsResult = getPendingOperationsForFragment(this._environment, this._selector.node, this._selector.owner);\n      var promise = pendingOperationsResult === null || pendingOperationsResult === void 0 ? void 0 : pendingOperationsResult.promise;\n\n      if (promise != null) {\n        if (this._rootIsQueryRenderer) {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Relay Container for fragment `%s` has missing data and ' + 'would suspend. When using features such as @defer or @module, ' + 'use `useFragment` instead of a Relay Container.', this._selector.node.name) : void 0;\n        } else {\n          var _pendingOperationsRes;\n\n          var pendingOperations = (_pendingOperationsRes = pendingOperationsResult === null || pendingOperationsResult === void 0 ? void 0 : pendingOperationsResult.pendingOperations) !== null && _pendingOperationsRes !== void 0 ? _pendingOperationsRes : [];\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Relay Container for fragment `%s` suspended. When using ' + 'features such as @defer or @module, use `useFragment` instead ' + 'of a Relay Container.', this._selector.node.name) : void 0;\n\n          this._environment.__log({\n            name: 'suspense.fragment',\n            data: this._data,\n            fragment: this._selector.node,\n            isRelayHooks: false,\n            isMissingData: this._isMissingData,\n            isPromiseCached: false,\n            pendingOperations: pendingOperations\n          });\n\n          throw promise;\n        }\n      }\n    }\n\n    if (this._missingRequiredFields != null) {\n      reportMissingRequiredFields(this._environment, this._missingRequiredFields);\n    }\n\n    return this._data;\n  };\n\n  _proto2.setSelector = function setSelector(selector) {\n    if (this._subscription != null && areEqualSelectors(selector, this._selector)) {\n      return;\n    }\n\n    this.dispose();\n\n    var snapshot = this._environment.lookup(selector);\n\n    this._data = recycleNodesInto(this._data, snapshot.data);\n    this._isMissingData = snapshot.isMissingData;\n    this._missingRequiredFields = snapshot.missingRequiredFields;\n    this._selector = selector;\n    this._subscription = this._environment.subscribe(snapshot, this._onChange);\n  };\n\n  _proto2.setVariables = function setVariables(variables, request) {\n    if (areEqual(variables, this._selector.variables)) {\n      // If we're not actually setting new variables, we don't actually want\n      // to create a new fragment owner, since areEqualSelectors relies on\n      // owner identity.\n      // In fact, we don't even need to try to attempt to set a new selector.\n      // When fragment ownership is not enabled, setSelector will also bail\n      // out since the selector doesn't really change, so we're doing it here\n      // earlier.\n      return;\n    } // NOTE: We manually create the request descriptor here instead of\n    // calling createOperationDescriptor() because we want to set a\n    // descriptor with *unaltered* variables as the fragment owner.\n    // This is a hack that allows us to preserve existing (broken)\n    // behavior of RelayModern containers while using fragment ownership\n    // to propagate variables instead of Context.\n    // For more details, see the summary of D13999308\n\n\n    var requestDescriptor = createRequestDescriptor(request, variables);\n    var selector = createReaderSelector(this._selector.node, this._selector.dataID, variables, requestDescriptor);\n    this.setSelector(selector);\n  };\n\n  return SelectorResolver;\n}();\n/**\n * A resolver for an array of Selectors.\n */\n\n\nvar SelectorListResolver = /*#__PURE__*/function () {\n  function SelectorListResolver(environment, rootIsQueryRenderer, selector, subscribeOnConstruction, callback) {\n    var _this3 = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_onChange\", function (data) {\n      _this3._stale = true;\n\n      _this3._callback();\n    });\n    this._callback = callback;\n    this._data = [];\n    this._environment = environment;\n    this._resolvers = [];\n    this._stale = true;\n    this._rootIsQueryRenderer = rootIsQueryRenderer;\n    this._subscribeOnConstruction = subscribeOnConstruction;\n    this.setSelector(selector);\n  }\n\n  var _proto3 = SelectorListResolver.prototype;\n\n  _proto3.dispose = function dispose() {\n    this._resolvers.forEach(disposeCallback);\n  };\n\n  _proto3.resolve = function resolve() {\n    if (this._stale) {\n      // Avoid mapping the array multiple times, which could occur if data for\n      // multiple indices changes in the same event loop.\n      var prevData = this._data;\n      var nextData;\n\n      for (var ii = 0; ii < this._resolvers.length; ii++) {\n        var prevItem = prevData[ii];\n\n        var nextItem = this._resolvers[ii].resolve();\n\n        if (nextData || nextItem !== prevItem) {\n          nextData = nextData || prevData.slice(0, ii);\n          nextData.push(nextItem);\n        }\n      }\n\n      if (!nextData && this._resolvers.length !== prevData.length) {\n        nextData = prevData.slice(0, this._resolvers.length);\n      }\n\n      this._data = nextData || prevData;\n      this._stale = false;\n    }\n\n    return this._data;\n  };\n\n  _proto3.setSelector = function setSelector(selector) {\n    var selectors = selector.selectors;\n\n    while (this._resolvers.length > selectors.length) {\n      var resolver = this._resolvers.pop();\n\n      resolver.dispose();\n    }\n\n    for (var ii = 0; ii < selectors.length; ii++) {\n      if (ii < this._resolvers.length) {\n        this._resolvers[ii].setSelector(selectors[ii]);\n      } else {\n        this._resolvers[ii] = new SelectorResolver(this._environment, this._rootIsQueryRenderer, selectors[ii], this._subscribeOnConstruction, this._onChange);\n      }\n    }\n\n    this._stale = true;\n  };\n\n  _proto3.setVariables = function setVariables(variables, request) {\n    this._resolvers.forEach(function (resolver) {\n      return resolver.setVariables(variables, request);\n    });\n\n    this._stale = true;\n  };\n\n  return SelectorListResolver;\n}();\n\nfunction disposeCallback(disposable) {\n  disposable && disposable.dispose();\n}\n\nmodule.exports = RelayModernFragmentSpecResolver;","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/store/RelayModernFragmentSpecResolver.js"],"names":["_interopRequireDefault","require","_objectSpread2","_defineProperty2","getPendingOperationsForFragment","isScalarAndEqual","recycleNodesInto","RelayFeatureFlags","reportMissingRequiredFields","_require","createRequestDescriptor","_require2","areEqualSelectors","createReaderSelector","getSelectorsFromObject","areEqual","invariant","warning","RelayModernFragmentSpecResolver","context","fragments","props","callback","rootIsQueryRenderer","_this","_stale","_callback","_context","_data","_fragments","_props","_resolvers","_rootIsQueryRenderer","setProps","_proto","prototype","dispose","_key","hasOwnProperty","disposeCallback","resolve","prevData","nextData","_key2","resolver","prevItem","nextItem","prop","_nextItem","undefined","setCallback","ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT","ownedSelectors","_key3","ownedSelector","kind","SelectorListResolver","environment","_onChange","process","env","NODE_ENV","setSelector","SelectorResolver","setVariables","variables","request","_key4","selector","subscribeOnConstruction","_this2","snapshot","data","_isMissingData","isMissingData","_missingRequiredFields","missingRequiredFields","_snapshot","lookup","_environment","_selector","_subscription","subscribe","_proto2","pendingOperationsResult","node","owner","promise","name","_pendingOperationsRes","pendingOperations","__log","fragment","isRelayHooks","isPromiseCached","requestDescriptor","dataID","_this3","_subscribeOnConstruction","_proto3","forEach","ii","length","slice","push","selectors","pop","disposable","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar getPendingOperationsForFragment = require('../util/getPendingOperationsForFragment');\n\nvar isScalarAndEqual = require('../util/isScalarAndEqual');\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar reportMissingRequiredFields = require('../util/reportMissingRequiredFields');\n\nvar _require = require('./RelayModernOperationDescriptor'),\n    createRequestDescriptor = _require.createRequestDescriptor;\n\nvar _require2 = require('./RelayModernSelector'),\n    areEqualSelectors = _require2.areEqualSelectors,\n    createReaderSelector = _require2.createReaderSelector,\n    getSelectorsFromObject = _require2.getSelectorsFromObject;\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\n/**\n * A utility for resolving and subscribing to the results of a fragment spec\n * (key -> fragment mapping) given some \"props\" that determine the root ID\n * and variables to use when reading each fragment. When props are changed via\n * `setProps()`, the resolver will update its results and subscriptions\n * accordingly. Internally, the resolver:\n * - Converts the fragment map & props map into a map of `Selector`s.\n * - Removes any resolvers for any props that became null.\n * - Creates resolvers for any props that became non-null.\n * - Updates resolvers with the latest props.\n *\n * This utility is implemented as an imperative, stateful API for performance\n * reasons: reusing previous resolvers, callback functions, and subscriptions\n * all helps to reduce object allocation and thereby decrease GC time.\n *\n * The `resolve()` function is also lazy and memoized: changes in the store mark\n * the resolver as stale and notify the caller, and the actual results are\n * recomputed the first time `resolve()` is called.\n */\nvar RelayModernFragmentSpecResolver = /*#__PURE__*/function () {\n  function RelayModernFragmentSpecResolver(context, fragments, props, callback, rootIsQueryRenderer) {\n    var _this = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_onChange\", function () {\n      _this._stale = true;\n\n      if (typeof _this._callback === 'function') {\n        _this._callback();\n      }\n    });\n    this._callback = callback;\n    this._context = context;\n    this._data = {};\n    this._fragments = fragments;\n    this._props = {};\n    this._resolvers = {};\n    this._stale = false;\n    this._rootIsQueryRenderer = rootIsQueryRenderer;\n    this.setProps(props);\n  }\n\n  var _proto = RelayModernFragmentSpecResolver.prototype;\n\n  _proto.dispose = function dispose() {\n    for (var _key in this._resolvers) {\n      if (this._resolvers.hasOwnProperty(_key)) {\n        disposeCallback(this._resolvers[_key]);\n      }\n    }\n  };\n\n  _proto.resolve = function resolve() {\n    if (this._stale) {\n      // Avoid mapping the object multiple times, which could occur if data for\n      // multiple keys changes in the same event loop.\n      var prevData = this._data;\n      var nextData;\n\n      for (var _key2 in this._resolvers) {\n        if (this._resolvers.hasOwnProperty(_key2)) {\n          var resolver = this._resolvers[_key2];\n          var prevItem = prevData[_key2];\n\n          if (resolver) {\n            var nextItem = resolver.resolve();\n\n            if (nextData || nextItem !== prevItem) {\n              nextData = nextData || (0, _objectSpread2[\"default\"])({}, prevData);\n              nextData[_key2] = nextItem;\n            }\n          } else {\n            var prop = this._props[_key2];\n\n            var _nextItem = prop !== undefined ? prop : null;\n\n            if (nextData || !isScalarAndEqual(_nextItem, prevItem)) {\n              nextData = nextData || (0, _objectSpread2[\"default\"])({}, prevData);\n              nextData[_key2] = _nextItem;\n            }\n          }\n        }\n      }\n\n      this._data = nextData || prevData;\n      this._stale = false;\n    }\n\n    return this._data;\n  };\n\n  _proto.setCallback = function setCallback(props, callback) {\n    this._callback = callback;\n\n    if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n      this.setProps(props);\n    }\n  };\n\n  _proto.setProps = function setProps(props) {\n    this._props = {};\n    var ownedSelectors = getSelectorsFromObject(this._fragments, props);\n\n    for (var _key3 in ownedSelectors) {\n      if (ownedSelectors.hasOwnProperty(_key3)) {\n        var ownedSelector = ownedSelectors[_key3];\n        var resolver = this._resolvers[_key3];\n\n        if (ownedSelector == null) {\n          if (resolver != null) {\n            resolver.dispose();\n          }\n\n          resolver = null;\n        } else if (ownedSelector.kind === 'PluralReaderSelector') {\n          if (resolver == null) {\n            resolver = new SelectorListResolver(this._context.environment, this._rootIsQueryRenderer, ownedSelector, this._callback != null, this._onChange);\n          } else {\n            !(resolver instanceof SelectorListResolver) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an array.', _key3) : invariant(false) : void 0;\n            resolver.setSelector(ownedSelector);\n          }\n        } else {\n          if (resolver == null) {\n            resolver = new SelectorResolver(this._context.environment, this._rootIsQueryRenderer, ownedSelector, this._callback != null, this._onChange);\n          } else {\n            !(resolver instanceof SelectorResolver) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an object.', _key3) : invariant(false) : void 0;\n            resolver.setSelector(ownedSelector);\n          }\n        }\n\n        this._props[_key3] = props[_key3];\n        this._resolvers[_key3] = resolver;\n      }\n    }\n\n    this._stale = true;\n  };\n\n  _proto.setVariables = function setVariables(variables, request) {\n    for (var _key4 in this._resolvers) {\n      if (this._resolvers.hasOwnProperty(_key4)) {\n        var resolver = this._resolvers[_key4];\n\n        if (resolver) {\n          resolver.setVariables(variables, request);\n        }\n      }\n    }\n\n    this._stale = true;\n  };\n\n  return RelayModernFragmentSpecResolver;\n}();\n/**\n * A resolver for a single Selector.\n */\n\n\nvar SelectorResolver = /*#__PURE__*/function () {\n  function SelectorResolver(environment, rootIsQueryRenderer, selector, subscribeOnConstruction, callback) {\n    var _this2 = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_onChange\", function (snapshot) {\n      _this2._data = snapshot.data;\n      _this2._isMissingData = snapshot.isMissingData;\n      _this2._missingRequiredFields = snapshot.missingRequiredFields;\n\n      _this2._callback();\n    });\n\n    var _snapshot = environment.lookup(selector);\n\n    this._callback = callback;\n    this._data = _snapshot.data;\n    this._isMissingData = _snapshot.isMissingData;\n    this._missingRequiredFields = _snapshot.missingRequiredFields;\n    this._environment = environment;\n    this._rootIsQueryRenderer = rootIsQueryRenderer;\n    this._selector = selector;\n\n    if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {\n      if (subscribeOnConstruction) {\n        this._subscription = environment.subscribe(_snapshot, this._onChange);\n      }\n    } else {\n      this._subscription = environment.subscribe(_snapshot, this._onChange);\n    }\n  }\n\n  var _proto2 = SelectorResolver.prototype;\n\n  _proto2.dispose = function dispose() {\n    if (this._subscription) {\n      this._subscription.dispose();\n\n      this._subscription = null;\n    }\n  };\n\n  _proto2.resolve = function resolve() {\n    if (this._isMissingData === true) {\n      // NOTE: This branch exists to handle the case in which:\n      // - A RelayModern container is rendered as a descendant of a Relay Hook\n      //   root using a \"partial\" renderPolicy (this means that eargerly\n      //   reading any cached data that is available instead of blocking\n      //   at the root until the whole query is fetched).\n      // - A parent Relay Hook didnt' suspend earlier on data being fetched,\n      //   either because the fragment data for the parent was available, or\n      //   the parent fragment didn't have any data dependencies.\n      // Even though our Flow types reflect the possiblity of null data, there\n      // might still be cases where it's not handled at runtime becuase the\n      // Flow types are being ignored, or simply not being used (for example,\n      // the case reported here: https://fburl.com/srnbucf8, was due to\n      // misuse of Flow types here: https://fburl.com/g3m0mqqh).\n      // Additionally, even though the null data might be handled without a\n      // runtime error, we might not suspend when we intended to if a parent\n      // Relay Hook (e.g. that is using @defer) decided not to suspend becuase\n      // it's immediate data was already available (even if it was deferred),\n      // or it didn't actually need any data (was just spreading other fragments).\n      // This should eventually go away with something like @optional, where we only\n      // suspend at specific boundaries depending on whether the boundary\n      // can be fulfilled or not.\n      var pendingOperationsResult = getPendingOperationsForFragment(this._environment, this._selector.node, this._selector.owner);\n      var promise = pendingOperationsResult === null || pendingOperationsResult === void 0 ? void 0 : pendingOperationsResult.promise;\n\n      if (promise != null) {\n        if (this._rootIsQueryRenderer) {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Relay Container for fragment `%s` has missing data and ' + 'would suspend. When using features such as @defer or @module, ' + 'use `useFragment` instead of a Relay Container.', this._selector.node.name) : void 0;\n        } else {\n          var _pendingOperationsRes;\n\n          var pendingOperations = (_pendingOperationsRes = pendingOperationsResult === null || pendingOperationsResult === void 0 ? void 0 : pendingOperationsResult.pendingOperations) !== null && _pendingOperationsRes !== void 0 ? _pendingOperationsRes : [];\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Relay Container for fragment `%s` suspended. When using ' + 'features such as @defer or @module, use `useFragment` instead ' + 'of a Relay Container.', this._selector.node.name) : void 0;\n\n          this._environment.__log({\n            name: 'suspense.fragment',\n            data: this._data,\n            fragment: this._selector.node,\n            isRelayHooks: false,\n            isMissingData: this._isMissingData,\n            isPromiseCached: false,\n            pendingOperations: pendingOperations\n          });\n\n          throw promise;\n        }\n      }\n    }\n\n    if (this._missingRequiredFields != null) {\n      reportMissingRequiredFields(this._environment, this._missingRequiredFields);\n    }\n\n    return this._data;\n  };\n\n  _proto2.setSelector = function setSelector(selector) {\n    if (this._subscription != null && areEqualSelectors(selector, this._selector)) {\n      return;\n    }\n\n    this.dispose();\n\n    var snapshot = this._environment.lookup(selector);\n\n    this._data = recycleNodesInto(this._data, snapshot.data);\n    this._isMissingData = snapshot.isMissingData;\n    this._missingRequiredFields = snapshot.missingRequiredFields;\n    this._selector = selector;\n    this._subscription = this._environment.subscribe(snapshot, this._onChange);\n  };\n\n  _proto2.setVariables = function setVariables(variables, request) {\n    if (areEqual(variables, this._selector.variables)) {\n      // If we're not actually setting new variables, we don't actually want\n      // to create a new fragment owner, since areEqualSelectors relies on\n      // owner identity.\n      // In fact, we don't even need to try to attempt to set a new selector.\n      // When fragment ownership is not enabled, setSelector will also bail\n      // out since the selector doesn't really change, so we're doing it here\n      // earlier.\n      return;\n    } // NOTE: We manually create the request descriptor here instead of\n    // calling createOperationDescriptor() because we want to set a\n    // descriptor with *unaltered* variables as the fragment owner.\n    // This is a hack that allows us to preserve existing (broken)\n    // behavior of RelayModern containers while using fragment ownership\n    // to propagate variables instead of Context.\n    // For more details, see the summary of D13999308\n\n\n    var requestDescriptor = createRequestDescriptor(request, variables);\n    var selector = createReaderSelector(this._selector.node, this._selector.dataID, variables, requestDescriptor);\n    this.setSelector(selector);\n  };\n\n  return SelectorResolver;\n}();\n/**\n * A resolver for an array of Selectors.\n */\n\n\nvar SelectorListResolver = /*#__PURE__*/function () {\n  function SelectorListResolver(environment, rootIsQueryRenderer, selector, subscribeOnConstruction, callback) {\n    var _this3 = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_onChange\", function (data) {\n      _this3._stale = true;\n\n      _this3._callback();\n    });\n    this._callback = callback;\n    this._data = [];\n    this._environment = environment;\n    this._resolvers = [];\n    this._stale = true;\n    this._rootIsQueryRenderer = rootIsQueryRenderer;\n    this._subscribeOnConstruction = subscribeOnConstruction;\n    this.setSelector(selector);\n  }\n\n  var _proto3 = SelectorListResolver.prototype;\n\n  _proto3.dispose = function dispose() {\n    this._resolvers.forEach(disposeCallback);\n  };\n\n  _proto3.resolve = function resolve() {\n    if (this._stale) {\n      // Avoid mapping the array multiple times, which could occur if data for\n      // multiple indices changes in the same event loop.\n      var prevData = this._data;\n      var nextData;\n\n      for (var ii = 0; ii < this._resolvers.length; ii++) {\n        var prevItem = prevData[ii];\n\n        var nextItem = this._resolvers[ii].resolve();\n\n        if (nextData || nextItem !== prevItem) {\n          nextData = nextData || prevData.slice(0, ii);\n          nextData.push(nextItem);\n        }\n      }\n\n      if (!nextData && this._resolvers.length !== prevData.length) {\n        nextData = prevData.slice(0, this._resolvers.length);\n      }\n\n      this._data = nextData || prevData;\n      this._stale = false;\n    }\n\n    return this._data;\n  };\n\n  _proto3.setSelector = function setSelector(selector) {\n    var selectors = selector.selectors;\n\n    while (this._resolvers.length > selectors.length) {\n      var resolver = this._resolvers.pop();\n\n      resolver.dispose();\n    }\n\n    for (var ii = 0; ii < selectors.length; ii++) {\n      if (ii < this._resolvers.length) {\n        this._resolvers[ii].setSelector(selectors[ii]);\n      } else {\n        this._resolvers[ii] = new SelectorResolver(this._environment, this._rootIsQueryRenderer, selectors[ii], this._subscribeOnConstruction, this._onChange);\n      }\n    }\n\n    this._stale = true;\n  };\n\n  _proto3.setVariables = function setVariables(variables, request) {\n    this._resolvers.forEach(function (resolver) {\n      return resolver.setVariables(variables, request);\n    });\n\n    this._stale = true;\n  };\n\n  return SelectorListResolver;\n}();\n\nfunction disposeCallback(disposable) {\n  disposable && disposable.dispose();\n}\n\nmodule.exports = RelayModernFragmentSpecResolver;"]},"metadata":{},"sourceType":"script"}