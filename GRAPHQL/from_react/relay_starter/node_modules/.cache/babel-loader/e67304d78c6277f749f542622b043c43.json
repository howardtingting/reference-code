{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar hasWeakSetDefined = typeof WeakSet !== 'undefined';\nvar hasWeakMapDefined = typeof WeakMap !== 'undefined';\n/**\n * Recycles subtrees from `prevData` by replacing equal subtrees in `nextData`.\n */\n\nfunction recycleNodesInto(prevData, nextData) {\n  if (prevData === nextData || typeof prevData !== 'object' || prevData instanceof Set || prevData instanceof Map || hasWeakSetDefined && prevData instanceof WeakSet || hasWeakMapDefined && prevData instanceof WeakMap || !prevData || typeof nextData !== 'object' || nextData instanceof Set || nextData instanceof Map || hasWeakSetDefined && nextData instanceof WeakSet || hasWeakMapDefined && nextData instanceof WeakMap || !nextData) {\n    return nextData;\n  }\n\n  var canRecycle = false; // Assign local variables to preserve Flow type refinement.\n\n  var prevArray = Array.isArray(prevData) ? prevData : null;\n  var nextArray = Array.isArray(nextData) ? nextData : null;\n\n  if (prevArray && nextArray) {\n    canRecycle = nextArray.reduce(function (wasEqual, nextItem, ii) {\n      var prevValue = prevArray[ii];\n      var nextValue = recycleNodesInto(prevValue, nextItem);\n\n      if (nextValue !== nextArray[ii]) {\n        if (process.env.NODE_ENV !== \"production\") {\n          if (!Object.isFrozen(nextArray)) {\n            nextArray[ii] = nextValue;\n          }\n        } else {\n          nextArray[ii] = nextValue;\n        }\n      }\n\n      return wasEqual && nextValue === prevArray[ii];\n    }, true) && prevArray.length === nextArray.length;\n  } else if (!prevArray && !nextArray) {\n    // Assign local variables to preserve Flow type refinement.\n    var prevObject = prevData;\n    var nextObject = nextData;\n    var prevKeys = Object.keys(prevObject);\n    var nextKeys = Object.keys(nextObject);\n    canRecycle = nextKeys.reduce(function (wasEqual, key) {\n      var prevValue = prevObject[key];\n      var nextValue = recycleNodesInto(prevValue, nextObject[key]);\n\n      if (nextValue !== nextObject[key]) {\n        if (process.env.NODE_ENV !== \"production\") {\n          if (!Object.isFrozen(nextObject)) {\n            // $FlowFixMe[cannot-write]\n            nextObject[key] = nextValue;\n          }\n        } else {\n          // $FlowFixMe[cannot-write]\n          nextObject[key] = nextValue;\n        }\n      }\n\n      return wasEqual && nextValue === prevObject[key];\n    }, true) && prevKeys.length === nextKeys.length;\n  }\n\n  return canRecycle ? prevData : nextData;\n}\n\nmodule.exports = recycleNodesInto;","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/util/recycleNodesInto.js"],"names":["hasWeakSetDefined","WeakSet","hasWeakMapDefined","WeakMap","recycleNodesInto","prevData","nextData","Set","Map","canRecycle","prevArray","Array","isArray","nextArray","reduce","wasEqual","nextItem","ii","prevValue","nextValue","process","env","NODE_ENV","Object","isFrozen","length","prevObject","nextObject","prevKeys","keys","nextKeys","key","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar hasWeakSetDefined = typeof WeakSet !== 'undefined';\nvar hasWeakMapDefined = typeof WeakMap !== 'undefined';\n/**\n * Recycles subtrees from `prevData` by replacing equal subtrees in `nextData`.\n */\n\nfunction recycleNodesInto(prevData, nextData) {\n  if (prevData === nextData || typeof prevData !== 'object' || prevData instanceof Set || prevData instanceof Map || hasWeakSetDefined && prevData instanceof WeakSet || hasWeakMapDefined && prevData instanceof WeakMap || !prevData || typeof nextData !== 'object' || nextData instanceof Set || nextData instanceof Map || hasWeakSetDefined && nextData instanceof WeakSet || hasWeakMapDefined && nextData instanceof WeakMap || !nextData) {\n    return nextData;\n  }\n\n  var canRecycle = false; // Assign local variables to preserve Flow type refinement.\n\n  var prevArray = Array.isArray(prevData) ? prevData : null;\n  var nextArray = Array.isArray(nextData) ? nextData : null;\n\n  if (prevArray && nextArray) {\n    canRecycle = nextArray.reduce(function (wasEqual, nextItem, ii) {\n      var prevValue = prevArray[ii];\n      var nextValue = recycleNodesInto(prevValue, nextItem);\n\n      if (nextValue !== nextArray[ii]) {\n        if (process.env.NODE_ENV !== \"production\") {\n          if (!Object.isFrozen(nextArray)) {\n            nextArray[ii] = nextValue;\n          }\n        } else {\n          nextArray[ii] = nextValue;\n        }\n      }\n\n      return wasEqual && nextValue === prevArray[ii];\n    }, true) && prevArray.length === nextArray.length;\n  } else if (!prevArray && !nextArray) {\n    // Assign local variables to preserve Flow type refinement.\n    var prevObject = prevData;\n    var nextObject = nextData;\n    var prevKeys = Object.keys(prevObject);\n    var nextKeys = Object.keys(nextObject);\n    canRecycle = nextKeys.reduce(function (wasEqual, key) {\n      var prevValue = prevObject[key];\n      var nextValue = recycleNodesInto(prevValue, nextObject[key]);\n\n      if (nextValue !== nextObject[key]) {\n        if (process.env.NODE_ENV !== \"production\") {\n          if (!Object.isFrozen(nextObject)) {\n            // $FlowFixMe[cannot-write]\n            nextObject[key] = nextValue;\n          }\n        } else {\n          // $FlowFixMe[cannot-write]\n          nextObject[key] = nextValue;\n        }\n      }\n\n      return wasEqual && nextValue === prevObject[key];\n    }, true) && prevKeys.length === nextKeys.length;\n  }\n\n  return canRecycle ? prevData : nextData;\n}\n\nmodule.exports = recycleNodesInto;"]},"metadata":{},"sourceType":"script"}