{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar SuspenseResource = require('./SuspenseResource');\n\nvar invariant = require('invariant');\n\nvar _require = require('relay-runtime'),\n    RelayFeatureFlags = _require.RelayFeatureFlags,\n    isPromise = _require.isPromise;\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar CACHE_CAPACITY = 1000;\nvar DEFAULT_FETCH_POLICY = 'store-or-network';\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\n\nfunction operationIsLiveQuery(operation) {\n  return operation.request.node.params.metadata.live !== undefined;\n}\n\nfunction getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n  var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n  var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();\n  var cacheIdentifier = \"\".concat(fetchPolicy, \"-\").concat(renderPolicy, \"-\").concat(operation.request.identifier);\n\n  if (cacheBreaker != null) {\n    return \"\".concat(cacheIdentifier, \"-\").concat(cacheBreaker);\n  }\n\n  return cacheIdentifier;\n}\n\nfunction getQueryResult(operation, cacheIdentifier) {\n  var rootFragmentRef = {\n    __id: operation.fragment.dataID,\n    __fragments: (0, _defineProperty2[\"default\"])({}, operation.fragment.node.name, operation.request.variables),\n    __fragmentOwner: operation.request\n  };\n  return {\n    cacheIdentifier: cacheIdentifier,\n    fragmentNode: operation.request.node.fragment,\n    fragmentRef: rootFragmentRef,\n    operation: operation\n  };\n}\n\nvar nextID = 200000;\n\nfunction createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose) {\n  // There should be no behavior difference between createCacheEntry_new and\n  // createCacheEntry_old, and it doesn't directly relate to Client Edges.\n  // It was just a refactoring that was needed for Client Edges but that\n  // is behind the feature flag just in case there is any accidental breakage.\n  if (RelayFeatureFlags.REFACTOR_SUSPENSE_RESOURCE) {\n    return createCacheEntry_new(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose);\n  } else {\n    return createCacheEntry_old(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose);\n  }\n}\n\nfunction createCacheEntry_new(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose) {\n  var isLiveQuery = operationIsLiveQuery(operation);\n  var currentValue = value;\n  var currentNetworkSubscription = networkSubscription;\n  var suspenseResource = new SuspenseResource(function (environment) {\n    var retention = environment.retain(operation);\n    return {\n      dispose: function dispose() {\n        // Normally if this entry never commits, the request would've ended by the\n        // time this timeout expires and the temporary retain is released. However,\n        // we need to do this for live queries which remain open indefinitely.\n        if (isLiveQuery && currentNetworkSubscription != null) {\n          currentNetworkSubscription.unsubscribe();\n        }\n\n        retention.dispose();\n        onDispose(cacheEntry);\n      }\n    };\n  });\n  var cacheEntry = {\n    cacheIdentifier: cacheIdentifier,\n    id: nextID++,\n    processedPayloadsCount: 0,\n    operationAvailability: operationAvailability,\n    getValue: function getValue() {\n      return currentValue;\n    },\n    setValue: function setValue(val) {\n      currentValue = val;\n    },\n    getRetainCount: function getRetainCount() {\n      return suspenseResource.getRetainCount();\n    },\n    getNetworkSubscription: function getNetworkSubscription() {\n      return currentNetworkSubscription;\n    },\n    setNetworkSubscription: function setNetworkSubscription(subscription) {\n      if (isLiveQuery && currentNetworkSubscription != null) {\n        currentNetworkSubscription.unsubscribe();\n      }\n\n      currentNetworkSubscription = subscription;\n    },\n    temporaryRetain: function temporaryRetain(environment) {\n      return suspenseResource.temporaryRetain(environment);\n    },\n    permanentRetain: function permanentRetain(environment) {\n      return suspenseResource.permanentRetain(environment);\n    },\n    releaseTemporaryRetain: function releaseTemporaryRetain() {\n      suspenseResource.releaseTemporaryRetain();\n    }\n  };\n  return cacheEntry;\n}\n\nvar DATA_RETENTION_TIMEOUT = 5 * 60 * 1000;\n\nfunction createCacheEntry_old(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose) {\n  var isLiveQuery = operationIsLiveQuery(operation);\n  var currentValue = value;\n  var retainCount = 0;\n  var retainDisposable = null;\n  var _releaseTemporaryRetain = null;\n  var currentNetworkSubscription = networkSubscription;\n\n  var retain = function retain(environment) {\n    retainCount++;\n\n    if (retainCount === 1) {\n      retainDisposable = environment.retain(operation);\n    }\n\n    return {\n      dispose: function dispose() {\n        retainCount = Math.max(0, retainCount - 1);\n\n        if (retainCount === 0) {\n          !(retainDisposable != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected disposable to release query to be defined.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n          retainDisposable.dispose();\n          retainDisposable = null;\n        }\n\n        onDispose(cacheEntry);\n      }\n    };\n  };\n\n  var cacheEntry = {\n    cacheIdentifier: cacheIdentifier,\n    id: nextID++,\n    processedPayloadsCount: 0,\n    operationAvailability: operationAvailability,\n    getValue: function getValue() {\n      return currentValue;\n    },\n    setValue: function setValue(val) {\n      currentValue = val;\n    },\n    getRetainCount: function getRetainCount() {\n      return retainCount;\n    },\n    getNetworkSubscription: function getNetworkSubscription() {\n      return currentNetworkSubscription;\n    },\n    setNetworkSubscription: function setNetworkSubscription(subscription) {\n      if (isLiveQuery && currentNetworkSubscription != null) {\n        currentNetworkSubscription.unsubscribe();\n      }\n\n      currentNetworkSubscription = subscription;\n    },\n    temporaryRetain: function temporaryRetain(environment) {\n      // NOTE: If we're executing in a server environment, there's no need\n      // to create temporary retains, since the component will never commit.\n      if (environment.isServer()) {\n        return {\n          dispose: function dispose() {}\n        };\n      } // NOTE: temporaryRetain is called during the render phase. However,\n      // given that we can't tell if this render will eventually commit or not,\n      // we create a timer to autodispose of this retain in case the associated\n      // component never commits.\n      // If the component /does/ commit, permanentRetain will clear this timeout\n      // and permanently retain the data.\n\n\n      var disposable = retain(environment);\n      var releaseQueryTimeout = null;\n\n      var localReleaseTemporaryRetain = function localReleaseTemporaryRetain() {\n        clearTimeout(releaseQueryTimeout);\n        releaseQueryTimeout = null;\n        _releaseTemporaryRetain = null;\n        disposable.dispose(); // Normally if this entry never commits, the request would've ended by the\n        // time this timeout expires and the temporary retain is released. However,\n        // we need to do this for live queries which remain open indefinitely.\n\n        if (isLiveQuery && retainCount <= 0 && currentNetworkSubscription != null) {\n          currentNetworkSubscription.unsubscribe();\n        }\n      };\n\n      releaseQueryTimeout = setTimeout(localReleaseTemporaryRetain, DATA_RETENTION_TIMEOUT); // NOTE: Since temporaryRetain can be called multiple times, we release\n      // the previous temporary retain after we re-establish a new one, since\n      // we only ever need a single temporary retain until the permanent retain is\n      // established.\n      // temporaryRetain may be called multiple times by React during the render\n      // phase, as well as multiple times by other query components that are\n      // rendering the same query/variables.\n\n      if (_releaseTemporaryRetain != null) {\n        _releaseTemporaryRetain();\n      }\n\n      _releaseTemporaryRetain = localReleaseTemporaryRetain;\n      return {\n        dispose: function dispose() {\n          _releaseTemporaryRetain && _releaseTemporaryRetain();\n        }\n      };\n    },\n    permanentRetain: function permanentRetain(environment) {\n      var disposable = retain(environment);\n\n      if (_releaseTemporaryRetain != null) {\n        _releaseTemporaryRetain();\n\n        _releaseTemporaryRetain = null;\n      }\n\n      return {\n        dispose: function dispose() {\n          disposable.dispose();\n\n          if (isLiveQuery && retainCount <= 0 && currentNetworkSubscription != null) {\n            currentNetworkSubscription.unsubscribe();\n          }\n        }\n      };\n    },\n    releaseTemporaryRetain: function releaseTemporaryRetain() {\n      if (_releaseTemporaryRetain != null) {\n        _releaseTemporaryRetain();\n\n        _releaseTemporaryRetain = null;\n      }\n    }\n  };\n  return cacheEntry;\n}\n\nvar QueryResourceImpl = /*#__PURE__*/function () {\n  function QueryResourceImpl(environment) {\n    var _this = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_clearCacheEntry\", function (cacheEntry) {\n      // The new code does this retainCount <= 0 check within SuspenseResource\n      // before calling _clearCacheEntry, whereas with the old code we do it here.\n      if (RelayFeatureFlags.REFACTOR_SUSPENSE_RESOURCE) {\n        _this._cache[\"delete\"](cacheEntry.cacheIdentifier);\n      } else {\n        if (cacheEntry.getRetainCount() <= 0) {\n          _this._cache[\"delete\"](cacheEntry.cacheIdentifier);\n        }\n      }\n    });\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n  }\n\n  var _proto = QueryResourceImpl.prototype;\n\n  _proto.prepare = function prepare(operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, cacheBreaker, profilerContext) {\n    var cacheIdentifier = getQueryCacheIdentifier(this._environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this.prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext);\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to either read an existing cached value for the query, or fetch the query\n   * and suspend.\n   */\n  ;\n\n  _proto.prepareWithIdentifier = function prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext) {\n    var environment = this._environment;\n    var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n    var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy(); // 1. Check if there's a cached value for this operation, and reuse it if\n    // it's available\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    var temporaryRetainDisposable = null;\n    var entryWasCached = cacheEntry != null;\n\n    if (cacheEntry == null) {\n      // 2. If a cached value isn't available, try fetching the operation.\n      // _fetchAndSaveQuery will update the cache with either a Promise or\n      // an Error to throw, or a QueryResult to return.\n      cacheEntry = this._fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, observer), {}, {\n        unsubscribe: function unsubscribe(subscription) {\n          // 4. If the request is cancelled, make sure to dispose\n          // of the temporary retain; this will ensure that a promise\n          // doesn't remain unnecessarily cached until the temporary retain\n          // expires. Not clearing the temporary retain might cause the\n          // query to incorrectly re-suspend.\n          if (temporaryRetainDisposable != null) {\n            temporaryRetainDisposable.dispose();\n          }\n\n          var observerUnsubscribe = observer === null || observer === void 0 ? void 0 : observer.unsubscribe;\n          observerUnsubscribe && observerUnsubscribe(subscription);\n        }\n      }));\n    } // 3. Temporarily retain here in render phase. When the component reading\n    // the operation is committed, we will transfer ownership of data retention\n    // to the component.\n    // In case the component never commits (mounts or updates) from this render,\n    // this data retention hold will auto-release itself after a timeout.\n\n\n    temporaryRetainDisposable = cacheEntry.temporaryRetain(environment);\n    var cachedValue = cacheEntry.getValue();\n\n    if (isPromise(cachedValue)) {\n      environment.__log({\n        name: 'suspense.query',\n        fetchPolicy: fetchPolicy,\n        isPromiseCached: entryWasCached,\n        operation: operation,\n        queryAvailability: cacheEntry.operationAvailability,\n        renderPolicy: renderPolicy\n      });\n\n      throw cachedValue;\n    }\n\n    if (cachedValue instanceof Error) {\n      throw cachedValue;\n    }\n\n    return cachedValue;\n  }\n  /**\n   * This function should be called during a component's commit phase\n   * (e.g. inside useEffect), in order to retain the operation in the Relay store\n   * and transfer ownership of the operation to the component lifecycle.\n   */\n  ;\n\n  _proto.retain = function retain(queryResult, profilerContext) {\n    var environment = this._environment;\n    var cacheIdentifier = queryResult.cacheIdentifier,\n        operation = queryResult.operation;\n\n    var cacheEntry = this._getOrCreateCacheEntry(cacheIdentifier, operation, null, queryResult, null);\n\n    var disposable = cacheEntry.permanentRetain(environment);\n\n    environment.__log({\n      name: 'queryresource.retain',\n      profilerContext: profilerContext,\n      resourceID: cacheEntry.id\n    });\n\n    return {\n      dispose: function dispose() {\n        disposable.dispose();\n      }\n    };\n  };\n\n  _proto.releaseTemporaryRetain = function releaseTemporaryRetain(queryResult) {\n    var cacheEntry = this._cache.get(queryResult.cacheIdentifier);\n\n    if (cacheEntry != null) {\n      cacheEntry.releaseTemporaryRetain();\n    }\n  };\n\n  _proto.TESTS_ONLY__getCacheEntry = function TESTS_ONLY__getCacheEntry(operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n    var environment = this._environment;\n    var cacheIdentifier = getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this._cache.get(cacheIdentifier);\n  };\n\n  _proto._getOrCreateCacheEntry = function _getOrCreateCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription) {\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    if (cacheEntry == null) {\n      cacheEntry = createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, cacheEntry);\n    }\n\n    return cacheEntry;\n  };\n\n  _proto._fetchAndSaveQuery = function _fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, observer) {\n    var _this2 = this;\n\n    var environment = this._environment; // NOTE: Running `check` will write missing data to the store using any\n    // missing data handlers specified on the environment;\n    // We run it here first to make the handlers get a chance to populate\n    // missing data.\n\n    var queryAvailability = environment.check(operation);\n    var queryStatus = queryAvailability.status;\n    var hasFullQuery = queryStatus === 'available';\n    var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale';\n    var shouldFetch;\n    var shouldAllowRender;\n\n    var resolveNetworkPromise = function resolveNetworkPromise() {};\n\n    switch (fetchPolicy) {\n      case 'store-only':\n        {\n          shouldFetch = false;\n          shouldAllowRender = true;\n          break;\n        }\n\n      case 'store-or-network':\n        {\n          shouldFetch = !hasFullQuery;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'store-and-network':\n        {\n          shouldFetch = true;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'network-only':\n      default:\n        {\n          shouldFetch = true;\n          shouldAllowRender = false;\n          break;\n        }\n    } // NOTE: If this value is false, we will cache a promise for this\n    // query, which means we will suspend here at this query root.\n    // If it's true, we will cache the query resource and allow rendering to\n    // continue.\n\n\n    if (shouldAllowRender) {\n      var queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var _cacheEntry = createCacheEntry(cacheIdentifier, operation, queryAvailability, queryResult, null, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, _cacheEntry);\n    }\n\n    if (shouldFetch) {\n      var _queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var networkSubscription;\n      fetchObservable.subscribe({\n        start: function start(subscription) {\n          networkSubscription = subscription;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(networkSubscription);\n          }\n\n          var observerStart = observer === null || observer === void 0 ? void 0 : observer.start;\n\n          if (observerStart) {\n            var subscriptionWithConditionalCancelation = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, subscription), {}, {\n              unsubscribe: function unsubscribe() {\n                // Only live queries should have their network requests canceled.\n                if (operationIsLiveQuery(operation)) {\n                  subscription.unsubscribe();\n                }\n              }\n            });\n            observerStart(subscriptionWithConditionalCancelation);\n          }\n        },\n        next: function next() {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _queryResult, networkSubscription);\n\n          cacheEntry.processedPayloadsCount += 1;\n          cacheEntry.setValue(_queryResult);\n          resolveNetworkPromise();\n          var observerNext = observer === null || observer === void 0 ? void 0 : observer.next;\n\n          if (observerNext != null) {\n            var snapshot = environment.lookup(operation.fragment);\n            observerNext(snapshot);\n          }\n        },\n        error: function error(_error) {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _error, networkSubscription); // If, this is the first thing we receive for the query,\n          // before any other payload handled is error, we will cache and\n          // re-throw that error later.\n          // We will ignore errors for any incremental payloads we receive.\n\n\n          if (cacheEntry.processedPayloadsCount === 0) {\n            cacheEntry.setValue(_error);\n          } else {\n            // TODO:T92030819 Remove this warning and actually throw the network error\n            // To complete this task we need to have a way of precisely tracking suspendable points\n            process.env.NODE_ENV !== \"production\" ? warning(false, 'QueryResource: An incremental payload for query `%` returned an error: `%`:`%`.', operation.fragment.node.name, _error.message, _error.stack) : void 0;\n          }\n\n          resolveNetworkPromise();\n          networkSubscription = null;\n          cacheEntry.setNetworkSubscription(null);\n          var observerError = observer === null || observer === void 0 ? void 0 : observer.error;\n          observerError && observerError(_error);\n        },\n        complete: function complete() {\n          resolveNetworkPromise();\n          networkSubscription = null;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(null);\n          }\n\n          var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n          observerComplete && observerComplete();\n        },\n        unsubscribe: observer === null || observer === void 0 ? void 0 : observer.unsubscribe\n      });\n\n      var _cacheEntry2 = this._cache.get(cacheIdentifier);\n\n      if (!_cacheEntry2) {\n        var networkPromise = new Promise(function (resolve) {\n          resolveNetworkPromise = resolve;\n        }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n        networkPromise.displayName = 'Relay(' + operation.fragment.node.name + ')';\n        _cacheEntry2 = createCacheEntry(cacheIdentifier, operation, queryAvailability, networkPromise, networkSubscription, this._clearCacheEntry);\n\n        this._cache.set(cacheIdentifier, _cacheEntry2);\n      }\n    } else {\n      var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n      observerComplete && observerComplete();\n    }\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    !(cacheEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to have cached a result when attempting to fetch query.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n\n    environment.__log({\n      name: 'queryresource.fetch',\n      resourceID: cacheEntry.id,\n      operation: operation,\n      profilerContext: profilerContext,\n      fetchPolicy: fetchPolicy,\n      renderPolicy: renderPolicy,\n      queryAvailability: queryAvailability,\n      shouldFetch: shouldFetch\n    });\n\n    return cacheEntry;\n  };\n\n  return QueryResourceImpl;\n}();\n\nfunction createQueryResource(environment) {\n  return new QueryResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getQueryResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createQueryResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createQueryResource: createQueryResource,\n  getQueryResourceForEnvironment: getQueryResourceForEnvironment,\n  getQueryCacheIdentifier: getQueryCacheIdentifier\n};","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/react-relay/lib/relay-hooks/QueryResource.js"],"names":["_interopRequireDefault","require","_objectSpread2","_defineProperty2","LRUCache","SuspenseResource","invariant","_require","RelayFeatureFlags","isPromise","warning","CACHE_CAPACITY","DEFAULT_FETCH_POLICY","WEAKMAP_SUPPORTED","WeakMap","operationIsLiveQuery","operation","request","node","params","metadata","live","undefined","getQueryCacheIdentifier","environment","maybeFetchPolicy","maybeRenderPolicy","cacheBreaker","fetchPolicy","renderPolicy","UNSTABLE_getDefaultRenderPolicy","cacheIdentifier","concat","identifier","getQueryResult","rootFragmentRef","__id","fragment","dataID","__fragments","name","variables","__fragmentOwner","fragmentNode","fragmentRef","nextID","createCacheEntry","operationAvailability","value","networkSubscription","onDispose","REFACTOR_SUSPENSE_RESOURCE","createCacheEntry_new","createCacheEntry_old","isLiveQuery","currentValue","currentNetworkSubscription","suspenseResource","retention","retain","dispose","unsubscribe","cacheEntry","id","processedPayloadsCount","getValue","setValue","val","getRetainCount","getNetworkSubscription","setNetworkSubscription","subscription","temporaryRetain","permanentRetain","releaseTemporaryRetain","DATA_RETENTION_TIMEOUT","retainCount","retainDisposable","_releaseTemporaryRetain","Math","max","process","env","NODE_ENV","isServer","disposable","releaseQueryTimeout","localReleaseTemporaryRetain","clearTimeout","setTimeout","QueryResourceImpl","_this","_cache","_environment","create","_proto","prototype","prepare","fetchObservable","observer","profilerContext","prepareWithIdentifier","get","temporaryRetainDisposable","entryWasCached","_fetchAndSaveQuery","observerUnsubscribe","cachedValue","__log","isPromiseCached","queryAvailability","Error","queryResult","_getOrCreateCacheEntry","resourceID","TESTS_ONLY__getCacheEntry","_clearCacheEntry","set","_this2","check","queryStatus","status","hasFullQuery","canPartialRender","shouldFetch","shouldAllowRender","resolveNetworkPromise","_cacheEntry","_queryResult","subscribe","start","observerStart","subscriptionWithConditionalCancelation","next","observerNext","snapshot","lookup","error","_error","message","stack","observerError","complete","observerComplete","_cacheEntry2","networkPromise","Promise","resolve","displayName","createQueryResource","dataResources","Map","getQueryResourceForEnvironment","cached","newDataResource","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar SuspenseResource = require('./SuspenseResource');\n\nvar invariant = require('invariant');\n\nvar _require = require('relay-runtime'),\n    RelayFeatureFlags = _require.RelayFeatureFlags,\n    isPromise = _require.isPromise;\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar CACHE_CAPACITY = 1000;\nvar DEFAULT_FETCH_POLICY = 'store-or-network';\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\n\nfunction operationIsLiveQuery(operation) {\n  return operation.request.node.params.metadata.live !== undefined;\n}\n\nfunction getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n  var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n  var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();\n  var cacheIdentifier = \"\".concat(fetchPolicy, \"-\").concat(renderPolicy, \"-\").concat(operation.request.identifier);\n\n  if (cacheBreaker != null) {\n    return \"\".concat(cacheIdentifier, \"-\").concat(cacheBreaker);\n  }\n\n  return cacheIdentifier;\n}\n\nfunction getQueryResult(operation, cacheIdentifier) {\n  var rootFragmentRef = {\n    __id: operation.fragment.dataID,\n    __fragments: (0, _defineProperty2[\"default\"])({}, operation.fragment.node.name, operation.request.variables),\n    __fragmentOwner: operation.request\n  };\n  return {\n    cacheIdentifier: cacheIdentifier,\n    fragmentNode: operation.request.node.fragment,\n    fragmentRef: rootFragmentRef,\n    operation: operation\n  };\n}\n\nvar nextID = 200000;\n\nfunction createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose) {\n  // There should be no behavior difference between createCacheEntry_new and\n  // createCacheEntry_old, and it doesn't directly relate to Client Edges.\n  // It was just a refactoring that was needed for Client Edges but that\n  // is behind the feature flag just in case there is any accidental breakage.\n  if (RelayFeatureFlags.REFACTOR_SUSPENSE_RESOURCE) {\n    return createCacheEntry_new(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose);\n  } else {\n    return createCacheEntry_old(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose);\n  }\n}\n\nfunction createCacheEntry_new(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose) {\n  var isLiveQuery = operationIsLiveQuery(operation);\n  var currentValue = value;\n  var currentNetworkSubscription = networkSubscription;\n  var suspenseResource = new SuspenseResource(function (environment) {\n    var retention = environment.retain(operation);\n    return {\n      dispose: function dispose() {\n        // Normally if this entry never commits, the request would've ended by the\n        // time this timeout expires and the temporary retain is released. However,\n        // we need to do this for live queries which remain open indefinitely.\n        if (isLiveQuery && currentNetworkSubscription != null) {\n          currentNetworkSubscription.unsubscribe();\n        }\n\n        retention.dispose();\n        onDispose(cacheEntry);\n      }\n    };\n  });\n  var cacheEntry = {\n    cacheIdentifier: cacheIdentifier,\n    id: nextID++,\n    processedPayloadsCount: 0,\n    operationAvailability: operationAvailability,\n    getValue: function getValue() {\n      return currentValue;\n    },\n    setValue: function setValue(val) {\n      currentValue = val;\n    },\n    getRetainCount: function getRetainCount() {\n      return suspenseResource.getRetainCount();\n    },\n    getNetworkSubscription: function getNetworkSubscription() {\n      return currentNetworkSubscription;\n    },\n    setNetworkSubscription: function setNetworkSubscription(subscription) {\n      if (isLiveQuery && currentNetworkSubscription != null) {\n        currentNetworkSubscription.unsubscribe();\n      }\n\n      currentNetworkSubscription = subscription;\n    },\n    temporaryRetain: function temporaryRetain(environment) {\n      return suspenseResource.temporaryRetain(environment);\n    },\n    permanentRetain: function permanentRetain(environment) {\n      return suspenseResource.permanentRetain(environment);\n    },\n    releaseTemporaryRetain: function releaseTemporaryRetain() {\n      suspenseResource.releaseTemporaryRetain();\n    }\n  };\n  return cacheEntry;\n}\n\nvar DATA_RETENTION_TIMEOUT = 5 * 60 * 1000;\n\nfunction createCacheEntry_old(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose) {\n  var isLiveQuery = operationIsLiveQuery(operation);\n  var currentValue = value;\n  var retainCount = 0;\n  var retainDisposable = null;\n  var _releaseTemporaryRetain = null;\n  var currentNetworkSubscription = networkSubscription;\n\n  var retain = function retain(environment) {\n    retainCount++;\n\n    if (retainCount === 1) {\n      retainDisposable = environment.retain(operation);\n    }\n\n    return {\n      dispose: function dispose() {\n        retainCount = Math.max(0, retainCount - 1);\n\n        if (retainCount === 0) {\n          !(retainDisposable != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected disposable to release query to be defined.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n          retainDisposable.dispose();\n          retainDisposable = null;\n        }\n\n        onDispose(cacheEntry);\n      }\n    };\n  };\n\n  var cacheEntry = {\n    cacheIdentifier: cacheIdentifier,\n    id: nextID++,\n    processedPayloadsCount: 0,\n    operationAvailability: operationAvailability,\n    getValue: function getValue() {\n      return currentValue;\n    },\n    setValue: function setValue(val) {\n      currentValue = val;\n    },\n    getRetainCount: function getRetainCount() {\n      return retainCount;\n    },\n    getNetworkSubscription: function getNetworkSubscription() {\n      return currentNetworkSubscription;\n    },\n    setNetworkSubscription: function setNetworkSubscription(subscription) {\n      if (isLiveQuery && currentNetworkSubscription != null) {\n        currentNetworkSubscription.unsubscribe();\n      }\n\n      currentNetworkSubscription = subscription;\n    },\n    temporaryRetain: function temporaryRetain(environment) {\n      // NOTE: If we're executing in a server environment, there's no need\n      // to create temporary retains, since the component will never commit.\n      if (environment.isServer()) {\n        return {\n          dispose: function dispose() {}\n        };\n      } // NOTE: temporaryRetain is called during the render phase. However,\n      // given that we can't tell if this render will eventually commit or not,\n      // we create a timer to autodispose of this retain in case the associated\n      // component never commits.\n      // If the component /does/ commit, permanentRetain will clear this timeout\n      // and permanently retain the data.\n\n\n      var disposable = retain(environment);\n      var releaseQueryTimeout = null;\n\n      var localReleaseTemporaryRetain = function localReleaseTemporaryRetain() {\n        clearTimeout(releaseQueryTimeout);\n        releaseQueryTimeout = null;\n        _releaseTemporaryRetain = null;\n        disposable.dispose(); // Normally if this entry never commits, the request would've ended by the\n        // time this timeout expires and the temporary retain is released. However,\n        // we need to do this for live queries which remain open indefinitely.\n\n        if (isLiveQuery && retainCount <= 0 && currentNetworkSubscription != null) {\n          currentNetworkSubscription.unsubscribe();\n        }\n      };\n\n      releaseQueryTimeout = setTimeout(localReleaseTemporaryRetain, DATA_RETENTION_TIMEOUT); // NOTE: Since temporaryRetain can be called multiple times, we release\n      // the previous temporary retain after we re-establish a new one, since\n      // we only ever need a single temporary retain until the permanent retain is\n      // established.\n      // temporaryRetain may be called multiple times by React during the render\n      // phase, as well as multiple times by other query components that are\n      // rendering the same query/variables.\n\n      if (_releaseTemporaryRetain != null) {\n        _releaseTemporaryRetain();\n      }\n\n      _releaseTemporaryRetain = localReleaseTemporaryRetain;\n      return {\n        dispose: function dispose() {\n          _releaseTemporaryRetain && _releaseTemporaryRetain();\n        }\n      };\n    },\n    permanentRetain: function permanentRetain(environment) {\n      var disposable = retain(environment);\n\n      if (_releaseTemporaryRetain != null) {\n        _releaseTemporaryRetain();\n\n        _releaseTemporaryRetain = null;\n      }\n\n      return {\n        dispose: function dispose() {\n          disposable.dispose();\n\n          if (isLiveQuery && retainCount <= 0 && currentNetworkSubscription != null) {\n            currentNetworkSubscription.unsubscribe();\n          }\n        }\n      };\n    },\n    releaseTemporaryRetain: function releaseTemporaryRetain() {\n      if (_releaseTemporaryRetain != null) {\n        _releaseTemporaryRetain();\n\n        _releaseTemporaryRetain = null;\n      }\n    }\n  };\n  return cacheEntry;\n}\n\nvar QueryResourceImpl = /*#__PURE__*/function () {\n  function QueryResourceImpl(environment) {\n    var _this = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_clearCacheEntry\", function (cacheEntry) {\n      // The new code does this retainCount <= 0 check within SuspenseResource\n      // before calling _clearCacheEntry, whereas with the old code we do it here.\n      if (RelayFeatureFlags.REFACTOR_SUSPENSE_RESOURCE) {\n        _this._cache[\"delete\"](cacheEntry.cacheIdentifier);\n      } else {\n        if (cacheEntry.getRetainCount() <= 0) {\n          _this._cache[\"delete\"](cacheEntry.cacheIdentifier);\n        }\n      }\n    });\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n  }\n\n  var _proto = QueryResourceImpl.prototype;\n\n  _proto.prepare = function prepare(operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, cacheBreaker, profilerContext) {\n    var cacheIdentifier = getQueryCacheIdentifier(this._environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this.prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext);\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to either read an existing cached value for the query, or fetch the query\n   * and suspend.\n   */\n  ;\n\n  _proto.prepareWithIdentifier = function prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext) {\n    var environment = this._environment;\n    var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n    var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy(); // 1. Check if there's a cached value for this operation, and reuse it if\n    // it's available\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    var temporaryRetainDisposable = null;\n    var entryWasCached = cacheEntry != null;\n\n    if (cacheEntry == null) {\n      // 2. If a cached value isn't available, try fetching the operation.\n      // _fetchAndSaveQuery will update the cache with either a Promise or\n      // an Error to throw, or a QueryResult to return.\n      cacheEntry = this._fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, observer), {}, {\n        unsubscribe: function unsubscribe(subscription) {\n          // 4. If the request is cancelled, make sure to dispose\n          // of the temporary retain; this will ensure that a promise\n          // doesn't remain unnecessarily cached until the temporary retain\n          // expires. Not clearing the temporary retain might cause the\n          // query to incorrectly re-suspend.\n          if (temporaryRetainDisposable != null) {\n            temporaryRetainDisposable.dispose();\n          }\n\n          var observerUnsubscribe = observer === null || observer === void 0 ? void 0 : observer.unsubscribe;\n          observerUnsubscribe && observerUnsubscribe(subscription);\n        }\n      }));\n    } // 3. Temporarily retain here in render phase. When the component reading\n    // the operation is committed, we will transfer ownership of data retention\n    // to the component.\n    // In case the component never commits (mounts or updates) from this render,\n    // this data retention hold will auto-release itself after a timeout.\n\n\n    temporaryRetainDisposable = cacheEntry.temporaryRetain(environment);\n    var cachedValue = cacheEntry.getValue();\n\n    if (isPromise(cachedValue)) {\n      environment.__log({\n        name: 'suspense.query',\n        fetchPolicy: fetchPolicy,\n        isPromiseCached: entryWasCached,\n        operation: operation,\n        queryAvailability: cacheEntry.operationAvailability,\n        renderPolicy: renderPolicy\n      });\n\n      throw cachedValue;\n    }\n\n    if (cachedValue instanceof Error) {\n      throw cachedValue;\n    }\n\n    return cachedValue;\n  }\n  /**\n   * This function should be called during a component's commit phase\n   * (e.g. inside useEffect), in order to retain the operation in the Relay store\n   * and transfer ownership of the operation to the component lifecycle.\n   */\n  ;\n\n  _proto.retain = function retain(queryResult, profilerContext) {\n    var environment = this._environment;\n    var cacheIdentifier = queryResult.cacheIdentifier,\n        operation = queryResult.operation;\n\n    var cacheEntry = this._getOrCreateCacheEntry(cacheIdentifier, operation, null, queryResult, null);\n\n    var disposable = cacheEntry.permanentRetain(environment);\n\n    environment.__log({\n      name: 'queryresource.retain',\n      profilerContext: profilerContext,\n      resourceID: cacheEntry.id\n    });\n\n    return {\n      dispose: function dispose() {\n        disposable.dispose();\n      }\n    };\n  };\n\n  _proto.releaseTemporaryRetain = function releaseTemporaryRetain(queryResult) {\n    var cacheEntry = this._cache.get(queryResult.cacheIdentifier);\n\n    if (cacheEntry != null) {\n      cacheEntry.releaseTemporaryRetain();\n    }\n  };\n\n  _proto.TESTS_ONLY__getCacheEntry = function TESTS_ONLY__getCacheEntry(operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n    var environment = this._environment;\n    var cacheIdentifier = getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this._cache.get(cacheIdentifier);\n  };\n\n  _proto._getOrCreateCacheEntry = function _getOrCreateCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription) {\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    if (cacheEntry == null) {\n      cacheEntry = createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, cacheEntry);\n    }\n\n    return cacheEntry;\n  };\n\n  _proto._fetchAndSaveQuery = function _fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, observer) {\n    var _this2 = this;\n\n    var environment = this._environment; // NOTE: Running `check` will write missing data to the store using any\n    // missing data handlers specified on the environment;\n    // We run it here first to make the handlers get a chance to populate\n    // missing data.\n\n    var queryAvailability = environment.check(operation);\n    var queryStatus = queryAvailability.status;\n    var hasFullQuery = queryStatus === 'available';\n    var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale';\n    var shouldFetch;\n    var shouldAllowRender;\n\n    var resolveNetworkPromise = function resolveNetworkPromise() {};\n\n    switch (fetchPolicy) {\n      case 'store-only':\n        {\n          shouldFetch = false;\n          shouldAllowRender = true;\n          break;\n        }\n\n      case 'store-or-network':\n        {\n          shouldFetch = !hasFullQuery;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'store-and-network':\n        {\n          shouldFetch = true;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'network-only':\n      default:\n        {\n          shouldFetch = true;\n          shouldAllowRender = false;\n          break;\n        }\n    } // NOTE: If this value is false, we will cache a promise for this\n    // query, which means we will suspend here at this query root.\n    // If it's true, we will cache the query resource and allow rendering to\n    // continue.\n\n\n    if (shouldAllowRender) {\n      var queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var _cacheEntry = createCacheEntry(cacheIdentifier, operation, queryAvailability, queryResult, null, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, _cacheEntry);\n    }\n\n    if (shouldFetch) {\n      var _queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var networkSubscription;\n      fetchObservable.subscribe({\n        start: function start(subscription) {\n          networkSubscription = subscription;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(networkSubscription);\n          }\n\n          var observerStart = observer === null || observer === void 0 ? void 0 : observer.start;\n\n          if (observerStart) {\n            var subscriptionWithConditionalCancelation = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, subscription), {}, {\n              unsubscribe: function unsubscribe() {\n                // Only live queries should have their network requests canceled.\n                if (operationIsLiveQuery(operation)) {\n                  subscription.unsubscribe();\n                }\n              }\n            });\n            observerStart(subscriptionWithConditionalCancelation);\n          }\n        },\n        next: function next() {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _queryResult, networkSubscription);\n\n          cacheEntry.processedPayloadsCount += 1;\n          cacheEntry.setValue(_queryResult);\n          resolveNetworkPromise();\n          var observerNext = observer === null || observer === void 0 ? void 0 : observer.next;\n\n          if (observerNext != null) {\n            var snapshot = environment.lookup(operation.fragment);\n            observerNext(snapshot);\n          }\n        },\n        error: function error(_error) {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _error, networkSubscription); // If, this is the first thing we receive for the query,\n          // before any other payload handled is error, we will cache and\n          // re-throw that error later.\n          // We will ignore errors for any incremental payloads we receive.\n\n\n          if (cacheEntry.processedPayloadsCount === 0) {\n            cacheEntry.setValue(_error);\n          } else {\n            // TODO:T92030819 Remove this warning and actually throw the network error\n            // To complete this task we need to have a way of precisely tracking suspendable points\n            process.env.NODE_ENV !== \"production\" ? warning(false, 'QueryResource: An incremental payload for query `%` returned an error: `%`:`%`.', operation.fragment.node.name, _error.message, _error.stack) : void 0;\n          }\n\n          resolveNetworkPromise();\n          networkSubscription = null;\n          cacheEntry.setNetworkSubscription(null);\n          var observerError = observer === null || observer === void 0 ? void 0 : observer.error;\n          observerError && observerError(_error);\n        },\n        complete: function complete() {\n          resolveNetworkPromise();\n          networkSubscription = null;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(null);\n          }\n\n          var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n          observerComplete && observerComplete();\n        },\n        unsubscribe: observer === null || observer === void 0 ? void 0 : observer.unsubscribe\n      });\n\n      var _cacheEntry2 = this._cache.get(cacheIdentifier);\n\n      if (!_cacheEntry2) {\n        var networkPromise = new Promise(function (resolve) {\n          resolveNetworkPromise = resolve;\n        }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n        networkPromise.displayName = 'Relay(' + operation.fragment.node.name + ')';\n        _cacheEntry2 = createCacheEntry(cacheIdentifier, operation, queryAvailability, networkPromise, networkSubscription, this._clearCacheEntry);\n\n        this._cache.set(cacheIdentifier, _cacheEntry2);\n      }\n    } else {\n      var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n      observerComplete && observerComplete();\n    }\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    !(cacheEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to have cached a result when attempting to fetch query.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n\n    environment.__log({\n      name: 'queryresource.fetch',\n      resourceID: cacheEntry.id,\n      operation: operation,\n      profilerContext: profilerContext,\n      fetchPolicy: fetchPolicy,\n      renderPolicy: renderPolicy,\n      queryAvailability: queryAvailability,\n      shouldFetch: shouldFetch\n    });\n\n    return cacheEntry;\n  };\n\n  return QueryResourceImpl;\n}();\n\nfunction createQueryResource(environment) {\n  return new QueryResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getQueryResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createQueryResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createQueryResource: createQueryResource,\n  getQueryResourceForEnvironment: getQueryResourceForEnvironment,\n  getQueryCacheIdentifier: getQueryCacheIdentifier\n};"]},"metadata":{},"sourceType":"script"}