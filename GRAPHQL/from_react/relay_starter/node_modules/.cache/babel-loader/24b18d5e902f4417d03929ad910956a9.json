{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _require = require('./RelayStoreUtils'),\n    getArgumentValues = _require.getArgumentValues;\n\nvar invariant = require('invariant');\n/**\n * Determines the variables that are in scope for a fragment given the variables\n * in scope at the root query as well as any arguments applied at the fragment\n * spread via `@arguments`.\n *\n * Note that this is analagous to determining function arguments given a function call.\n */\n\n\nfunction getFragmentVariables(fragment, rootVariables, argumentVariables) {\n  var variables;\n  fragment.argumentDefinitions.forEach(function (definition) {\n    if (argumentVariables.hasOwnProperty(definition.name)) {\n      return;\n    }\n\n    variables = variables || (0, _objectSpread2[\"default\"])({}, argumentVariables);\n\n    switch (definition.kind) {\n      case 'LocalArgument':\n        variables[definition.name] = definition.defaultValue;\n        break;\n\n      case 'RootArgument':\n        if (!rootVariables.hasOwnProperty(definition.name)) {\n          /*\n           * Global variables passed as values of @arguments are not required to\n           * be declared unless they are used by the callee fragment or a\n           * descendant. In this case, the root variable may not be defined when\n           * resolving the callee's variables. The value is explicitly set to\n           * undefined to conform to the check in\n           * RelayStoreUtils.getStableVariableValue() that variable keys are all\n           * present.\n           */\n          variables[definition.name] = undefined;\n          break;\n        }\n\n        variables[definition.name] = rootVariables[definition.name];\n        break;\n\n      default:\n        definition;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayConcreteVariables: Unexpected node kind `%s` in fragment `%s`.', definition.kind, fragment.name) : invariant(false) : void 0;\n    }\n  });\n  return variables || argumentVariables;\n}\n/**\n * Determines the variables that are in scope for a given operation given values\n * for some/all of its arguments.\n * - extraneous input variables are filtered from the output\n * - missing variables are set to default values (if given in the\n * operation's definition).\n * - variables with provider modules are added\n */\n\n\nfunction getOperationVariables(operation, providedVariables, variables) {\n  var operationVariables = {};\n  operation.argumentDefinitions.forEach(function (def) {\n    var value = def.defaultValue;\n\n    if (variables[def.name] != null) {\n      value = variables[def.name];\n    }\n\n    operationVariables[def.name] = value;\n  });\n\n  if (providedVariables != null) {\n    Object.keys(providedVariables).forEach(function (varName) {\n      operationVariables[varName] = providedVariables[varName].get();\n    });\n  }\n\n  return operationVariables;\n}\n\nfunction getLocalVariables(currentVariables, argumentDefinitions, args) {\n  if (argumentDefinitions == null) {\n    return currentVariables;\n  }\n\n  var nextVariables = (0, _objectSpread2[\"default\"])({}, currentVariables);\n  var nextArgs = args ? getArgumentValues(args, currentVariables) : {};\n  argumentDefinitions.forEach(function (def) {\n    var _nextArgs$def$name; // $FlowFixMe[cannot-write]\n\n\n    var value = (_nextArgs$def$name = nextArgs[def.name]) !== null && _nextArgs$def$name !== void 0 ? _nextArgs$def$name : def.defaultValue;\n    nextVariables[def.name] = value;\n  });\n  return nextVariables;\n}\n\nmodule.exports = {\n  getLocalVariables: getLocalVariables,\n  getFragmentVariables: getFragmentVariables,\n  getOperationVariables: getOperationVariables\n};","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js"],"names":["_interopRequireDefault","require","_objectSpread2","_require","getArgumentValues","invariant","getFragmentVariables","fragment","rootVariables","argumentVariables","variables","argumentDefinitions","forEach","definition","hasOwnProperty","name","kind","defaultValue","undefined","process","env","NODE_ENV","getOperationVariables","operation","providedVariables","operationVariables","def","value","Object","keys","varName","get","getLocalVariables","currentVariables","args","nextVariables","nextArgs","_nextArgs$def$name","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _require = require('./RelayStoreUtils'),\n    getArgumentValues = _require.getArgumentValues;\n\nvar invariant = require('invariant');\n/**\n * Determines the variables that are in scope for a fragment given the variables\n * in scope at the root query as well as any arguments applied at the fragment\n * spread via `@arguments`.\n *\n * Note that this is analagous to determining function arguments given a function call.\n */\n\n\nfunction getFragmentVariables(fragment, rootVariables, argumentVariables) {\n  var variables;\n  fragment.argumentDefinitions.forEach(function (definition) {\n    if (argumentVariables.hasOwnProperty(definition.name)) {\n      return;\n    }\n\n    variables = variables || (0, _objectSpread2[\"default\"])({}, argumentVariables);\n\n    switch (definition.kind) {\n      case 'LocalArgument':\n        variables[definition.name] = definition.defaultValue;\n        break;\n\n      case 'RootArgument':\n        if (!rootVariables.hasOwnProperty(definition.name)) {\n          /*\n           * Global variables passed as values of @arguments are not required to\n           * be declared unless they are used by the callee fragment or a\n           * descendant. In this case, the root variable may not be defined when\n           * resolving the callee's variables. The value is explicitly set to\n           * undefined to conform to the check in\n           * RelayStoreUtils.getStableVariableValue() that variable keys are all\n           * present.\n           */\n          variables[definition.name] = undefined;\n          break;\n        }\n\n        variables[definition.name] = rootVariables[definition.name];\n        break;\n\n      default:\n        definition;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayConcreteVariables: Unexpected node kind `%s` in fragment `%s`.', definition.kind, fragment.name) : invariant(false) : void 0;\n    }\n  });\n  return variables || argumentVariables;\n}\n/**\n * Determines the variables that are in scope for a given operation given values\n * for some/all of its arguments.\n * - extraneous input variables are filtered from the output\n * - missing variables are set to default values (if given in the\n * operation's definition).\n * - variables with provider modules are added\n */\n\n\nfunction getOperationVariables(operation, providedVariables, variables) {\n  var operationVariables = {};\n  operation.argumentDefinitions.forEach(function (def) {\n    var value = def.defaultValue;\n\n    if (variables[def.name] != null) {\n      value = variables[def.name];\n    }\n\n    operationVariables[def.name] = value;\n  });\n\n  if (providedVariables != null) {\n    Object.keys(providedVariables).forEach(function (varName) {\n      operationVariables[varName] = providedVariables[varName].get();\n    });\n  }\n\n  return operationVariables;\n}\n\nfunction getLocalVariables(currentVariables, argumentDefinitions, args) {\n  if (argumentDefinitions == null) {\n    return currentVariables;\n  }\n\n  var nextVariables = (0, _objectSpread2[\"default\"])({}, currentVariables);\n  var nextArgs = args ? getArgumentValues(args, currentVariables) : {};\n  argumentDefinitions.forEach(function (def) {\n    var _nextArgs$def$name;\n\n    // $FlowFixMe[cannot-write]\n    var value = (_nextArgs$def$name = nextArgs[def.name]) !== null && _nextArgs$def$name !== void 0 ? _nextArgs$def$name : def.defaultValue;\n    nextVariables[def.name] = value;\n  });\n  return nextVariables;\n}\n\nmodule.exports = {\n  getLocalVariables: getLocalVariables,\n  getFragmentVariables: getFragmentVariables,\n  getOperationVariables: getOperationVariables\n};"]},"metadata":{},"sourceType":"script"}