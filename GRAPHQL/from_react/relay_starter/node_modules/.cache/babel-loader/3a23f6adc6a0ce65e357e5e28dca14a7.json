{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar profileHandlersByName = {};\nvar defaultProfiler = {\n  stop: function stop() {}\n};\n/**\n * @public\n *\n * Instruments methods to allow profiling various parts of Relay. Profiling code\n * in Relay consists of three steps:\n *\n *  - Instrument the function to be profiled.\n *  - Attach handlers to the instrumented function.\n *  - Run the code which triggers the handlers.\n *\n * Handlers attached to instrumented methods are called with an instrumentation\n * name and a callback that must be synchronously executed:\n *\n *   instrumentedMethod.attachHandler(function(name, callback) {\n *     const start = performance.now();\n *     callback();\n *     console.log('Duration', performance.now() - start);\n *   });\n *\n * Handlers for profiles are callbacks that return a stop method:\n *\n *   RelayProfiler.attachProfileHandler('profileName', (name, state) => {\n *     const start = performance.now();\n *     return function stop(name, state) {\n *       console.log(`Duration (${name})`, performance.now() - start);\n *     }\n *   });\n */\n\nvar RelayProfiler = {\n  /**\n   * Instruments profiling for arbitrarily asynchronous code by a name.\n   *\n   *   const timerProfiler = RelayProfiler.profile('timeout');\n   *   setTimeout(function() {\n   *     timerProfiler.stop();\n   *   }, 1000);\n   *\n   *   RelayProfiler.attachProfileHandler('timeout', ...);\n   *\n   * Arbitrary state can also be passed into `profile` as a second argument. The\n   * attached profile handlers will receive this as the second argument.\n   */\n  profile: function profile(name, state) {\n    var handlers = profileHandlersByName[name];\n\n    if (handlers && handlers.length > 0) {\n      var stopHandlers = [];\n\n      for (var ii = handlers.length - 1; ii >= 0; ii--) {\n        var stopHandler = handlers[ii](name, state);\n        stopHandlers.unshift(stopHandler);\n      }\n\n      return {\n        stop: function stop(error) {\n          stopHandlers.forEach(function (stopHandler) {\n            return stopHandler(error);\n          });\n        }\n      };\n    }\n\n    return defaultProfiler;\n  },\n\n  /**\n   * Attaches a handler to profiles with the supplied name.\n   */\n  attachProfileHandler: function attachProfileHandler(name, handler) {\n    if (!profileHandlersByName.hasOwnProperty(name)) {\n      profileHandlersByName[name] = [];\n    }\n\n    profileHandlersByName[name].push(handler);\n  },\n\n  /**\n   * Detaches a handler attached via `attachProfileHandler`.\n   */\n  detachProfileHandler: function detachProfileHandler(name, handler) {\n    if (profileHandlersByName.hasOwnProperty(name)) {\n      removeFromArray(profileHandlersByName[name], handler);\n    }\n  }\n};\n\nfunction removeFromArray(array, element) {\n  var index = array.indexOf(element);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nmodule.exports = RelayProfiler;","map":{"version":3,"sources":["/home/ting/Desktop/Projects/tutorials/GRAPHQL/from_react/relay_starter/node_modules/relay-runtime/lib/util/RelayProfiler.js"],"names":["profileHandlersByName","defaultProfiler","stop","RelayProfiler","profile","name","state","handlers","length","stopHandlers","ii","stopHandler","unshift","error","forEach","attachProfileHandler","handler","hasOwnProperty","push","detachProfileHandler","removeFromArray","array","element","index","indexOf","splice","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,qBAAqB,GAAG,EAA5B;AACA,IAAIC,eAAe,GAAG;AACpBC,EAAAA,IAAI,EAAE,SAASA,IAAT,GAAgB,CAAE;AADJ,CAAtB;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,aAAa,GAAG;AAClB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,OAAO,EAAE,SAASA,OAAT,CAAiBC,IAAjB,EAAuBC,KAAvB,EAA8B;AACrC,QAAIC,QAAQ,GAAGP,qBAAqB,CAACK,IAAD,CAApC;;AAEA,QAAIE,QAAQ,IAAIA,QAAQ,CAACC,MAAT,GAAkB,CAAlC,EAAqC;AACnC,UAAIC,YAAY,GAAG,EAAnB;;AAEA,WAAK,IAAIC,EAAE,GAAGH,QAAQ,CAACC,MAAT,GAAkB,CAAhC,EAAmCE,EAAE,IAAI,CAAzC,EAA4CA,EAAE,EAA9C,EAAkD;AAChD,YAAIC,WAAW,GAAGJ,QAAQ,CAACG,EAAD,CAAR,CAAaL,IAAb,EAAmBC,KAAnB,CAAlB;AACAG,QAAAA,YAAY,CAACG,OAAb,CAAqBD,WAArB;AACD;;AAED,aAAO;AACLT,QAAAA,IAAI,EAAE,SAASA,IAAT,CAAcW,KAAd,EAAqB;AACzBJ,UAAAA,YAAY,CAACK,OAAb,CAAqB,UAAUH,WAAV,EAAuB;AAC1C,mBAAOA,WAAW,CAACE,KAAD,CAAlB;AACD,WAFD;AAGD;AALI,OAAP;AAOD;;AAED,WAAOZ,eAAP;AACD,GAnCiB;;AAqClB;AACF;AACA;AACEc,EAAAA,oBAAoB,EAAE,SAASA,oBAAT,CAA8BV,IAA9B,EAAoCW,OAApC,EAA6C;AACjE,QAAI,CAAChB,qBAAqB,CAACiB,cAAtB,CAAqCZ,IAArC,CAAL,EAAiD;AAC/CL,MAAAA,qBAAqB,CAACK,IAAD,CAArB,GAA8B,EAA9B;AACD;;AAEDL,IAAAA,qBAAqB,CAACK,IAAD,CAArB,CAA4Ba,IAA5B,CAAiCF,OAAjC;AACD,GA9CiB;;AAgDlB;AACF;AACA;AACEG,EAAAA,oBAAoB,EAAE,SAASA,oBAAT,CAA8Bd,IAA9B,EAAoCW,OAApC,EAA6C;AACjE,QAAIhB,qBAAqB,CAACiB,cAAtB,CAAqCZ,IAArC,CAAJ,EAAgD;AAC9Ce,MAAAA,eAAe,CAACpB,qBAAqB,CAACK,IAAD,CAAtB,EAA8BW,OAA9B,CAAf;AACD;AACF;AAvDiB,CAApB;;AA0DA,SAASI,eAAT,CAAyBC,KAAzB,EAAgCC,OAAhC,EAAyC;AACvC,MAAIC,KAAK,GAAGF,KAAK,CAACG,OAAN,CAAcF,OAAd,CAAZ;;AAEA,MAAIC,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChBF,IAAAA,KAAK,CAACI,MAAN,CAAaF,KAAb,EAAoB,CAApB;AACD;AACF;;AAEDG,MAAM,CAACC,OAAP,GAAiBxB,aAAjB","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar profileHandlersByName = {};\nvar defaultProfiler = {\n  stop: function stop() {}\n};\n/**\n * @public\n *\n * Instruments methods to allow profiling various parts of Relay. Profiling code\n * in Relay consists of three steps:\n *\n *  - Instrument the function to be profiled.\n *  - Attach handlers to the instrumented function.\n *  - Run the code which triggers the handlers.\n *\n * Handlers attached to instrumented methods are called with an instrumentation\n * name and a callback that must be synchronously executed:\n *\n *   instrumentedMethod.attachHandler(function(name, callback) {\n *     const start = performance.now();\n *     callback();\n *     console.log('Duration', performance.now() - start);\n *   });\n *\n * Handlers for profiles are callbacks that return a stop method:\n *\n *   RelayProfiler.attachProfileHandler('profileName', (name, state) => {\n *     const start = performance.now();\n *     return function stop(name, state) {\n *       console.log(`Duration (${name})`, performance.now() - start);\n *     }\n *   });\n */\n\nvar RelayProfiler = {\n  /**\n   * Instruments profiling for arbitrarily asynchronous code by a name.\n   *\n   *   const timerProfiler = RelayProfiler.profile('timeout');\n   *   setTimeout(function() {\n   *     timerProfiler.stop();\n   *   }, 1000);\n   *\n   *   RelayProfiler.attachProfileHandler('timeout', ...);\n   *\n   * Arbitrary state can also be passed into `profile` as a second argument. The\n   * attached profile handlers will receive this as the second argument.\n   */\n  profile: function profile(name, state) {\n    var handlers = profileHandlersByName[name];\n\n    if (handlers && handlers.length > 0) {\n      var stopHandlers = [];\n\n      for (var ii = handlers.length - 1; ii >= 0; ii--) {\n        var stopHandler = handlers[ii](name, state);\n        stopHandlers.unshift(stopHandler);\n      }\n\n      return {\n        stop: function stop(error) {\n          stopHandlers.forEach(function (stopHandler) {\n            return stopHandler(error);\n          });\n        }\n      };\n    }\n\n    return defaultProfiler;\n  },\n\n  /**\n   * Attaches a handler to profiles with the supplied name.\n   */\n  attachProfileHandler: function attachProfileHandler(name, handler) {\n    if (!profileHandlersByName.hasOwnProperty(name)) {\n      profileHandlersByName[name] = [];\n    }\n\n    profileHandlersByName[name].push(handler);\n  },\n\n  /**\n   * Detaches a handler attached via `attachProfileHandler`.\n   */\n  detachProfileHandler: function detachProfileHandler(name, handler) {\n    if (profileHandlersByName.hasOwnProperty(name)) {\n      removeFromArray(profileHandlersByName[name], handler);\n    }\n  }\n};\n\nfunction removeFromArray(array, element) {\n  var index = array.indexOf(element);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nmodule.exports = RelayProfiler;"]},"metadata":{},"sourceType":"script"}