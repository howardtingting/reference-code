/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @emails oncall+relay
 * @format
 */
// flowlint ambiguous-object-type:error
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _createForOfIteratorHelper2 = _interopRequireDefault(require("@babel/runtime/helpers/createForOfIteratorHelper"));

var _require = require('../query/GraphQLTag'),
    getRequest = _require.getRequest;

var _require2 = require('../store/RelayStoreUtils'),
    getArgumentValues = _require2.getArgumentValues;

var nonUpdatableKeys = ['id', '__id', '__typename', 'js'];

function readUpdatableQuery_EXPERIMENTAL(query, variables, proxy) {
  // TODO assert that the concrete request is an updatable query
  var request = getRequest(query);
  var updatableProxy = {};
  updateProxyFromSelections(updatableProxy, proxy.getRoot(), variables, request.fragment.selections, proxy);

  if (process.env.NODE_ENV !== "production") {
    Object.freeze(updatableProxy);
  }

  return updatableProxy;
}

function updateProxyFromSelections(mutableUpdatableProxy, recordProxy, queryVariables, selections, root) {
  var _selection$alias3;

  var _iterator = (0, _createForOfIteratorHelper2["default"])(selections),
      _step;

  try {
    var _loop = function _loop() {
      var selection = _step.value;

      switch (selection.kind) {
        case 'LinkedField':
          if (selection.plural) {
            Object.defineProperty(mutableUpdatableProxy, (_selection$alias = selection.alias) !== null && _selection$alias !== void 0 ? _selection$alias : selection.name, {
              // $FlowFixMe[incompatible-call] these getters and setters have different types on purpose
              get: createGetterForPluralLinkedField(selection, queryVariables, recordProxy, root),
              set: createSetterForPluralLinkedField(selection, queryVariables, recordProxy, root)
            });
          } else {
            Object.defineProperty(mutableUpdatableProxy, (_selection$alias2 = selection.alias) !== null && _selection$alias2 !== void 0 ? _selection$alias2 : selection.name, {
              get: createGetterForSingularLinkedField(selection, queryVariables, recordProxy, root),
              set: createSetterForSingularLinkedField(selection, queryVariables, recordProxy, root)
            });
          }

          break;

        case 'ScalarField':
          var scalarFieldName = (_selection$alias3 = selection.alias) !== null && _selection$alias3 !== void 0 ? _selection$alias3 : selection.name;
          Object.defineProperty(mutableUpdatableProxy, scalarFieldName, {
            get: function get() {
              var _selection$args;

              var variables = getArgumentValues((_selection$args = selection.args) !== null && _selection$args !== void 0 ? _selection$args : [], queryVariables); // Flow incorrect assumes that the return value for the get method must match
              // the set parameter.

              return recordProxy.getValue(selection.name, // $FlowFixMe[unclear-type] No good way to type these variables
              variables // $FlowFixMe[unclear-type] Typed by the generated updatable query flow type
              );
            },
            set: nonUpdatableKeys.includes(selection.name) ? undefined : // $FlowFixMe[unclear-type] Typed by the generated updatable query flow type
            function (newValue) {
              var _selection$args2;

              var variables = getArgumentValues((_selection$args2 = selection.args) !== null && _selection$args2 !== void 0 ? _selection$args2 : [], queryVariables);
              recordProxy.setValue(newValue, selection.name, // $FlowFixMe[unclear-type] No good way to type these variables
              variables);
            }
          });
          break;

        case 'InlineFragment':
          if (recordProxy.getType() === selection.type) {
            updateProxyFromSelections(mutableUpdatableProxy, recordProxy, queryVariables, selection.selections, root);
          }

          break;

        case 'ClientExtension':
          updateProxyFromSelections(mutableUpdatableProxy, recordProxy, queryVariables, selection.selections, root);
          break;

        case 'FragmentSpread':
          // Explicitly ignore
          break;

        default:
          throw new Error('Encountered an unexpected ReaderSelection variant in RelayRecordSourceProxy. This indicates a bug in Relay.');
      }
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _selection$alias;

      var _selection$alias2;

      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function createSetterForPluralLinkedField(selection, queryVariables, recordProxy, root) {
  return function set(newValue) {
    var _selection$args3;

    var variables = getArgumentValues((_selection$args3 = selection.args) !== null && _selection$args3 !== void 0 ? _selection$args3 : [], queryVariables);

    if (newValue == null) {
      throw new Error('Do not assign null to plural linked fields; assign an empty array instead.');
    } else {
      var recordProxies = newValue.map(function (item) {
        if (item == null) {
          throw new Error('When assigning an array of items, none of the items should be null or undefined.');
        }

        var __id = item.__id;

        if (__id == null) {
          throw new Error('The __id field must be present on each item passed to the setter. This indicates a bug in Relay.');
        }

        var newValueRecord = root.get(__id);

        if (newValueRecord == null) {
          throw new Error("Did not find item with data id ".concat(__id, " in the store."));
        }

        return newValueRecord;
      });
      recordProxy.setLinkedRecords(recordProxies, selection.name, // $FlowFixMe[unclear-type] No good way to type these variables
      variables);
    }
  };
}

function createSetterForSingularLinkedField(selection, queryVariables, recordProxy, root) {
  return function set(newValue) {
    var _selection$args4;

    var variables = getArgumentValues((_selection$args4 = selection.args) !== null && _selection$args4 !== void 0 ? _selection$args4 : [], queryVariables);

    if (newValue == null) {
      // $FlowFixMe[unclear-type] No good way to type these variables
      recordProxy.setValue(newValue, selection.name, variables);
    } else {
      var __id = newValue.__id;

      if (__id == null) {
        throw new Error('The __id field must be present on the argument. This indicates a bug in Relay.');
      }

      var newValueRecord = root.get(__id);

      if (newValueRecord == null) {
        throw new Error("Did not find item with data id ".concat(__id, " in the store."));
      }

      recordProxy.setLinkedRecord(newValueRecord, selection.name, // $FlowFixMe[unclear-type] No good way to type these variables
      variables);
    }
  };
}

function createGetterForPluralLinkedField(selection, queryVariables, recordProxy, root) {
  return function () {
    var _selection$args5;

    var variables = getArgumentValues((_selection$args5 = selection.args) !== null && _selection$args5 !== void 0 ? _selection$args5 : [], queryVariables);
    var linkedRecords = recordProxy.getLinkedRecords(selection.name, // $FlowFixMe[unclear-type] No good way to type these variables
    variables);

    if (linkedRecords != null) {
      return linkedRecords.map(function (linkedRecord) {
        if (linkedRecord != null) {
          var updatableProxy = {};
          updateProxyFromSelections(updatableProxy, linkedRecord, queryVariables, selection.selections, root);

          if (process.env.NODE_ENV !== "production") {
            Object.freeze(updatableProxy);
          } // Flow incorrect assumes that the return value for the get method must match
          // the set parameter.
          // $FlowFixMe[unclear-type] Typed by the generated updatable query flow type


          return updatableProxy;
        } else {
          return linkedRecord;
        } // $FlowFixMe[unclear-type] Typed by the generated updatable query flow type

      });
    } else {
      return linkedRecords;
    }
  };
}

function createGetterForSingularLinkedField(selection, queryVariables, recordProxy, root) {
  return function () {
    var _selection$args6;

    var variables = getArgumentValues((_selection$args6 = selection.args) !== null && _selection$args6 !== void 0 ? _selection$args6 : [], queryVariables);
    var linkedRecord = recordProxy.getLinkedRecord(selection.name, // $FlowFixMe[unclear-type] No good way to type these variables
    variables);

    if (linkedRecord != null) {
      var updatableProxy = {};
      updateProxyFromSelections(updatableProxy, linkedRecord, queryVariables, selection.selections, root);

      if (process.env.NODE_ENV !== "production") {
        Object.freeze(updatableProxy);
      } // Flow incorrect assumes that the return value for the get method must match
      // the set parameter.
      // $FlowFixMe[unclear-type] Typed by the generated updatable query flow type


      return updatableProxy;
    } else {
      return linkedRecord;
    }
  };
}

module.exports = {
  readUpdatableQuery_EXPERIMENTAL: readUpdatableQuery_EXPERIMENTAL
};